{
  "generated": "2026-02-02T23:08:29.396788",
  "modules": {
    "agents.cio_agent": {
      "name": "cio_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\cio_agent.py",
      "docstring": "CIO (Chief Investment Officer) Agent\n====================================\n\nTHE SINGLE DECISION-MAKING AUTHORITY.\n\nThis agent is the ONLY one authorized to make trading decisions.\nIt aggregates signals from all strategy agents and decides whether to trade.\n\nPer the constitution:\n- One and only one decision authority\n- Decisions must include rationale and data sources\n- All decisions are logged for compliance\n\nEnhanced features:\n- Kelly criterion position sizing\n- Dynamic signal weights (regime-dependent, performance-weighted)\n- Correlation-adjusted sizing\n- Performance attribution integration",
      "classes": [
        {
          "name": "MarketRegime",
          "module": "cio_agent",
          "docstring": "Market regime classification for weight adjustment.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 55
        },
        {
          "name": "SignalAggregation",
          "module": "cio_agent",
          "docstring": "Aggregated signals for decision making.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "signals",
              "type": "dict[str, SignalEvent]"
            },
            {
              "name": "weighted_strength",
              "type": "float"
            },
            {
              "name": "weighted_confidence",
              "type": "float"
            },
            {
              "name": "consensus_direction",
              "type": "SignalDirection"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "regime_adjusted",
              "type": "bool"
            },
            {
              "name": "correlation_adjusted",
              "type": "bool"
            },
            {
              "name": "effective_signal_count",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 66
        },
        {
          "name": "StrategyPerformance",
          "module": "cio_agent",
          "docstring": "Performance metrics for a strategy used in dynamic weighting.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "strategy",
              "type": "str"
            },
            {
              "name": "rolling_sharpe",
              "type": "float"
            },
            {
              "name": "win_rate",
              "type": "float"
            },
            {
              "name": "recent_pnl",
              "type": "float"
            },
            {
              "name": "signal_accuracy",
              "type": "float"
            },
            {
              "name": "last_update",
              "type": "datetime"
            },
            {
              "name": "avg_win",
              "type": "float"
            },
            {
              "name": "avg_loss",
              "type": "float"
            },
            {
              "name": "total_trades",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 80
        },
        {
          "name": "CIOAgent",
          "module": "cio_agent",
          "docstring": "Chief Investment Officer Agent.\n\nTHE ONLY DECISION-MAKING AUTHORITY IN THE SYSTEM.\n\nResponsibilities:\n1. Wait for signal barrier synchronization (fan-in)\n2. Aggregate signals from all strategy agents\n3. Apply portfolio-level constraints\n4. Make final trading decisions\n5. Log decisions with full rationale\n\nThis agent does NOT:\n- Generate signals (that's strategy agents' job)\n- Execute orders (that's execution agent's job)\n- Validate risk/compliance (that's risk agent's job)",
          "bases": [
            "DecisionAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "cio_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 113
            },
            {
              "name": "initialize",
              "module": "cio_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize CIO agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 203
            },
            {
              "name": "get_subscribed_events",
              "module": "cio_agent",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "CIO subscribes to validated decisions only - signals come via barrier.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 208
            },
            {
              "name": "start",
              "module": "cio_agent",
              "signature": "async def start(self) -> None",
              "docstring": "Start CIO agent with barrier monitoring loop.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 212
            },
            {
              "name": "stop",
              "module": "cio_agent",
              "signature": "async def stop(self) -> None",
              "docstring": "Stop CIO agent and cancel barrier monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 219
            },
            {
              "name": "_barrier_monitoring_loop",
              "module": "cio_agent",
              "signature": "async def _barrier_monitoring_loop(self) -> None",
              "docstring": "Monitor signal barrier for fan-in synchronization.\n\nThis is the correct fan-in implementation per CLAUDE.md:\n- Wait for ALL signal agents to report (or timeout)\n- Process signals together after synchronization\n- Avoid making decisions on partial signals",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 229
            },
            {
              "name": "_process_barrier_signals",
              "module": "cio_agent",
              "signature": "async def _process_barrier_signals(self, signals: dict[str, SignalEvent]) -> None",
              "docstring": "Process all signals from completed barrier (fan-in).\n\nGroups signals by symbol and makes decisions for each.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signals",
                  "type": "dict[str, SignalEvent]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 257
            },
            {
              "name": "process_event",
              "module": "cio_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process validated decision events.\n\nSignal processing is handled by the barrier monitoring loop,\nnot by individual event subscription (per CLAUDE.md fan-in).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 280
            },
            {
              "name": "_handle_validated_decision",
              "module": "cio_agent",
              "signature": "async def _handle_validated_decision(self, event: ValidatedDecisionEvent) -> None",
              "docstring": "Handle validated decision event - clean up tracking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "ValidatedDecisionEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 291
            },
            {
              "name": "_cleanup_stale_decisions",
              "module": "cio_agent",
              "signature": "def _cleanup_stale_decisions(self) -> None",
              "docstring": "Remove decisions older than timeout.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 301
            },
            {
              "name": "_make_decision_from_aggregation",
              "module": "cio_agent",
              "signature": "async def _make_decision_from_aggregation(self, agg: SignalAggregation) -> None",
              "docstring": "Make a trading decision from aggregated signals (post-barrier).\n\nThis is THE decision point - all decisions go through here.\nCalled only after barrier synchronization completes (fan-in).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agg",
                  "type": "SignalAggregation"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 312
            },
            {
              "name": "_aggregate_signals",
              "module": "cio_agent",
              "signature": "def _aggregate_signals(self, agg: SignalAggregation) -> None",
              "docstring": "Aggregate signals with dynamic weights and correlation adjustment (#Q5).\n\nFeatures:\n- Regime-dependent weight adjustment\n- Performance-weighted signals\n- Signal correlation adjustment (NEW)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agg",
                  "type": "SignalAggregation"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 426
            },
            {
              "name": "_update_dynamic_weights",
              "module": "cio_agent",
              "signature": "def _update_dynamic_weights(self) -> None",
              "docstring": "Update signal weights based on regime and performance.\n\nCombines:\n1. Base weights\n2. Regime-dependent adjustments\n3. Performance-based adjustments",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 488
            },
            {
              "name": "_record_signals_to_history",
              "module": "cio_agent",
              "signature": "def _record_signals_to_history(self, signals: dict[str, SignalEvent]) -> None",
              "docstring": "Record signals to history for correlation calculation (#Q5).\n\nConverts signal direction to numeric value for correlation calculation:\n- LONG = +1\n- SHORT = -1\n- FLAT = 0",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signals",
                  "type": "dict[str, SignalEvent]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 528
            },
            {
              "name": "_update_signal_correlations",
              "module": "cio_agent",
              "signature": "def _update_signal_correlations(self) -> None",
              "docstring": "Update the signal correlation matrix (#Q5).\n\nCalculates pairwise correlations between agent signals over the lookback period.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 560
            },
            {
              "name": "_calculate_signal_correlation",
              "module": "cio_agent",
              "signature": "def _calculate_signal_correlation(self, agent1: str, agent2: str)",
              "docstring": "Calculate correlation between two agents' signals (#Q5).\n\nUses the last N signals where both agents provided signals.\nReturns None if insufficient data.\n\nP1-12: Now properly aligns signals by timestamp instead of index.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent1",
                  "type": "str"
                },
                {
                  "name": "agent2",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 575
            },
            {
              "name": "_get_correlation_adjusted_weights",
              "module": "cio_agent",
              "signature": "def _get_correlation_adjusted_weights(self, signals: dict[str, SignalEvent]) -> dict[str, float]",
              "docstring": "Adjust signal weights to account for correlation (#Q5).\n\nHighly correlated signals should not be double-counted.\nUses a discount factor based on pairwise correlations.\n\nThe adjustment reduces the effective weight of signals that are\nhighly correlated with others, preventing overconfidence from\nredundant information.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signals",
                  "type": "dict[str, SignalEvent]"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 649
            },
            {
              "name": "_calculate_effective_signal_count",
              "module": "cio_agent",
              "signature": "def _calculate_effective_signal_count(self, signals: dict[str, SignalEvent]) -> float",
              "docstring": "Calculate effective number of independent signals (#Q5).\n\nSimilar to effective N in portfolio diversification.\nIf all signals are independent: effective_n = n\nIf all signals are perfectly correlated: effective_n = 1\n\nFormula: effective_n = (sum of weights)^2 / (sum of weights^2 adjusted for correlation)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signals",
                  "type": "dict[str, SignalEvent]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 718
            },
            {
              "name": "get_signal_correlations",
              "module": "cio_agent",
              "signature": "def get_signal_correlations(self) -> dict[str, Any]",
              "docstring": "Get signal correlation information for monitoring (#Q5).\n\nReturns:\n    Dictionary with correlation matrix and statistics",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 764
            },
            {
              "name": "_calculate_position_size",
              "module": "cio_agent",
              "signature": "def _calculate_position_size(self, agg: SignalAggregation) -> int",
              "docstring": "Calculate position size using Kelly criterion or conviction-based sizing.\n\nMethods:\n- Kelly criterion (f* = (bp - q) / b)\n- Conviction scaling\n- Correlation adjustment\n- Max position limits",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agg",
                  "type": "SignalAggregation"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 788
            },
            {
              "name": "_calculate_kelly_size",
              "module": "cio_agent",
              "signature": "def _calculate_kelly_size(self, agg: SignalAggregation) -> int",
              "docstring": "Calculate position size using Kelly criterion.\n\nKelly formula: f* = (bp - q) / b\nWhere:\n- b = avg_win / avg_loss (win/loss ratio)\n- p = win probability\n- q = 1 - p\n\nUses actual tracked statistics rather than estimation from Sharpe.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agg",
                  "type": "SignalAggregation"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 803
            },
            {
              "name": "_calculate_conviction_size",
              "module": "cio_agent",
              "signature": "def _calculate_conviction_size(self, agg: SignalAggregation) -> int",
              "docstring": "Calculate position size based on conviction (fallback method).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agg",
                  "type": "SignalAggregation"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 910
            },
            {
              "name": "_get_correlation_discount",
              "module": "cio_agent",
              "signature": "def _get_correlation_discount(self, symbol: str) -> float",
              "docstring": "Get correlation-based discount for position sizing.\n\nReduces size if highly correlated with existing positions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 925
            },
            {
              "name": "_build_rationale",
              "module": "cio_agent",
              "signature": "def _build_rationale(self, agg: SignalAggregation) -> str",
              "docstring": "Build decision rationale from contributing signals.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agg",
                  "type": "SignalAggregation"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 950
            },
            {
              "name": "_collect_data_sources",
              "module": "cio_agent",
              "signature": "def _collect_data_sources(self, agg: SignalAggregation) -> tuple[str, Ellipsis]",
              "docstring": "Collect all data sources from contributing signals.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agg",
                  "type": "SignalAggregation"
                }
              ],
              "return_type": "tuple[str, Ellipsis]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 969
            },
            {
              "name": "set_position_sizer",
              "module": "cio_agent",
              "signature": "def set_position_sizer(self, position_sizer) -> None",
              "docstring": "Set position sizer for Kelly criterion sizing.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position_sizer"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 980
            },
            {
              "name": "set_attribution",
              "module": "cio_agent",
              "signature": "def set_attribution(self, attribution) -> None",
              "docstring": "Set performance attribution for tracking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "attribution"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 985
            },
            {
              "name": "set_correlation_manager",
              "module": "cio_agent",
              "signature": "def set_correlation_manager(self, correlation_manager) -> None",
              "docstring": "Set correlation manager for correlation-adjusted sizing.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "correlation_manager"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 990
            },
            {
              "name": "set_risk_budget_manager",
              "module": "cio_agent",
              "signature": "def set_risk_budget_manager(self, risk_budget_manager) -> None",
              "docstring": "Set cross-strategy risk budget manager (#P3).\n\nEnables:\n- Risk budget allocation across strategies\n- Position rejection if strategy is over budget\n- Rebalancing trigger monitoring",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "risk_budget_manager"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 995
            },
            {
              "name": "set_portfolio_value",
              "module": "cio_agent",
              "signature": "def set_portfolio_value(self, value: float) -> None",
              "docstring": "Update portfolio value for position sizing.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1007
            },
            {
              "name": "update_price",
              "module": "cio_agent",
              "signature": "def update_price(self, symbol: str, price: float) -> None",
              "docstring": "Update price cache for a symbol.\n\nCalled by orchestrator when market data is received.\nRequired for accurate Kelly position sizing.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1011
            },
            {
              "name": "update_prices",
              "module": "cio_agent",
              "signature": "def update_prices(self, prices: dict[str, float]) -> None",
              "docstring": "Bulk update price cache.\n\nCalled by orchestrator with latest market prices.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1021
            },
            {
              "name": "set_market_regime",
              "module": "cio_agent",
              "signature": "def set_market_regime(self, regime: MarketRegime) -> None",
              "docstring": "Set current market regime.\n\nThis triggers recalculation of dynamic weights.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "regime",
                  "type": "MarketRegime"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1031
            },
            {
              "name": "update_strategy_performance",
              "module": "cio_agent",
              "signature": "def update_strategy_performance(self, strategy: str, rolling_sharpe: float, win_rate: float, recent_pnl: float, signal_accuracy: float, avg_win: float, avg_loss: float, total_trades: int) -> None",
              "docstring": "Update performance metrics for a strategy.\n\nCalled by the orchestrator or attribution system.\n\nArgs:\n    strategy: Strategy name\n    rolling_sharpe: Rolling Sharpe ratio\n    win_rate: Probability of winning trade (0-1)\n    recent_pnl: Recent P&L in dollars\n    signal_accuracy: Signal accuracy rate (0-1)\n    avg_win: Average profit on winning trades (dollars)\n    avg_loss: Average loss on losing trades (positive dollars)\n    total_trades: Total number of trades for statistical significance",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "rolling_sharpe",
                  "type": "float"
                },
                {
                  "name": "win_rate",
                  "type": "float"
                },
                {
                  "name": "recent_pnl",
                  "type": "float"
                },
                {
                  "name": "signal_accuracy",
                  "type": "float"
                },
                {
                  "name": "avg_win",
                  "type": "float"
                },
                {
                  "name": "avg_loss",
                  "type": "float"
                },
                {
                  "name": "total_trades",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1045
            },
            {
              "name": "get_current_weights",
              "module": "cio_agent",
              "signature": "def get_current_weights(self) -> dict[str, float]",
              "docstring": "Get current effective signal weights.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1099
            },
            {
              "name": "get_base_weights",
              "module": "cio_agent",
              "signature": "def get_base_weights(self) -> dict[str, float]",
              "docstring": "Get base (unadjusted) signal weights.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1103
            },
            {
              "name": "get_status",
              "module": "cio_agent",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get agent status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1107
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 94
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "core.position_sizing",
        "core.attribution",
        "core.correlation_manager",
        "core.risk_budget",
        "numpy"
      ],
      "dependencies": [
        "__future__",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "core.position_sizing",
        "core.attribution",
        "core.correlation_manager",
        "core.risk_budget",
        "numpy"
      ]
    },
    "agents.compliance_agent": {
      "name": "compliance_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\compliance_agent.py",
      "docstring": "Compliance Agent\n================\n\nRegulatory compliance validation for EU/AMF framework.\nValidates all trading decisions against regulatory requirements.\n\nResponsibility: Regulatory compliance ONLY.\nDoes NOT handle risk limits (see RiskAgent).",
      "classes": [
        {
          "name": "RejectionCode",
          "module": "compliance_agent",
          "docstring": "Compliance rejection codes.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 257
        },
        {
          "name": "BlackoutType",
          "module": "compliance_agent",
          "docstring": "Types of blackout periods.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 272
        },
        {
          "name": "BlackoutEvent",
          "module": "compliance_agent",
          "docstring": "A blackout event for a symbol.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "blackout_type",
              "type": "BlackoutType"
            },
            {
              "name": "event_date",
              "type": "datetime"
            },
            {
              "name": "blackout_start",
              "type": "datetime"
            },
            {
              "name": "blackout_end",
              "type": "datetime"
            },
            {
              "name": "description",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 281
        },
        {
          "name": "ComplianceCheckResult",
          "module": "compliance_agent",
          "docstring": "Result of a single compliance check.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "check_name",
              "type": "str"
            },
            {
              "name": "passed",
              "type": "bool"
            },
            {
              "name": "code",
              "type": "Optional[RejectionCode]"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "details",
              "type": "dict"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 292
        },
        {
          "name": "ComplianceValidationResult",
          "module": "compliance_agent",
          "docstring": "Complete result of compliance validation.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "approved",
              "type": "bool"
            },
            {
              "name": "checks",
              "type": "list[ComplianceCheckResult]"
            },
            {
              "name": "rejection_code",
              "type": "Optional[RejectionCode]"
            },
            {
              "name": "rejection_reason",
              "type": "Optional[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 302
        },
        {
          "name": "ComplianceAgent",
          "module": "compliance_agent",
          "docstring": "Compliance Agent for EU/AMF Regulatory Framework.\n\nValidates all trading decisions against:\n1. Blackout periods (earnings, M&A, corporate actions)\n2. Material Non-Public Information (MNPI) detection\n3. Restricted instruments (sanctions, embargos)\n4. Market hours\n5. Short Selling Regulation (SSR)\n6. Declaration thresholds (5%, 10%, etc.)\n7. Data source validation\n\nEnsures full audit trail per CLAUDE.md requirements.",
          "bases": [
            "ValidationAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "compliance_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 340
            },
            {
              "name": "set_compliance_notifier",
              "module": "compliance_agent",
              "signature": "def set_compliance_notifier(self, compliance_notifier) -> None",
              "docstring": "Set compliance officer notifier (#C33).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "compliance_notifier"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 398
            },
            {
              "name": "initialize",
              "module": "compliance_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize compliance agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 403
            },
            {
              "name": "get_subscribed_events",
              "module": "compliance_agent",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Compliance agent subscribes to decisions and validated decisions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 440
            },
            {
              "name": "process_event",
              "module": "compliance_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Validate decisions for regulatory compliance.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 445
            },
            {
              "name": "_validate_compliance",
              "module": "compliance_agent",
              "signature": "async def _validate_compliance(self, decision: dict, risk_event: ValidatedDecisionEvent) -> ComplianceValidationResult",
              "docstring": "Run all compliance checks.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "dict"
                },
                {
                  "name": "risk_event",
                  "type": "ValidatedDecisionEvent"
                }
              ],
              "return_type": "ComplianceValidationResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 523
            },
            {
              "name": "_check_restricted_instrument",
              "module": "compliance_agent",
              "signature": "def _check_restricted_instrument(self, symbol: str) -> ComplianceCheckResult",
              "docstring": "Check if instrument is on restricted list.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 623
            },
            {
              "name": "_check_blackout_period",
              "module": "compliance_agent",
              "signature": "async def _check_blackout_period(self, symbol: str) -> ComplianceCheckResult",
              "docstring": "Check if symbol is in blackout period.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 638
            },
            {
              "name": "_check_mnpi",
              "module": "compliance_agent",
              "signature": "async def _check_mnpi(self, decision: dict) -> ComplianceCheckResult",
              "docstring": "Check for Material Non-Public Information.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "dict"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 663
            },
            {
              "name": "_check_market_hours",
              "module": "compliance_agent",
              "signature": "def _check_market_hours(self, symbol: str) -> ComplianceCheckResult",
              "docstring": "Check if market is open with proper timezone handling.\n\nConverts UTC time to market timezone (ET for US markets) before checking.\nSupports extended hours trading if configured.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 698
            },
            {
              "name": "_check_trading_suspended",
              "module": "compliance_agent",
              "signature": "def _check_trading_suspended(self, symbol: str) -> ComplianceCheckResult",
              "docstring": "Check if trading is suspended for symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 765
            },
            {
              "name": "_check_ssr",
              "module": "compliance_agent",
              "signature": "async def _check_ssr(self, symbol: str) -> ComplianceCheckResult",
              "docstring": "Check Short Selling Regulation restrictions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 780
            },
            {
              "name": "_check_declaration_threshold",
              "module": "compliance_agent",
              "signature": "async def _check_declaration_threshold(self, symbol: str, decision: dict) -> ComplianceCheckResult",
              "docstring": "Check if order would trigger declaration threshold.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "decision",
                  "type": "dict"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 795
            },
            {
              "name": "_check_data_sources",
              "module": "compliance_agent",
              "signature": "def _check_data_sources(self, decision: dict) -> ComplianceCheckResult",
              "docstring": "Validate that all data sources are approved.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "dict"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 832
            },
            {
              "name": "_alert_mnpi_detected",
              "module": "compliance_agent",
              "signature": "async def _alert_mnpi_detected(self, decision: dict, check_result: ComplianceCheckResult) -> None",
              "docstring": "Alert compliance officer about potential MNPI.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "dict"
                },
                {
                  "name": "check_result",
                  "type": "ComplianceCheckResult"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 860
            },
            {
              "name": "_cache_decision",
              "module": "compliance_agent",
              "signature": "def _cache_decision(self, decision) -> None",
              "docstring": "Cache a decision event for later compliance lookup.\n\nArgs:\n    decision: DecisionEvent to cache",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 877
            },
            {
              "name": "_get_original_decision",
              "module": "compliance_agent",
              "signature": "async def _get_original_decision(self, decision_id: str) -> Optional[dict]",
              "docstring": "Get original decision details from cache.\n\nThis is used to retrieve the full decision context when\nperforming compliance checks on a validated decision.\n\nArgs:\n    decision_id: The ID of the decision to retrieve\n\nReturns:\n    Decision dict if found, None otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision_id",
                  "type": "str"
                }
              ],
              "return_type": "Optional[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 910
            },
            {
              "name": "_load_blackout_calendar",
              "module": "compliance_agent",
              "signature": "async def _load_blackout_calendar(self) -> None",
              "docstring": "Load blackout calendar from external source.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 945
            },
            {
              "name": "_load_restricted_list",
              "module": "compliance_agent",
              "signature": "async def _load_restricted_list(self) -> None",
              "docstring": "Load restricted instruments list.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 967
            },
            {
              "name": "add_blackout_event",
              "module": "compliance_agent",
              "signature": "def add_blackout_event(self, event: BlackoutEvent) -> None",
              "docstring": "Add a blackout event to the calendar.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "BlackoutEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 973
            },
            {
              "name": "add_restricted_instrument",
              "module": "compliance_agent",
              "signature": "def add_restricted_instrument(self, symbol: str) -> None",
              "docstring": "Add instrument to restricted list.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 980
            },
            {
              "name": "activate_ssr",
              "module": "compliance_agent",
              "signature": "def activate_ssr(self, symbol: str) -> None",
              "docstring": "Activate Short Selling Regulation for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 985
            },
            {
              "name": "deactivate_ssr",
              "module": "compliance_agent",
              "signature": "def deactivate_ssr(self, symbol: str) -> None",
              "docstring": "Deactivate Short Selling Regulation for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 990
            },
            {
              "name": "suspend_trading",
              "module": "compliance_agent",
              "signature": "def suspend_trading(self, symbol: str) -> None",
              "docstring": "Suspend trading for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 995
            },
            {
              "name": "resume_trading",
              "module": "compliance_agent",
              "signature": "def resume_trading(self, symbol: str) -> None",
              "docstring": "Resume trading for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1000
            },
            {
              "name": "validate_entity_lei",
              "module": "compliance_agent",
              "signature": "def validate_entity_lei(self) -> ComplianceCheckResult",
              "docstring": "Validate the entity's LEI for transaction reporting.\n\nRequired for ESMA transaction reporting (RTS 22/23).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1005
            },
            {
              "name": "validate_counterparty_lei",
              "module": "compliance_agent",
              "signature": "def validate_counterparty_lei(self, lei: str) -> ComplianceCheckResult",
              "docstring": "Validate a counterparty's LEI.\n\nArgs:\n    lei: The counterparty's LEI to validate\n\nReturns:\n    ComplianceCheckResult with validation status",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lei",
                  "type": "str"
                }
              ],
              "return_type": "ComplianceCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1035
            },
            {
              "name": "set_entity_lei",
              "module": "compliance_agent",
              "signature": "def set_entity_lei(self, lei: str) -> bool",
              "docstring": "Set the entity's LEI after validation.\n\nReturns True if LEI is valid and was set.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lei",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1062
            },
            {
              "name": "add_isin_mapping",
              "module": "compliance_agent",
              "signature": "def add_isin_mapping(self, symbol: str, isin: str) -> bool",
              "docstring": "Add an ISIN mapping for a symbol.\n\nArgs:\n    symbol: Trading symbol (e.g., \"AAPL\")\n    isin: ISIN code (e.g., \"US0378331005\")\n\nReturns:\n    True if ISIN is valid and was added",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "isin",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1077
            },
            {
              "name": "get_isin",
              "module": "compliance_agent",
              "signature": "def get_isin(self, symbol: str)",
              "docstring": "Get ISIN for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1097
            },
            {
              "name": "_validate_isin",
              "module": "compliance_agent",
              "signature": "def _validate_isin(self, isin: str) -> tuple[bool, str]",
              "docstring": "Validate an ISIN (International Securities Identification Number).\n\nISIN format:\n- 12 characters total\n- Characters 1-2: Country code (ISO 3166-1 alpha-2)\n- Characters 3-11: NSIN (National Securities Identifying Number)\n- Character 12: Check digit (Luhn algorithm)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "isin",
                  "type": "str"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1101
            },
            {
              "name": "get_status",
              "module": "compliance_agent",
              "signature": "def get_status(self) -> dict",
              "docstring": "Get current compliance agent status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1151
            },
            {
              "name": "_get_rejection_breakdown",
              "module": "compliance_agent",
              "signature": "def _get_rejection_breakdown(self, rejections: list[tuple[datetime, RejectionCode, str]]) -> dict[str, int]",
              "docstring": "Get breakdown of rejections by code.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "rejections",
                  "type": "list[tuple[datetime, RejectionCode, str]]"
                }
              ],
              "return_type": "dict[str, int]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1173
            }
          ],
          "class_attributes": [
            {
              "name": "APPROVED_SOURCES",
              "type": "Set[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 310
        }
      ],
      "functions": [
        {
          "name": "validate_lei",
          "module": "compliance_agent",
          "signature": "def validate_lei(lei: str, strict: bool) -> tuple[bool, str]",
          "docstring": "Validate a Legal Entity Identifier (LEI) per ISO 17442 standard.\n\nLEI format:\n- 20 characters total\n- Characters 1-4: LOU (Local Operating Unit) prefix\n- Characters 5-6: Reserved (usually \"00\")\n- Characters 7-18: Entity-specific part\n- Characters 19-20: Check digits (MOD 97-10)\n\nArgs:\n    lei: The LEI string to validate\n    strict: If True, also check for placeholder patterns\n\nReturns:\n    Tuple of (is_valid, error_message)",
          "parameters": [
            {
              "name": "lei",
              "type": "str"
            },
            {
              "name": "strict",
              "type": "bool"
            }
          ],
          "return_type": "tuple[bool, str]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 76
        },
        {
          "name": "validate_lei_against_gleif",
          "module": "compliance_agent",
          "signature": "async def validate_lei_against_gleif(lei: str) -> tuple[bool, str, dict]",
          "docstring": "Validate LEI against GLEIF (Global LEI Foundation) API.\n\nThis provides authoritative validation that the LEI:\n- Exists in the global registry\n- Is currently active (not lapsed/retired)\n- Belongs to the expected entity\n\nArgs:\n    lei: The LEI to validate\n\nReturns:\n    Tuple of (is_valid, error_message, entity_data)\n\nNote:\n    Requires network access to GLEIF API.\n    For production, implement proper caching and rate limiting.",
          "parameters": [
            {
              "name": "lei",
              "type": "str"
            }
          ],
          "return_type": "tuple[bool, str, dict]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": true,
          "line_number": 151
        },
        {
          "name": "calculate_lei_check_digits",
          "module": "compliance_agent",
          "signature": "def calculate_lei_check_digits(lei_without_check: str) -> str",
          "docstring": "Calculate the check digits for an LEI (for generating LEIs).\n\nArgs:\n    lei_without_check: First 18 characters of LEI\n\nReturns:\n    2-character check digit string",
          "parameters": [
            {
              "name": "lei_without_check",
              "type": "str"
            }
          ],
          "return_type": "str",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 226
        }
      ],
      "constants": [
        {
          "name": "VALID_LOU_PREFIXES",
          "line": 46
        },
        {
          "name": "PLACEHOLDER_LEI_PATTERNS",
          "line": 66
        }
      ],
      "imports": [
        "__future__",
        "logging",
        "re",
        "dataclasses",
        "datetime",
        "typing",
        "enum",
        "zoneinfo",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "aiohttp",
        "core.events"
      ],
      "dependencies": [
        "__future__",
        "zoneinfo",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "aiohttp",
        "core.events"
      ]
    },
    "agents.execution_agent": {
      "name": "execution_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\execution_agent.py",
      "docstring": "Execution Agent\n===============\n\nTHE ONLY AGENT AUTHORIZED TO SEND ORDERS TO THE BROKER.\n\nReceives validated decisions and executes them via Interactive Brokers.\nImplements execution algorithms (TWAP, VWAP) to minimize market impact.\n\nResponsibility: Order execution ONLY.\nDoes NOT make trading decisions.",
      "classes": [
        {
          "name": "OrderBookLevel",
          "module": "execution_agent",
          "docstring": "Single level in order book.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "price",
              "type": "float"
            },
            {
              "name": "size",
              "type": "int"
            },
            {
              "name": "num_orders",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 54
        },
        {
          "name": "OrderBookSnapshot",
          "module": "execution_agent",
          "docstring": "Order book snapshot for depth analysis (#E15).\n\nTracks bid/ask levels and derived metrics.",
          "bases": [],
          "methods": [
            {
              "name": "best_bid",
              "module": "execution_agent",
              "signature": "def best_bid(self)",
              "docstring": "Best bid price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 74
            },
            {
              "name": "best_ask",
              "module": "execution_agent",
              "signature": "def best_ask(self)",
              "docstring": "Best ask price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 79
            },
            {
              "name": "mid_price",
              "module": "execution_agent",
              "signature": "def mid_price(self)",
              "docstring": "Mid-point price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 84
            },
            {
              "name": "spread_bps",
              "module": "execution_agent",
              "signature": "def spread_bps(self)",
              "docstring": "Bid-ask spread in basis points.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 91
            },
            {
              "name": "total_bid_depth",
              "module": "execution_agent",
              "signature": "def total_bid_depth(self, n_levels: ) -> int",
              "docstring": "Total bid size up to n_levels.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n_levels",
                  "type": ""
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 97
            },
            {
              "name": "total_ask_depth",
              "module": "execution_agent",
              "signature": "def total_ask_depth(self, n_levels: ) -> int",
              "docstring": "Total ask size up to n_levels.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n_levels",
                  "type": ""
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 102
            },
            {
              "name": "depth_imbalance",
              "module": "execution_agent",
              "signature": "def depth_imbalance(self, n_levels: int) -> float",
              "docstring": "Order book imbalance ratio.\n\nPositive = more bid depth (buy pressure)\nNegative = more ask depth (sell pressure)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n_levels",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 107
            },
            {
              "name": "vwap_to_size",
              "module": "execution_agent",
              "signature": "def vwap_to_size(self, side: str, target_size: int) -> tuple[float, int]",
              "docstring": "Calculate VWAP and filled size to execute target_size.\n\nArgs:\n    side: 'buy' (consume asks) or 'sell' (consume bids)\n    target_size: Target quantity\n\nReturns:\n    (vwap, filled_size) tuple",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "target_size",
                  "type": "int"
                }
              ],
              "return_type": "tuple[float, int]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 121
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "bids",
              "type": "list[OrderBookLevel]"
            },
            {
              "name": "asks",
              "type": "list[OrderBookLevel]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 62
        },
        {
          "name": "FillCategory",
          "module": "execution_agent",
          "docstring": "Categorization of a fill as passive or aggressive (#E20).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "is_aggressive",
              "type": "bool"
            },
            {
              "name": "category",
              "type": "str"
            },
            {
              "name": "price_vs_arrival_bps",
              "type": "float"
            },
            {
              "name": "price_vs_spread_position",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 150
        },
        {
          "name": "MarketImpactEstimate",
          "module": "execution_agent",
          "docstring": "Estimated market impact for an order (#E21).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "temporary_impact_bps",
              "type": "float"
            },
            {
              "name": "permanent_impact_bps",
              "type": "float"
            },
            {
              "name": "total_impact_bps",
              "type": "float"
            },
            {
              "name": "estimated_cost",
              "type": "float"
            },
            {
              "name": "model_used",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 159
        },
        {
          "name": "SliceFill",
          "module": "execution_agent",
          "docstring": "Tracks fills for a single TWAP/VWAP slice (#E4, #E5).",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "execution_agent",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 184
            },
            {
              "name": "add_fill",
              "module": "execution_agent",
              "signature": "def add_fill(self, quantity: int, price: float) -> None",
              "docstring": "Add a fill to this slice.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 187
            },
            {
              "name": "fill_rate",
              "module": "execution_agent",
              "signature": "def fill_rate(self) -> float",
              "docstring": "Percentage of target quantity filled.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 204
            },
            {
              "name": "slippage_bps",
              "module": "execution_agent",
              "signature": "def slippage_bps(self)",
              "docstring": "Calculate slippage in basis points vs arrival price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 211
            },
            {
              "name": "price_improvement_bps",
              "module": "execution_agent",
              "signature": "def price_improvement_bps(self)",
              "docstring": "Calculate price improvement in basis points (#E5).\n\nPrice improvement occurs when:\n- For buys: fill_price < arrival_price (paid less)\n- For sells: fill_price > arrival_price (received more)\n\nReturns positive value if there was improvement, negative if there was slippage.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 218
            },
            {
              "name": "has_price_improvement",
              "module": "execution_agent",
              "signature": "def has_price_improvement(self) -> bool",
              "docstring": "Check if fill received price improvement (#E5).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 243
            }
          ],
          "class_attributes": [
            {
              "name": "slice_index",
              "type": "int"
            },
            {
              "name": "broker_order_id",
              "type": "int"
            },
            {
              "name": "target_quantity",
              "type": "int"
            },
            {
              "name": "filled_quantity",
              "type": "int"
            },
            {
              "name": "avg_fill_price",
              "type": "float"
            },
            {
              "name": "fills",
              "type": "list[tuple[datetime, int, float]]"
            },
            {
              "name": "arrival_price",
              "type": ""
            },
            {
              "name": "is_complete",
              "type": "bool"
            },
            {
              "name": "is_buy",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 172
        },
        {
          "name": "PendingOrder",
          "module": "execution_agent",
          "docstring": "Tracks a pending order with state machine and slice-level fills (#E4).",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "execution_agent",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 266
            },
            {
              "name": "register_slice",
              "module": "execution_agent",
              "signature": "def register_slice(self, broker_id: int, target_quantity: int, arrival_price: , is_buy: bool) -> None",
              "docstring": "Register a new slice for tracking (#E4, #E5).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "broker_id",
                  "type": "int"
                },
                {
                  "name": "target_quantity",
                  "type": "int"
                },
                {
                  "name": "arrival_price",
                  "type": ""
                },
                {
                  "name": "is_buy",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 273
            },
            {
              "name": "get_slice_fill",
              "module": "execution_agent",
              "signature": "def get_slice_fill(self, broker_id: int)",
              "docstring": "Get fill info for a specific slice.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "broker_id",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 291
            },
            {
              "name": "add_slice_fill",
              "module": "execution_agent",
              "signature": "def add_slice_fill(self, broker_id: int, quantity: int, price: float) -> bool",
              "docstring": "Add a fill to a slice and update totals (#E4).\n\nReturns True if this was a known slice, False otherwise.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "broker_id",
                  "type": "int"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 295
            },
            {
              "name": "transition_state",
              "module": "execution_agent",
              "signature": "def transition_state(self, new_state: OrderState, reason: str) -> bool",
              "docstring": "Attempt to transition to a new state.\n\nReturns True if transition is valid and was applied.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "new_state",
                  "type": "OrderState"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 307
            },
            {
              "name": "is_terminal",
              "module": "execution_agent",
              "signature": "def is_terminal(self) -> bool",
              "docstring": "Check if order is in a terminal state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 330
            }
          ],
          "class_attributes": [
            {
              "name": "order_event",
              "type": "OrderEvent"
            },
            {
              "name": "decision_event",
              "type": "DecisionEvent"
            },
            {
              "name": "broker_order_id",
              "type": ""
            },
            {
              "name": "filled_quantity",
              "type": "int"
            },
            {
              "name": "remaining_quantity",
              "type": "int"
            },
            {
              "name": "avg_fill_price",
              "type": "float"
            },
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "state",
              "type": "OrderState"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "slices",
              "type": "list[int]"
            },
            {
              "name": "slice_fills",
              "type": "dict[int, SliceFill]"
            },
            {
              "name": "state_history",
              "type": "list[tuple[datetime, OrderState, str]]"
            },
            {
              "name": "arrival_price",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 250
        },
        {
          "name": "ExecutionAgentImpl",
          "module": "execution_agent",
          "docstring": "Execution Agent Implementation.\n\nTHE ONLY AGENT THAT CAN SEND ORDERS TO INTERACTIVE BROKERS.\n\nExecution algorithms:\n- MARKET: Immediate execution at market price\n- TWAP: Time-weighted average price\n- VWAP: Volume-weighted average price (simplified)\n\nAll orders are logged for audit compliance.",
          "bases": [
            "ExecutionAgentBase"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "execution_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger, broker: IBBroker)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                },
                {
                  "name": "broker",
                  "type": "IBBroker"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 355
            },
            {
              "name": "initialize",
              "module": "execution_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize execution agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 437
            },
            {
              "name": "get_subscribed_events",
              "module": "execution_agent",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Execution agent subscribes to validated decisions and kill switch.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 444
            },
            {
              "name": "process_event",
              "module": "execution_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process validated decisions and execute orders.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 448
            },
            {
              "name": "_handle_kill_switch",
              "module": "execution_agent",
              "signature": "async def _handle_kill_switch(self, event: KillSwitchEvent) -> None",
              "docstring": "Handle kill switch activation/deactivation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "KillSwitchEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 490
            },
            {
              "name": "_cancel_all_pending_orders",
              "module": "execution_agent",
              "signature": "async def _cancel_all_pending_orders(self, reason: str) -> None",
              "docstring": "Cancel all pending orders (kill switch response).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 511
            },
            {
              "name": "_enforce_tick_size",
              "module": "execution_agent",
              "signature": "def _enforce_tick_size(self, symbol: str, price: )",
              "docstring": "Round price to nearest valid tick for the symbol.\n\nArgs:\n    symbol: Contract symbol\n    price: Price to round\n\nReturns:\n    Tick-aligned price, or original price if symbol not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 526
            },
            {
              "name": "_execute_decision",
              "module": "execution_agent",
              "signature": "async def _execute_decision(self, decision: DecisionEvent, quantity: int, validation: ValidatedDecisionEvent) -> None",
              "docstring": "Execute a validated trading decision.\n\nThis is THE execution point - all orders go through here.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "validation",
                  "type": "ValidatedDecisionEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 547
            },
            {
              "name": "_execute_market",
              "module": "execution_agent",
              "signature": "async def _execute_market(self, pending: PendingOrder) -> None",
              "docstring": "Execute order immediately at market price with slippage protection (#E6).\n\nInstead of a pure market order, uses an aggressive limit order with\na price cap to prevent excessive slippage. The limit price is set at\narrival_price +/- max_slippage_bps based on order direction.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pending",
                  "type": "PendingOrder"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 627
            },
            {
              "name": "_get_lot_size",
              "module": "execution_agent",
              "signature": "def _get_lot_size(self, symbol: str) -> int",
              "docstring": "Get the lot size for a symbol (#E9).\n\nDifferent instruments have different minimum trading quantities:\n- Stocks: Usually 1 share (but some prefer round lots of 100)\n- Futures: Contract-specific (e.g., ES=1, crude oil=1)\n- Options: Usually 1 contract (100 shares underlying)\n\nReturns:\n    Minimum lot size for the symbol",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 699
            },
            {
              "name": "_round_to_lot_size",
              "module": "execution_agent",
              "signature": "def _round_to_lot_size(self, quantity: int, lot_size: int, round_up: bool) -> int",
              "docstring": "Round quantity to the nearest lot size (#E9).\n\nArgs:\n    quantity: Desired quantity\n    lot_size: Lot size to round to\n    round_up: If True, always round up; if False, round to nearest\n\nReturns:\n    Rounded quantity",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "lot_size",
                  "type": "int"
                },
                {
                  "name": "round_up",
                  "type": "bool"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 735
            },
            {
              "name": "_execute_twap",
              "module": "execution_agent",
              "signature": "async def _execute_twap(self, pending: PendingOrder) -> None",
              "docstring": "Execute order using Time-Weighted Average Price algorithm.\n\nSplits order into equal slices over time to minimize market impact.\nProperly handles lot sizes for different instrument types (#E9).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pending",
                  "type": "PendingOrder"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 758
            },
            {
              "name": "update_market_volume",
              "module": "execution_agent",
              "signature": "def update_market_volume(self, symbol: str, volume: int) -> None",
              "docstring": "Update market volume observation for participation tracking (#E10).\n\nCalled by orchestrator when market data volume updates are received.\n\nArgs:\n    symbol: Instrument symbol\n    volume: Current market volume (typically cumulative or tick volume)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "volume",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 873
            },
            {
              "name": "_record_our_volume",
              "module": "execution_agent",
              "signature": "def _record_our_volume(self, symbol: str, filled_quantity: int) -> None",
              "docstring": "Record our filled volume for participation tracking (#E10).\n\nCalled when orders are filled to track our market participation.\n\nArgs:\n    symbol: Instrument symbol\n    filled_quantity: Quantity we filled",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "filled_quantity",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 897
            },
            {
              "name": "_get_current_participation_rate",
              "module": "execution_agent",
              "signature": "def _get_current_participation_rate(self, symbol: str)",
              "docstring": "Calculate current participation rate (#E10).\n\nReturns:\n    Current participation rate (our volume / market volume), or None if insufficient data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 921
            },
            {
              "name": "_get_adjusted_participation_rate",
              "module": "execution_agent",
              "signature": "def _get_adjusted_participation_rate(self, symbol: str) -> float",
              "docstring": "Get dynamically adjusted participation rate (#E10).\n\nAdjusts participation based on:\n- Current market volume vs expected\n- Our recent participation rate vs target\n- Market conditions (volatility, spread)\n\nReturns:\n    Adjusted participation rate (bounded by min/max)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 954
            },
            {
              "name": "_calculate_vwap_slice_size",
              "module": "execution_agent",
              "signature": "def _calculate_vwap_slice_size(self, symbol: str, total_remaining: int, expected_market_volume: float) -> int",
              "docstring": "Calculate dynamic VWAP slice size based on current participation (#E10).\n\nArgs:\n    symbol: Instrument symbol\n    total_remaining: Remaining quantity to fill\n    expected_market_volume: Expected market volume for this period\n\nReturns:\n    Slice size adjusted for participation rate",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "total_remaining",
                  "type": "int"
                },
                {
                  "name": "expected_market_volume",
                  "type": "float"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 995
            },
            {
              "name": "get_participation_stats",
              "module": "execution_agent",
              "signature": "def get_participation_stats(self, symbol: str) -> dict[str, Any]",
              "docstring": "Get participation rate statistics for monitoring (#E10).\n\nArgs:\n    symbol: Instrument symbol\n\nReturns:\n    Dictionary with participation statistics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1033
            },
            {
              "name": "_get_et_time",
              "module": "execution_agent",
              "signature": "def _get_et_time(self) -> tuple[float, float, float]",
              "docstring": "Get current time in Eastern Time for VWAP calculations.\n\nReturns:\n    Tuple of (current_hour_decimal, hours_into_session, hours_remaining)",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[float, float, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1058
            },
            {
              "name": "_execute_vwap",
              "module": "execution_agent",
              "signature": "async def _execute_vwap(self, pending: PendingOrder) -> None",
              "docstring": "Execute order using Volume-Weighted Average Price algorithm.\n\nVWAP execution distributes order slices proportionally to expected\nintraday volume. This helps minimize market impact by trading\nheavier during high-volume periods.\n\nUses historical volume profile to determine slice sizes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pending",
                  "type": "PendingOrder"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1090
            },
            {
              "name": "_get_volume_profile",
              "module": "execution_agent",
              "signature": "def _get_volume_profile(self, symbol: str) -> list[float]",
              "docstring": "Get historical volume profile for a symbol.\n\nReturns list of 7 values representing normalized hourly volume\nfrom 9:30 AM to 4:00 PM (0.5 hour buckets would be more precise).\n\nIn production, this would fetch from historical data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "list[float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1206
            },
            {
              "name": "set_volume_profile",
              "module": "execution_agent",
              "signature": "def set_volume_profile(self, symbol: str, profile: list[float]) -> None",
              "docstring": "Set historical volume profile for a symbol.\n\nArgs:\n    symbol: The symbol\n    profile: List of relative volume weights for each time bucket",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "profile",
                  "type": "list[float]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1233
            },
            {
              "name": "_handle_fill",
              "module": "execution_agent",
              "signature": "def _handle_fill(self, fill: FillEvent) -> None",
              "docstring": "Handle fill notification from broker.\n\nCalled by broker when an order is filled.\nHandles both direct orders (MARKET) and TWAP/VWAP slice orders.\n\nThread-safe: uses lock to prevent race conditions when\nmultiple fills arrive simultaneously.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fill",
                  "type": "FillEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1248
            },
            {
              "name": "_process_fill_internal",
              "module": "execution_agent",
              "signature": "def _process_fill_internal(self, fill: FillEvent) -> None",
              "docstring": "Internal fill processing (called within lock).\n\nSeparated for testability and clarity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fill",
                  "type": "FillEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1261
            },
            {
              "name": "cancel_order",
              "module": "execution_agent",
              "signature": "async def cancel_order(self, order_id: str) -> bool",
              "docstring": "Cancel a pending order.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1360
            },
            {
              "name": "get_pending_orders",
              "module": "execution_agent",
              "signature": "def get_pending_orders(self) -> list[dict]",
              "docstring": "Get all pending orders for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1375
            },
            {
              "name": "set_best_execution_analyzer",
              "module": "execution_agent",
              "signature": "def set_best_execution_analyzer(self, analyzer) -> None",
              "docstring": "Set the best execution analyzer for RTS 27/28 compliance tracking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "analyzer"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1391
            },
            {
              "name": "_pre_trade_checks",
              "module": "execution_agent",
              "signature": "async def _pre_trade_checks(self, decision: DecisionEvent, quantity: int) -> dict[str, Any]",
              "docstring": "P1-11: Pre-trade checks to prevent excessive slippage and execution issues.\n\nChecks:\n1. Market data freshness - data must be recent\n2. Spread sanity - spread should not be excessive\n3. Price sanity - price should be reasonable vs recent history\n4. Liquidity check - order size vs available volume\n\nReturns:\n    dict with 'passed' bool and 'reason' if failed, plus 'warnings' list",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                },
                {
                  "name": "quantity",
                  "type": "int"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1395
            },
            {
              "name": "_get_current_bid_ask",
              "module": "execution_agent",
              "signature": "async def _get_current_bid_ask(self, symbol: str) -> tuple[, ]",
              "docstring": "Get current bid/ask from broker or cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "tuple[, ]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1471
            },
            {
              "name": "_check_rate_limits",
              "module": "execution_agent",
              "signature": "def _check_rate_limits(self) -> bool",
              "docstring": "Check rate limits before placing order (anti-HFT per CLAUDE.md).\n\nReturns True if order can proceed, False if rate limited.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1482
            },
            {
              "name": "_record_order_timestamp",
              "module": "execution_agent",
              "signature": "def _record_order_timestamp(self) -> None",
              "docstring": "Record timestamp after successful order placement.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1513
            },
            {
              "name": "start_stop_order_monitor",
              "module": "execution_agent",
              "signature": "async def start_stop_order_monitor(self) -> None",
              "docstring": "Start the background task that monitors and triggers stop orders.\n\nThis should be called when the execution agent starts.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1523
            },
            {
              "name": "stop_stop_order_monitor",
              "module": "execution_agent",
              "signature": "async def stop_stop_order_monitor(self) -> None",
              "docstring": "Stop the stop order monitor task.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1538
            },
            {
              "name": "_stop_order_monitor_loop",
              "module": "execution_agent",
              "signature": "async def _stop_order_monitor_loop(self) -> None",
              "docstring": "Background loop that checks if any stop orders should be triggered.\n\nRuns continuously with configurable interval (default 100ms).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1549
            },
            {
              "name": "_check_and_trigger_stop_orders",
              "module": "execution_agent",
              "signature": "async def _check_and_trigger_stop_orders(self) -> None",
              "docstring": "Check all pending stop orders and trigger those that meet conditions.\n\nStop order trigger logic:\n- BUY STOP: triggers when last_price >= stop_price\n- SELL STOP: triggers when last_price <= stop_price",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1566
            },
            {
              "name": "_trigger_stop_order",
              "module": "execution_agent",
              "signature": "async def _trigger_stop_order(self, pending: PendingOrder, trigger_price: float) -> None",
              "docstring": "Trigger a stop order by converting it to a market or limit order.\n\nArgs:\n    pending: The stop order to trigger\n    trigger_price: The price that triggered the stop",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pending",
                  "type": "PendingOrder"
                },
                {
                  "name": "trigger_price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1611
            },
            {
              "name": "start_order_timeout_monitor",
              "module": "execution_agent",
              "signature": "def start_order_timeout_monitor(self) -> None",
              "docstring": "Start background task to monitor order timeouts (#E24).\n\nCancels orders that exceed configured timeout thresholds.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1660
            },
            {
              "name": "stop_order_timeout_monitor",
              "module": "execution_agent",
              "signature": "async def stop_order_timeout_monitor(self) -> None",
              "docstring": "Stop the order timeout monitor task.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1678
            },
            {
              "name": "_order_timeout_monitor_loop",
              "module": "execution_agent",
              "signature": "async def _order_timeout_monitor_loop(self) -> None",
              "docstring": "Background loop that checks for timed-out orders (#E24).\n\nOrders are cancelled if they exceed their timeout threshold:\n- Simple orders (MARKET/LIMIT): order_timeout_seconds (default 5 min)\n- Algorithmic orders (TWAP/VWAP): algo_timeout_seconds (default 1 hour)",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1689
            },
            {
              "name": "_check_and_cancel_timed_out_orders",
              "module": "execution_agent",
              "signature": "async def _check_and_cancel_timed_out_orders(self) -> None",
              "docstring": "Check all pending orders for timeout and cancel expired ones (#E24).\n\nTimeout thresholds:\n- MARKET/LIMIT: _order_timeout_seconds\n- TWAP/VWAP: _algo_timeout_seconds",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1708
            },
            {
              "name": "_cancel_timed_out_order",
              "module": "execution_agent",
              "signature": "async def _cancel_timed_out_order(self, order_id: str, age_seconds: float, timeout_seconds: float) -> None",
              "docstring": "Cancel a single timed-out order (#E24).\n\nArgs:\n    order_id: Order to cancel\n    age_seconds: How old the order is\n    timeout_seconds: The timeout threshold it exceeded",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "age_seconds",
                  "type": "float"
                },
                {
                  "name": "timeout_seconds",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1746
            },
            {
              "name": "get_partial_fill_timeouts",
              "module": "execution_agent",
              "signature": "def get_partial_fill_timeouts(self) -> list[dict]",
              "docstring": "P1-14: Get list of orders that timed out with partial fills.\n\nThese represent execution failures where the full order was not completed\nand remaining quantity was not executed.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1845
            },
            {
              "name": "get_timed_out_orders",
              "module": "execution_agent",
              "signature": "def get_timed_out_orders(self) -> list[str]",
              "docstring": "Get list of order IDs that have been cancelled due to timeout.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1856
            },
            {
              "name": "get_order_age",
              "module": "execution_agent",
              "signature": "def get_order_age(self, order_id: str)",
              "docstring": "Get age of an order in seconds (#E24).\n\nReturns None if order not found.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1860
            },
            {
              "name": "_execute_limit_order",
              "module": "execution_agent",
              "signature": "async def _execute_limit_order(self, pending: PendingOrder) -> None",
              "docstring": "Execute a limit order (used for triggered stop-limit orders).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pending",
                  "type": "PendingOrder"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1873
            },
            {
              "name": "register_stop_order",
              "module": "execution_agent",
              "signature": "def register_stop_order(self, pending: PendingOrder) -> None",
              "docstring": "Register a stop order for monitoring.\n\nCalled when a stop order is created but not yet triggered.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pending",
                  "type": "PendingOrder"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1899
            },
            {
              "name": "update_price",
              "module": "execution_agent",
              "signature": "def update_price(self, symbol: str, price: float) -> None",
              "docstring": "Update the last known price for a symbol.\n\nCalled by market data feed to enable stop order triggering.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1916
            },
            {
              "name": "get_stop_orders",
              "module": "execution_agent",
              "signature": "def get_stop_orders(self) -> list[dict]",
              "docstring": "Get all pending stop orders for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1925
            },
            {
              "name": "_log_fill_quality",
              "module": "execution_agent",
              "signature": "def _log_fill_quality(self, pending: PendingOrder) -> None",
              "docstring": "Log fill quality metrics for TWAP/VWAP orders (#E4, #E5).\n\nCalculates:\n- Overall fill rate\n- Average slippage per slice\n- Fill time distribution\n- Price improvement detection (#E5)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pending",
                  "type": "PendingOrder"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1941
            },
            {
              "name": "get_fill_quality_report",
              "module": "execution_agent",
              "signature": "def get_fill_quality_report(self, order_id: str)",
              "docstring": "Get detailed fill quality report for an order (#E4, #E5).\n\nArgs:\n    order_id: Order ID\n\nReturns:\n    Fill quality metrics dict, or None if order not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2007
            },
            {
              "name": "get_status",
              "module": "execution_agent",
              "signature": "def get_status(self) -> dict",
              "docstring": "Get execution agent status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2063
            },
            {
              "name": "persist_orders_to_file",
              "module": "execution_agent",
              "signature": "def persist_orders_to_file(self, filepath: str) -> int",
              "docstring": "Persist pending orders to file for recovery after restart (#E12).\n\nSaves all non-terminal pending orders to JSON for later recovery.\n\nArgs:\n    filepath: Path to save orders\n\nReturns:\n    Number of orders persisted",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filepath",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2085
            },
            {
              "name": "recover_orders_from_file",
              "module": "execution_agent",
              "signature": "async def recover_orders_from_file(self, filepath: str) -> int",
              "docstring": "Recover pending orders from file after restart (#E12).\n\nLoads persisted orders and attempts to reconcile with broker state.\n\nArgs:\n    filepath: Path to load orders from\n\nReturns:\n    Number of orders recovered",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filepath",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 2164
            },
            {
              "name": "get_aggregate_fill_metrics",
              "module": "execution_agent",
              "signature": "def get_aggregate_fill_metrics(self) -> dict",
              "docstring": "Get aggregate fill quality metrics across all orders (#E13).\n\nReturns summary statistics for execution quality monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2276
            },
            {
              "name": "calculate_implementation_shortfall",
              "module": "execution_agent",
              "signature": "def calculate_implementation_shortfall(self, order_id: str)",
              "docstring": "Calculate implementation shortfall for an order (#E14).\n\nImplementation shortfall = (Actual Execution Cost) - (Paper Portfolio Cost)\nComponents:\n1. Delay cost: Price movement from decision to execution start\n2. Trading impact: Price movement during execution\n3. Opportunity cost: Unfilled portion\n\nArgs:\n    order_id: Order ID to analyze\n\nReturns:\n    Implementation shortfall breakdown, or None if order not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2330
            },
            {
              "name": "get_implementation_shortfall_summary",
              "module": "execution_agent",
              "signature": "def get_implementation_shortfall_summary(self) -> dict",
              "docstring": "Get aggregate implementation shortfall metrics (#E14).\n\nReturns summary across all completed orders.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2433
            },
            {
              "name": "update_order_book",
              "module": "execution_agent",
              "signature": "def update_order_book(self, symbol: str, bids: list[tuple[float, int, int]], asks: list[tuple[float, int, int]]) -> None",
              "docstring": "Update order book snapshot for a symbol (#E15).\n\nCalled by market data handler when order book updates received.\n\nArgs:\n    symbol: Instrument symbol\n    bids: List of (price, size, num_orders) tuples, best first\n    asks: List of (price, size, num_orders) tuples, best first",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "bids",
                  "type": "list[tuple[float, int, int]]"
                },
                {
                  "name": "asks",
                  "type": "list[tuple[float, int, int]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2476
            },
            {
              "name": "analyze_order_book",
              "module": "execution_agent",
              "signature": "def analyze_order_book(self, symbol: str)",
              "docstring": "Analyze current order book depth (#E15).\n\nReturns metrics useful for execution decisions.\n\nArgs:\n    symbol: Instrument symbol\n\nReturns:\n    Order book analysis or None if no data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2502
            },
            {
              "name": "estimate_execution_cost",
              "module": "execution_agent",
              "signature": "def estimate_execution_cost(self, symbol: str, side: str, quantity: int)",
              "docstring": "Estimate execution cost using order book (#E15).\n\nCalculates expected VWAP and slippage for given order size.\n\nArgs:\n    symbol: Instrument symbol\n    side: 'buy' or 'sell'\n    quantity: Order quantity\n\nReturns:\n    Execution cost estimate or None if no book data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2541
            },
            {
              "name": "categorize_fill",
              "module": "execution_agent",
              "signature": "def categorize_fill(self, order_id: str, fill_price: float, fill_quantity: int, fill_side: str) -> FillCategory",
              "docstring": "Categorize a fill as passive or aggressive (#E20).\n\nAggressive: Takes liquidity (crosses spread)\nPassive: Provides liquidity (rests in book)\nMidpoint: Filled at or near mid price\n\nArgs:\n    order_id: Order identifier\n    fill_price: Price at which filled\n    fill_quantity: Quantity filled\n    fill_side: 'buy' or 'sell'\n\nReturns:\n    FillCategory with classification",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "fill_price",
                  "type": "float"
                },
                {
                  "name": "fill_quantity",
                  "type": "int"
                },
                {
                  "name": "fill_side",
                  "type": "str"
                }
              ],
              "return_type": "FillCategory",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2596
            },
            {
              "name": "get_fill_categorization_summary",
              "module": "execution_agent",
              "signature": "def get_fill_categorization_summary(self) -> dict",
              "docstring": "Get summary of fill categorizations (#E20).\n\nReturns breakdown of aggressive vs passive fills.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2691
            },
            {
              "name": "estimate_market_impact",
              "module": "execution_agent",
              "signature": "def estimate_market_impact(self, symbol: str, side: str, quantity: int, price: , adv: , volatility: ) -> MarketImpactEstimate",
              "docstring": "Estimate market impact for an order (#E21).\n\nUses a square-root market impact model (Almgren-Chriss simplified):\n\nImpact = \u03b7 * \u03c3 * \u221a(Q/V)\n\nWhere:\n- \u03b7 = market impact coefficient\n- \u03c3 = volatility\n- Q = order quantity\n- V = average daily volume\n\nArgs:\n    symbol: Instrument symbol\n    side: 'buy' or 'sell'\n    quantity: Order quantity\n    price: Current price (uses last price if None)\n    adv: Average daily volume (uses default if None)\n    volatility: Daily volatility (uses default if None)\n\nReturns:\n    MarketImpactEstimate with impact breakdown",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": ""
                },
                {
                  "name": "adv",
                  "type": ""
                },
                {
                  "name": "volatility",
                  "type": ""
                }
              ],
              "return_type": "MarketImpactEstimate",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2741
            },
            {
              "name": "configure_market_impact_model",
              "module": "execution_agent",
              "signature": "def configure_market_impact_model(self, eta: , gamma: , alpha: ) -> None",
              "docstring": "Configure market impact model parameters (#E21).\n\nArgs:\n    eta: Temporary impact coefficient (default 0.1)\n    gamma: Permanent impact coefficient (default 0.1)\n    alpha: Square-root power (default 0.5)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "eta",
                  "type": ""
                },
                {
                  "name": "gamma",
                  "type": ""
                },
                {
                  "name": "alpha",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2819
            },
            {
              "name": "should_cross_spread",
              "module": "execution_agent",
              "signature": "def should_cross_spread(self, symbol: str, side: str, urgency: float, opportunity_cost_bps: ) -> dict",
              "docstring": "Determine whether to cross the spread for immediate execution (#E16).\n\nCompares the cost of crossing (paying the spread) against:\n- Opportunity cost of waiting (missed alpha)\n- Queue position probability\n- Market conditions\n\nArgs:\n    symbol: Instrument symbol\n    side: 'buy' or 'sell'\n    urgency: Urgency factor 0-1 (1 = max urgency)\n    opportunity_cost_bps: Estimated alpha decay per unit time (bps/min)\n\nReturns:\n    Decision dict with recommendation and breakdown",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "urgency",
                  "type": "float"
                },
                {
                  "name": "opportunity_cost_bps",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2849
            },
            {
              "name": "execute_with_spread_awareness",
              "module": "execution_agent",
              "signature": "def execute_with_spread_awareness(self, order: OrderEvent, urgency: float) -> dict",
              "docstring": "Execute order with spread-aware logic (#E16).\n\nAutomatically chooses between aggressive (crossing) and passive\n(limit at bid/ask) execution based on market conditions.\n\nArgs:\n    order: Order to execute\n    urgency: Urgency factor 0-1\n\nReturns:\n    Execution decision details",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order",
                  "type": "OrderEvent"
                },
                {
                  "name": "urgency",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2930
            },
            {
              "name": "_estimate_queue_time",
              "module": "execution_agent",
              "signature": "def _estimate_queue_time(self, symbol: str, side: str, size: int) -> float",
              "docstring": "Estimate time to get filled when posting at NBBO (#E17).\n\nUses simplified queue model based on:\n- Current queue depth at NBBO\n- Historical fill rate\n- Order size relative to queue\n\nArgs:\n    symbol: Instrument symbol\n    side: 'buy' (posting at bid) or 'sell' (posting at ask)\n    size: Order size\n\nReturns:\n    Estimated minutes to fill",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "size",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2979
            },
            {
              "name": "_estimate_fill_rate",
              "module": "execution_agent",
              "signature": "def _estimate_fill_rate(self, symbol: str, side: str) -> float",
              "docstring": "Estimate passive fill rate in shares/minute (#E17).\n\nUses historical fill data if available, otherwise market volume.\n\nArgs:\n    symbol: Instrument symbol\n    side: 'buy' or 'sell'\n\nReturns:\n    Estimated fill rate in shares/minute",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3022
            },
            {
              "name": "estimate_queue_position",
              "module": "execution_agent",
              "signature": "def estimate_queue_position(self, symbol: str, side: str, size: int, price: ) -> dict",
              "docstring": "Estimate queue position and expected fill time (#E17).\n\nArgs:\n    symbol: Instrument symbol\n    side: 'buy' or 'sell'\n    size: Order size\n    price: Limit price (uses NBBO if None)\n\nReturns:\n    Queue position analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "size",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3068
            },
            {
              "name": "execute_midpoint_peg",
              "module": "execution_agent",
              "signature": "async def execute_midpoint_peg(self, order: OrderEvent, max_deviation_bps: float, timeout_seconds: float) -> dict",
              "docstring": "Execute order with midpoint pegging (#E18).\n\nPlaces limit order at midpoint and re-pegs on price changes.\nCommon for reducing spread costs in less urgent executions.\n\nArgs:\n    order: Order to execute\n    max_deviation_bps: Max price deviation before re-peg (bps from mid)\n    timeout_seconds: Maximum time to attempt execution\n\nReturns:\n    Execution result",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order",
                  "type": "OrderEvent"
                },
                {
                  "name": "max_deviation_bps",
                  "type": "float"
                },
                {
                  "name": "timeout_seconds",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 3147
            },
            {
              "name": "_cancel_order",
              "module": "execution_agent",
              "signature": "async def _cancel_order(self, broker_order_id: int) -> bool",
              "docstring": "Cancel an order by broker ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "broker_order_id",
                  "type": "int"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 3269
            },
            {
              "name": "execute_iceberg",
              "module": "execution_agent",
              "signature": "async def execute_iceberg(self, order: OrderEvent, display_size: int, variance_pct: float, min_replenish_seconds: float, price_offset_ticks: int) -> dict",
              "docstring": "Execute iceberg order with hidden quantity (#E19).\n\nShows only display_size at a time, replenishing as fills occur.\nUseful for large orders to avoid market impact from signaling.\n\nArgs:\n    order: Full order (total quantity)\n    display_size: Visible quantity per slice\n    variance_pct: Random variance in display size (0-1)\n    min_replenish_seconds: Minimum time between slice submissions\n    price_offset_ticks: Ticks from NBBO (0 = at NBBO)\n\nReturns:\n    Execution result",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order",
                  "type": "OrderEvent"
                },
                {
                  "name": "display_size",
                  "type": "int"
                },
                {
                  "name": "variance_pct",
                  "type": "float"
                },
                {
                  "name": "min_replenish_seconds",
                  "type": "float"
                },
                {
                  "name": "price_offset_ticks",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 3284
            },
            {
              "name": "calculate_post_trade_tca",
              "module": "execution_agent",
              "signature": "def calculate_post_trade_tca(self, order_id: str, benchmark: str)",
              "docstring": "Calculate comprehensive post-trade Transaction Cost Analysis (#E22).\n\nAnalyzes execution quality against multiple benchmarks.\n\nArgs:\n    order_id: Order ID to analyze\n    benchmark: Primary benchmark ('arrival', 'vwap', 'twap', 'close')\n\nReturns:\n    TCA report or None if order not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "benchmark",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3434
            },
            {
              "name": "_calculate_interval_vwap",
              "module": "execution_agent",
              "signature": "def _calculate_interval_vwap(self, symbol: str, start_time: datetime)",
              "docstring": "Calculate VWAP from start_time to now.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "start_time",
                  "type": "datetime"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3553
            },
            {
              "name": "_get_adv",
              "module": "execution_agent",
              "signature": "def _get_adv(self, symbol: str) -> float",
              "docstring": "Get average daily volume for symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3564
            },
            {
              "name": "generate_tca_report",
              "module": "execution_agent",
              "signature": "def generate_tca_report(self, start_date: , end_date: ) -> dict",
              "docstring": "Generate aggregate TCA report for a period (#E22).\n\nArgs:\n    start_date: Report start (default: all data)\n    end_date: Report end (default: now)\n\nReturns:\n    Aggregate TCA statistics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3569
            },
            {
              "name": "__init_venue_latency",
              "module": "execution_agent",
              "signature": "def __init_venue_latency(self)",
              "docstring": "Initialize venue latency tracking structures.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3646
            },
            {
              "name": "record_venue_latency",
              "module": "execution_agent",
              "signature": "def record_venue_latency(self, venue: str, latency_ms: float, event_type: str) -> None",
              "docstring": "Record latency measurement for a venue (#E23).\n\nArgs:\n    venue: Venue/exchange identifier\n    latency_ms: Round-trip latency in milliseconds\n    event_type: Type of event ('order', 'fill', 'cancel', 'quote')",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue",
                  "type": "str"
                },
                {
                  "name": "latency_ms",
                  "type": "float"
                },
                {
                  "name": "event_type",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3652
            },
            {
              "name": "get_venue_latency_stats",
              "module": "execution_agent",
              "signature": "def get_venue_latency_stats(self, venue: , lookback_minutes: int) -> dict",
              "docstring": "Get venue latency statistics (#E23).\n\nArgs:\n    venue: Specific venue or None for all\n    lookback_minutes: Analysis window\n\nReturns:\n    Latency statistics by venue and event type",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue",
                  "type": ""
                },
                {
                  "name": "lookback_minutes",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3698
            },
            {
              "name": "set_latency_threshold",
              "module": "execution_agent",
              "signature": "def set_latency_threshold(self, threshold_ms: float) -> None",
              "docstring": "Set latency alert threshold in milliseconds (#E23).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "threshold_ms",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3751
            },
            {
              "name": "check_venue_health",
              "module": "execution_agent",
              "signature": "def check_venue_health(self) -> dict",
              "docstring": "Check overall venue connectivity health (#E23).\n\nReturns:\n    Health status for each venue",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 3758
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 341
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "dataclasses",
        "datetime",
        "typing",
        "core.agent_base",
        "core.events",
        "core.contract_specs",
        "core.event_bus",
        "core.logger",
        "core.broker",
        "threading",
        "json",
        "os",
        "json",
        "os",
        "random",
        "zoneinfo",
        "core.events"
      ],
      "dependencies": [
        "__future__",
        "core.agent_base",
        "core.events",
        "core.contract_specs",
        "core.event_bus",
        "core.logger",
        "core.broker",
        "threading",
        "random",
        "zoneinfo",
        "core.events"
      ]
    },
    "agents.macro_agent": {
      "name": "macro_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\macro_agent.py",
      "docstring": "Macro Strategy Agent\n====================\n\nGenerates signals based on macroeconomic indicators.\nMonitors yield curves, VIX, DXY, and other macro factors.\n\nResponsibility: Macro signal generation ONLY.\nDoes NOT make trading decisions or send orders.",
      "classes": [
        {
          "name": "MacroAgent",
          "module": "macro_agent",
          "docstring": "Macro Strategy Agent.\n\nAnalyzes macroeconomic indicators to generate regime-based signals.\n\nIndicators monitored:\n- Yield curve (2s10s spread)\n- VIX (volatility index)\n- DXY (dollar index)\n- Credit spreads\n\nSignal output:\n- Risk-on / Risk-off regime\n- Sector rotation signals\n- Duration signals",
          "bases": [
            "SignalAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "macro_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 52
            },
            {
              "name": "initialize",
              "module": "macro_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize macro data feeds.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 69
            },
            {
              "name": "process_event",
              "module": "macro_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process market data and generate macro signals.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 77
            },
            {
              "name": "_analyze_macro_conditions",
              "module": "macro_agent",
              "signature": "async def _analyze_macro_conditions(self, market_data: MarketDataEvent)",
              "docstring": "Analyze macroeconomic conditions.\n\nTODO: Implement real macro models:\n1. Yield curve analysis (inversion = risk-off)\n2. VIX regime detection (>20 = elevated, >30 = crisis)\n3. Dollar strength impact on EM/commodities\n4. Credit spread analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "market_data",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 89
            },
            {
              "name": "_process_vix_signal",
              "module": "macro_agent",
              "signature": "async def _process_vix_signal(self, market_data: MarketDataEvent)",
              "docstring": "Process VIX data for regime signal.\n\nTODO: Implement proper VIX regime model:\n- VIX < 15: Low vol, risk-on\n- VIX 15-20: Normal\n- VIX 20-30: Elevated, reduce risk\n- VIX > 30: Crisis, risk-off",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "market_data",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 116
            },
            {
              "name": "_analyze_yield_curve",
              "module": "macro_agent",
              "signature": "async def _analyze_yield_curve(self)",
              "docstring": "Analyze yield curve for recession signals.\n\nTODO: Implement yield curve analysis:\n- 2s10s spread\n- 3m10y spread (Fed preferred)\n- Full curve shape analysis",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 171
            },
            {
              "name": "_analyze_dollar_strength",
              "module": "macro_agent",
              "signature": "async def _analyze_dollar_strength(self)",
              "docstring": "Analyze dollar strength for sector rotation.\n\nTODO: Implement DXY analysis:\n- Strong dollar = headwind for multinationals, EM\n- Weak dollar = tailwind for commodities, EM",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 183
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 34
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger"
      ],
      "dependencies": [
        "__future__",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger"
      ]
    },
    "agents.market_making_agent": {
      "name": "market_making_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\market_making_agent.py",
      "docstring": "Market Making Agent\n===================\n\nGenerates signals for market making strategy (IB-compatible latency).\nProvides liquidity by quoting bid/ask spreads.\n\nNOTE: This is NOT High-Frequency Trading (HFT).\n- Quote refresh rate is IB-compatible (>100ms)\n- No nanosecond-level strategies\n- Focus on spread capture, not speed\n\nResponsibility: Market making signal generation ONLY.\nDoes NOT make trading decisions or send orders.",
      "classes": [
        {
          "name": "MarketMakingState",
          "module": "market_making_agent",
          "docstring": "State for market making per symbol.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "bid_prices",
              "type": "deque"
            },
            {
              "name": "ask_prices",
              "type": "deque"
            },
            {
              "name": "mid_prices",
              "type": "deque"
            },
            {
              "name": "spreads",
              "type": "deque"
            },
            {
              "name": "volumes",
              "type": "deque"
            },
            {
              "name": "inventory",
              "type": "int"
            },
            {
              "name": "last_quote_time",
              "type": ""
            },
            {
              "name": "fair_value",
              "type": "float"
            },
            {
              "name": "volatility",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 45
        },
        {
          "name": "MarketMakingAgent",
          "module": "market_making_agent",
          "docstring": "Market Making Agent.\n\nImplements passive market making strategy:\n1. Calculate fair value from order book\n2. Estimate short-term volatility\n3. Set bid/ask quotes around fair value\n4. Manage inventory risk\n\nNOT HFT - operates at IB-compatible latencies (100ms+).",
          "bases": [
            "SignalAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "market_making_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 72
            },
            {
              "name": "initialize",
              "module": "market_making_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize market making state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 89
            },
            {
              "name": "process_event",
              "module": "market_making_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process market data and generate market making signals.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 101
            },
            {
              "name": "_generate_mm_signal",
              "module": "market_making_agent",
              "signature": "def _generate_mm_signal(self, state: MarketMakingState, market_data: MarketDataEvent)",
              "docstring": "Generate market making signal.\n\nTODO: Implement proper market making model:\n- Order flow imbalance\n- Inventory optimization (Avellaneda-Stoikov)\n- Adverse selection risk\n- Optimal spread calculation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MarketMakingState"
                },
                {
                  "name": "market_data",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 148
            },
            {
              "name": "_calculate_optimal_spread",
              "module": "market_making_agent",
              "signature": "def _calculate_optimal_spread(self, state: MarketMakingState, market_data: MarketDataEvent) -> float",
              "docstring": "Calculate optimal spread in basis points.\n\nTODO: Implement Avellaneda-Stoikov optimal market making:\n- s* = \u03b3\u03c3\u00b2T + (2/\u03b3)ln(1 + \u03b3/k)\n- Where \u03b3 is risk aversion, \u03c3 is volatility, k is order arrival rate",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MarketMakingState"
                },
                {
                  "name": "market_data",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 188
            },
            {
              "name": "_generate_liquidity_signal",
              "module": "market_making_agent",
              "signature": "def _generate_liquidity_signal(self, state: MarketMakingState, market_data: MarketDataEvent, optimal_spread: float) -> SignalEvent",
              "docstring": "Generate signal to provide liquidity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MarketMakingState"
                },
                {
                  "name": "market_data",
                  "type": "MarketDataEvent"
                },
                {
                  "name": "optimal_spread",
                  "type": "float"
                }
              ],
              "return_type": "SignalEvent",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 214
            },
            {
              "name": "_generate_inventory_signal",
              "module": "market_making_agent",
              "signature": "def _generate_inventory_signal(self, state: MarketMakingState, market_data: MarketDataEvent) -> SignalEvent",
              "docstring": "Generate signal to reduce inventory.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MarketMakingState"
                },
                {
                  "name": "market_data",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "SignalEvent",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 251
            },
            {
              "name": "update_inventory",
              "module": "market_making_agent",
              "signature": "def update_inventory(self, symbol: str, quantity_change: int) -> None",
              "docstring": "Update inventory after a fill.\n\nCalled by execution agent to track positions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity_change",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 281
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 59
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "collections",
        "dataclasses",
        "datetime",
        "typing",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger"
      ]
    },
    "agents.momentum_agent": {
      "name": "momentum_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\momentum_agent.py",
      "docstring": "Momentum / Trend Following Agent\n================================\n\nGenerates signals based on price momentum and trend indicators.\nImplements moving average crossovers, RSI, and breakout detection.\n\nResponsibility: Momentum/trend signal generation ONLY.\nDoes NOT make trading decisions or send orders.",
      "classes": [
        {
          "name": "MomentumState",
          "module": "momentum_agent",
          "docstring": "State for tracking momentum indicators per symbol.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "prices",
              "type": "deque"
            },
            {
              "name": "fast_ma",
              "type": "float"
            },
            {
              "name": "slow_ma",
              "type": "float"
            },
            {
              "name": "rsi",
              "type": "float"
            },
            {
              "name": "macd",
              "type": "float"
            },
            {
              "name": "macd_signal",
              "type": "float"
            },
            {
              "name": "last_signal",
              "type": "SignalDirection"
            },
            {
              "name": "gains",
              "type": "deque"
            },
            {
              "name": "losses",
              "type": "deque"
            },
            {
              "name": "fast_ema",
              "type": "float"
            },
            {
              "name": "slow_ema",
              "type": "float"
            },
            {
              "name": "macd_history",
              "type": "deque"
            },
            {
              "name": "signal_ema",
              "type": "float"
            },
            {
              "name": "ema_initialized",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 39
        },
        {
          "name": "MomentumAgent",
          "module": "momentum_agent",
          "docstring": "Momentum / Trend Following Agent.\n\nImplements multiple momentum indicators:\n1. Moving Average Crossover (fast/slow MA)\n2. RSI (Relative Strength Index)\n3. MACD (Moving Average Convergence Divergence)\n\nSignal output:\n- Trend direction (long/short/flat)\n- Signal strength based on indicator confluence",
          "bases": [
            "SignalAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "momentum_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 73
            },
            {
              "name": "initialize",
              "module": "momentum_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize momentum tracking.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 93
            },
            {
              "name": "process_event",
              "module": "momentum_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process market data and generate momentum signals.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 100
            },
            {
              "name": "_generate_momentum_signal",
              "module": "momentum_agent",
              "signature": "def _generate_momentum_signal(self, state: MomentumState)",
              "docstring": "Generate momentum signal based on multiple indicators.\n\nTODO: Implement more sophisticated momentum models:\n- ADX for trend strength\n- Bollinger Bands for volatility-adjusted signals\n- Volume confirmation\n- Multiple timeframe analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MomentumState"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 140
            },
            {
              "name": "_calculate_rsi",
              "module": "momentum_agent",
              "signature": "def _calculate_rsi(self, state: MomentumState) -> float",
              "docstring": "Calculate RSI indicator.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MomentumState"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 186
            },
            {
              "name": "_calculate_macd",
              "module": "momentum_agent",
              "signature": "def _calculate_macd(self, state: MomentumState, price: float) -> tuple[float, float]",
              "docstring": "Calculate MACD and signal line using proper EMA.\n\nMACD = 12-period EMA - 26-period EMA\nSignal = 9-period EMA of MACD\n\nEMA formula: EMA_t = price * k + EMA_{t-1} * (1 - k)\nwhere k = 2 / (period + 1)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MomentumState"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "tuple[float, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 202
            },
            {
              "name": "_evaluate_indicators",
              "module": "momentum_agent",
              "signature": "def _evaluate_indicators(self, state: MomentumState) -> tuple[SignalDirection, float, str]",
              "docstring": "Evaluate indicator confluence for signal generation.\n\nReturns (direction, strength, rationale)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MomentumState"
                }
              ],
              "return_type": "tuple[SignalDirection, float, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 246
            },
            {
              "name": "_calculate_confidence",
              "module": "momentum_agent",
              "signature": "def _calculate_confidence(self, state: MomentumState) -> float",
              "docstring": "Calculate confidence based on indicator agreement.\n\nTODO: Add more factors:\n- Volume confirmation\n- Trend strength (ADX)\n- Historical accuracy",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "MomentumState"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 298
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 59
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "collections",
        "dataclasses",
        "typing",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger"
      ]
    },
    "agents.options_vol_agent": {
      "name": "options_vol_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\options_vol_agent.py",
      "docstring": "Options Volatility Agent\n========================\n\nGenerates signals based on options market analysis.\nMonitors implied volatility, skew, and term structure.\n\nResponsibility: Options/volatility signal generation ONLY.\nDoes NOT make trading decisions or send orders.",
      "classes": [
        {
          "name": "VolatilityState",
          "module": "options_vol_agent",
          "docstring": "State for volatility tracking per underlying.",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "options_vol_agent",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 56
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "underlying_price",
              "type": "float"
            },
            {
              "name": "iv_history",
              "type": "deque"
            },
            {
              "name": "rv_history",
              "type": "deque"
            },
            {
              "name": "return_history",
              "type": "deque"
            },
            {
              "name": "skew_history",
              "type": "deque"
            },
            {
              "name": "term_structure",
              "type": "dict"
            },
            {
              "name": "iv_percentile",
              "type": "float"
            },
            {
              "name": "vol_premium",
              "type": "float"
            },
            {
              "name": "realized_vol",
              "type": "float"
            },
            {
              "name": "iv_is_estimated",
              "type": "bool"
            },
            {
              "name": "last_price",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 41
        },
        {
          "name": "OptionsVolAgent",
          "module": "options_vol_agent",
          "docstring": "Options Volatility Agent.\n\nAnalyzes options markets for volatility-based signals:\n1. IV percentile ranking\n2. Volatility risk premium (IV vs RV)\n3. Skew analysis\n4. Term structure\n\nSignal output:\n- Volatility regime (high/low/normal)\n- Vol selling/buying opportunities\n- Skew trades",
          "bases": [
            "SignalAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "options_vol_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 80
            },
            {
              "name": "initialize",
              "module": "options_vol_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize volatility tracking.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 97
            },
            {
              "name": "process_event",
              "module": "options_vol_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process market data and generate volatility signals.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 105
            },
            {
              "name": "_update_realized_vol",
              "module": "options_vol_agent",
              "signature": "def _update_realized_vol(self, state: VolatilityState, market_data: MarketDataEvent) -> None",
              "docstring": "Update realized volatility estimate using close-to-close method.\n\nImplements standard historical volatility calculation:\nRV = std(log_returns) * sqrt(252)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "VolatilityState"
                },
                {
                  "name": "market_data",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 133
            },
            {
              "name": "_update_implied_vol",
              "module": "options_vol_agent",
              "signature": "async def _update_implied_vol(self, state: VolatilityState, market_data: MarketDataEvent) -> None",
              "docstring": "Update implied volatility from options.\n\nLIMITATION: Actual IV requires options chain data from IB.\nUntil IB options data is integrated, we estimate IV based on:\n1. Realized volatility as baseline\n2. Historical IV premium (typically IV > RV)\n3. VIX correlation if available\n\nIn production, this should:\n1. Query IB for ATM options chain\n2. Calculate IV via Black-Scholes inversion\n3. Build IV surface (strike x expiry)\n4. Calculate skew and term structure",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "VolatilityState"
                },
                {
                  "name": "market_data",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 160
            },
            {
              "name": "_generate_vol_signal",
              "module": "options_vol_agent",
              "signature": "def _generate_vol_signal(self, state: VolatilityState)",
              "docstring": "Generate volatility-based trading signal with option selection criteria.\n\nStrategies based on IV percentile:\n- IV rank > threshold: Sell premium (iron condor, strangle)\n- IV rank < (100 - threshold): Buy premium (straddle, calendar)\n\nOptions filtered by configured delta range and DTE.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "VolatilityState"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 219
            },
            {
              "name": "_calculate_confidence",
              "module": "options_vol_agent",
              "signature": "def _calculate_confidence(self, state: VolatilityState) -> float",
              "docstring": "Calculate signal confidence.\n\nTODO: Factor in:\n- IV percentile extremity\n- Vol premium magnitude\n- Skew normality\n- Term structure shape",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "VolatilityState"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 292
            },
            {
              "name": "calculate_black_scholes_iv",
              "module": "options_vol_agent",
              "signature": "def calculate_black_scholes_iv(self, option_price: float, spot: float, strike: float, tte: float, rate: float, is_call: bool, dividend_yield: float, max_iterations: int, precision: float)",
              "docstring": "Calculate implied volatility via Newton-Raphson method.\n\nUses Black-Scholes-Merton formula with continuous dividend yield\nand iteratively solves for IV.\n\nThe dividend yield adjustment uses the Merton extension:\n- S * exp(-q*T) replaces S in the formula\n- d1 = (ln(S/K) + (r - q + \u03c3\u00b2/2)T) / (\u03c3\u221aT)\n\nArgs:\n    option_price: Market price of the option\n    spot: Current spot price of underlying\n    strike: Strike price\n    tte: Time to expiry in years\n    rate: Risk-free rate (annualized)\n    is_call: True for call, False for put\n    dividend_yield: Continuous dividend yield (annualized)\n    max_iterations: Max Newton-Raphson iterations\n    precision: Convergence threshold\n\nReturns:\n    Implied volatility or None if convergence fails",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "option_price",
                  "type": "float"
                },
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "strike",
                  "type": "float"
                },
                {
                  "name": "tte",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                },
                {
                  "name": "max_iterations",
                  "type": "int"
                },
                {
                  "name": "precision",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 312
            },
            {
              "name": "calculate_delta",
              "module": "options_vol_agent",
              "signature": "def calculate_delta(self, spot: float, strike: float, tte: float, sigma: float, rate: float, is_call: bool, dividend_yield: float) -> float",
              "docstring": "Calculate option delta using Black-Scholes-Merton with dividend yield.\n\nFor dividend-paying stocks:\n- Call delta = exp(-q*T) * N(d1)\n- Put delta = exp(-q*T) * (N(d1) - 1)\n\nArgs:\n    spot: Current spot price\n    strike: Strike price\n    tte: Time to expiry in years\n    sigma: Volatility\n    rate: Risk-free rate\n    is_call: True for call, False for put\n    dividend_yield: Continuous dividend yield (annualized)\n\nReturns:\n    Delta value (-1 to 1)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "strike",
                  "type": "float"
                },
                {
                  "name": "tte",
                  "type": "float"
                },
                {
                  "name": "sigma",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 397
            },
            {
              "name": "filter_options_by_criteria",
              "module": "options_vol_agent",
              "signature": "def filter_options_by_criteria(self, options: list[dict], spot: float, rate: float) -> list[dict]",
              "docstring": "Filter options based on configured delta range and DTE criteria.\n\nArgs:\n    options: List of option dicts with keys: strike, tte, sigma, is_call, price\n    spot: Current spot price\n    rate: Risk-free rate\n\nReturns:\n    Filtered list of options meeting criteria",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[dict]"
                },
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 444
            },
            {
              "name": "get_optimal_option_for_signal",
              "module": "options_vol_agent",
              "signature": "def get_optimal_option_for_signal(self, state: VolatilityState, direction: SignalDirection, rate: float)",
              "docstring": "Find optimal option for given signal direction based on config criteria.\n\nFor vol selling (SHORT signal): Look for high IV options with delta in range\nFor vol buying (LONG signal): Look for low IV options with delta in range\n\nReturns:\n    Dict with recommended option parameters or None",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "VolatilityState"
                },
                {
                  "name": "direction",
                  "type": "SignalDirection"
                },
                {
                  "name": "rate",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 488
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 64
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "collections",
        "dataclasses",
        "datetime",
        "typing",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "scipy.stats",
        "scipy.stats",
        "scipy.stats"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "scipy.stats",
        "scipy.stats",
        "scipy.stats"
      ]
    },
    "agents.risk_agent": {
      "name": "risk_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\risk_agent.py",
      "docstring": "Risk Agent\n==========\n\nValidates all trading decisions against risk limits.\nImplements kill-switch mechanism for emergency halt.\n\nResponsibility: Risk validation ONLY.\nDoes NOT handle regulatory compliance (see ComplianceAgent).",
      "classes": [
        {
          "name": "KillSwitchReason",
          "module": "risk_agent",
          "docstring": "Reasons for activating kill-switch.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 44
        },
        {
          "name": "DrawdownLevel",
          "module": "risk_agent",
          "docstring": "Tiered drawdown response levels.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 57
        },
        {
          "name": "KillSwitchAction",
          "module": "risk_agent",
          "docstring": "Actions available during kill-switch activation.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 65
        },
        {
          "name": "PositionInfo",
          "module": "risk_agent",
          "docstring": "Position information for a single instrument.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "avg_cost",
              "type": "float"
            },
            {
              "name": "market_value",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "weight_pct",
              "type": "float"
            },
            {
              "name": "sector",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 74
        },
        {
          "name": "GreeksState",
          "module": "risk_agent",
          "docstring": "Portfolio Greeks state with staleness tracking.",
          "bases": [],
          "methods": [
            {
              "name": "is_stale",
              "module": "risk_agent",
              "signature": "def is_stale(self, max_age_seconds: float) -> bool",
              "docstring": "Check if Greeks data is stale.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "max_age_seconds",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 95
            },
            {
              "name": "age_seconds",
              "module": "risk_agent",
              "signature": "def age_seconds(self) -> float",
              "docstring": "Get age of Greeks data in seconds.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 100
            }
          ],
          "class_attributes": [
            {
              "name": "delta",
              "type": "float"
            },
            {
              "name": "gamma",
              "type": "float"
            },
            {
              "name": "vega",
              "type": "float"
            },
            {
              "name": "theta",
              "type": "float"
            },
            {
              "name": "rho",
              "type": "float"
            },
            {
              "name": "last_update",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 86
        },
        {
          "name": "PositionGreeks",
          "module": "risk_agent",
          "docstring": "Per-position Greeks for individual position risk limits (#R4).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "risk_agent",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 117
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "delta",
              "type": "float"
            },
            {
              "name": "gamma",
              "type": "float"
            },
            {
              "name": "vega",
              "type": "float"
            },
            {
              "name": "theta",
              "type": "float"
            },
            {
              "name": "rho",
              "type": "float"
            },
            {
              "name": "contracts",
              "type": "int"
            },
            {
              "name": "last_update",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 106
        },
        {
          "name": "LiquidityMetrics",
          "module": "risk_agent",
          "docstring": "Liquidity risk metrics.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "avg_daily_volume",
              "type": "dict[str, int]"
            },
            {
              "name": "position_pct_of_adv",
              "type": "dict[str, float]"
            },
            {
              "name": "estimated_liquidation_days",
              "type": "dict[str, float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 132
        },
        {
          "name": "DrawdownRecoveryState",
          "module": "risk_agent",
          "docstring": "Tracks drawdown recovery metrics (#R11).\n\nMonitors:\n- Current drawdown start time\n- Historical recovery times\n- Recovery velocity",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "drawdown_start_time",
              "type": ""
            },
            {
              "name": "drawdown_start_equity",
              "type": "float"
            },
            {
              "name": "drawdown_trough_equity",
              "type": "float"
            },
            {
              "name": "drawdown_trough_time",
              "type": ""
            },
            {
              "name": "recovery_start_time",
              "type": ""
            },
            {
              "name": "is_recovering",
              "type": "bool"
            },
            {
              "name": "recovery_times_days",
              "type": "list[float]"
            },
            {
              "name": "avg_recovery_time_days",
              "type": "float"
            },
            {
              "name": "max_recovery_time_days",
              "type": "float"
            },
            {
              "name": "recovery_count",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 140
        },
        {
          "name": "MarginState",
          "module": "risk_agent",
          "docstring": "Intraday margin monitoring state (#R10).\n\nTracks margin requirements throughout the trading day,\nnot just at EOD.",
          "bases": [],
          "methods": [
            {
              "name": "is_warning",
              "module": "risk_agent",
              "signature": "def is_warning(self) -> bool",
              "docstring": "Check if margin is at warning level.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 188
            },
            {
              "name": "is_critical",
              "module": "risk_agent",
              "signature": "def is_critical(self) -> bool",
              "docstring": "Check if margin is at critical level.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 192
            },
            {
              "name": "is_margin_call",
              "module": "risk_agent",
              "signature": "def is_margin_call(self) -> bool",
              "docstring": "Check if in margin call territory.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 196
            }
          ],
          "class_attributes": [
            {
              "name": "initial_margin",
              "type": "float"
            },
            {
              "name": "maintenance_margin",
              "type": "float"
            },
            {
              "name": "available_margin",
              "type": "float"
            },
            {
              "name": "margin_utilization_pct",
              "type": "float"
            },
            {
              "name": "margin_excess",
              "type": "float"
            },
            {
              "name": "last_margin_check",
              "type": ""
            },
            {
              "name": "margin_check_count_today",
              "type": "int"
            },
            {
              "name": "intraday_peak_utilization",
              "type": "float"
            },
            {
              "name": "intraday_margin_calls",
              "type": "int"
            },
            {
              "name": "warning_utilization_pct",
              "type": "float"
            },
            {
              "name": "critical_utilization_pct",
              "type": "float"
            },
            {
              "name": "margin_call_pct",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 164
        },
        {
          "name": "RiskState",
          "module": "risk_agent",
          "docstring": "Current risk state of the portfolio.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "net_liquidation",
              "type": "float"
            },
            {
              "name": "total_cash",
              "type": "float"
            },
            {
              "name": "gross_exposure",
              "type": "float"
            },
            {
              "name": "net_exposure",
              "type": "float"
            },
            {
              "name": "daily_pnl",
              "type": "float"
            },
            {
              "name": "daily_pnl_pct",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "realized_pnl_today",
              "type": "float"
            },
            {
              "name": "peak_equity",
              "type": "float"
            },
            {
              "name": "current_drawdown_pct",
              "type": "float"
            },
            {
              "name": "max_drawdown_pct",
              "type": "float"
            },
            {
              "name": "drawdown_recovery",
              "type": "DrawdownRecoveryState"
            },
            {
              "name": "margin",
              "type": "MarginState"
            },
            {
              "name": "var_95",
              "type": "float"
            },
            {
              "name": "var_99",
              "type": "float"
            },
            {
              "name": "expected_shortfall",
              "type": "float"
            },
            {
              "name": "leverage",
              "type": "float"
            },
            {
              "name": "var_parametric",
              "type": "float"
            },
            {
              "name": "var_historical",
              "type": "float"
            },
            {
              "name": "var_monte_carlo",
              "type": "float"
            },
            {
              "name": "positions",
              "type": "dict[str, PositionInfo]"
            },
            {
              "name": "sector_exposure",
              "type": "dict[str, float]"
            },
            {
              "name": "orders_today",
              "type": "int"
            },
            {
              "name": "orders_this_minute",
              "type": "list[datetime]"
            },
            {
              "name": "last_order_time",
              "type": "Optional[datetime]"
            },
            {
              "name": "greeks",
              "type": "GreeksState"
            },
            {
              "name": "position_greeks",
              "type": "dict[str, PositionGreeks]"
            },
            {
              "name": "liquidity",
              "type": "LiquidityMetrics"
            },
            {
              "name": "last_stress_test_pnl",
              "type": "float"
            },
            {
              "name": "worst_stress_scenario",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 202
        },
        {
          "name": "RiskCheckResult",
          "module": "risk_agent",
          "docstring": "Result of a single risk check.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "check_name",
              "type": "str"
            },
            {
              "name": "passed",
              "type": "bool"
            },
            {
              "name": "current_value",
              "type": "float"
            },
            {
              "name": "limit_value",
              "type": "float"
            },
            {
              "name": "message",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 264
        },
        {
          "name": "RiskValidationResult",
          "module": "risk_agent",
          "docstring": "Complete result of risk validation.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "approved",
              "type": "bool"
            },
            {
              "name": "checks",
              "type": "list[RiskCheckResult]"
            },
            {
              "name": "risk_metrics",
              "type": "dict[str, float]"
            },
            {
              "name": "adjusted_quantity",
              "type": "Optional[int]"
            },
            {
              "name": "rejection_reason",
              "type": "Optional[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 274
        },
        {
          "name": "RiskAgent",
          "module": "risk_agent",
          "docstring": "Risk Management Agent.\n\nValidates all trading decisions against:\n1. Position size limits (5% max per position)\n2. Sector concentration limits (20% max per sector)\n3. Portfolio leverage (2x max)\n4. VaR limits (2% at 95% confidence)\n5. Daily loss limit (-3% triggers halt)\n6. Maximum drawdown (-10% triggers halt)\n7. Rate limits (anti-HFT: 10 orders/min, 100ms interval)\n\nImplements KILL-SWITCH for emergency situations.",
          "bases": [
            "ValidationAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger, broker: Optional[IBBroker])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                },
                {
                  "name": "broker",
                  "type": "Optional[IBBroker]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 299
            },
            {
              "name": "initialize",
              "module": "risk_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize risk state from broker.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 428
            },
            {
              "name": "get_subscribed_events",
              "module": "risk_agent",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Risk agent subscribes to decisions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 439
            },
            {
              "name": "process_event",
              "module": "risk_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Validate trading decisions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 443
            },
            {
              "name": "_validate_decision",
              "module": "risk_agent",
              "signature": "async def _validate_decision(self, decision: DecisionEvent) -> RiskValidationResult",
              "docstring": "Run all risk checks on a decision.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "RiskValidationResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 498
            },
            {
              "name": "_check_position_limit",
              "module": "risk_agent",
              "signature": "async def _check_position_limit(self, decision: DecisionEvent) -> tuple[RiskCheckResult, Optional[int]]",
              "docstring": "Check position size limit (5% max per CLAUDE.md).\n\nAlso applies tiered drawdown position size reduction when in REDUCE mode.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "tuple[RiskCheckResult, Optional[int]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 648
            },
            {
              "name": "_check_sector_limit",
              "module": "risk_agent",
              "signature": "async def _check_sector_limit(self, decision: DecisionEvent) -> RiskCheckResult",
              "docstring": "Check sector and asset class concentration limits (#R8).\n\nEnhanced checks:\n1. Sector concentration (20% max)\n2. Asset class concentration\n3. HHI (Herfindahl-Hirschman Index) for portfolio concentration\n4. Early warning when approaching limits",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 726
            },
            {
              "name": "_calculate_portfolio_hhi",
              "module": "risk_agent",
              "signature": "def _calculate_portfolio_hhi(self) -> float",
              "docstring": "Calculate Herfindahl-Hirschman Index for portfolio concentration (#R8).\n\nHHI = sum of squared market share percentages\nRange: 0 (perfectly diversified) to 10,000 (single position)\n\nThresholds (adapted from DOJ/FTC):\n- HHI < 1500: Unconcentrated (well diversified)\n- HHI 1500-2500: Moderately concentrated\n- HHI > 2500: Highly concentrated (concentration risk)",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 796
            },
            {
              "name": "get_concentration_metrics",
              "module": "risk_agent",
              "signature": "def get_concentration_metrics(self) -> dict",
              "docstring": "Get comprehensive portfolio concentration metrics (#R8).\n\nReturns metrics for monitoring:\n- HHI (Herfindahl-Hirschman Index)\n- Top N positions concentration\n- Sector concentration breakdown\n- Effective number of positions",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 820
            },
            {
              "name": "_check_leverage_limit",
              "module": "risk_agent",
              "signature": "async def _check_leverage_limit(self, decision: DecisionEvent) -> RiskCheckResult",
              "docstring": "Check leverage limit (2x max) with position netting consideration (#R3).\n\nUses net exposure when positions offset each other, but also checks\ngross exposure for risk management purposes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 871
            },
            {
              "name": "_check_var_limit",
              "module": "risk_agent",
              "signature": "async def _check_var_limit(self, decision: DecisionEvent) -> RiskCheckResult",
              "docstring": "Check VaR limit (2% at 95% confidence) using VaRCalculator.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 941
            },
            {
              "name": "_check_daily_loss_limit",
              "module": "risk_agent",
              "signature": "async def _check_daily_loss_limit(self) -> RiskCheckResult",
              "docstring": "Check daily loss limit (-3% triggers kill-switch).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 998
            },
            {
              "name": "_check_drawdown_limit",
              "module": "risk_agent",
              "signature": "async def _check_drawdown_limit(self) -> RiskCheckResult",
              "docstring": "Check drawdown with tiered response.\n\nTiers:\n- NORMAL (<5%): Normal trading\n- WARNING (5-7.5%): Log warnings, continue trading\n- REDUCE (7.5-10%): Reduce position sizes by configured factor\n- HALT (>10%): Trigger kill-switch\n\nReturns:\n    RiskCheckResult with appropriate pass/fail based on tier",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1012
            },
            {
              "name": "_handle_drawdown_level_change",
              "module": "risk_agent",
              "signature": "async def _handle_drawdown_level_change(self, previous: DrawdownLevel, current: DrawdownLevel, drawdown_pct: float) -> None",
              "docstring": "Handle transitions between drawdown levels.\n\nPublishes appropriate alerts and logs for audit trail.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "previous",
                  "type": "DrawdownLevel"
                },
                {
                  "name": "current",
                  "type": "DrawdownLevel"
                },
                {
                  "name": "drawdown_pct",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1082
            },
            {
              "name": "get_drawdown_level",
              "module": "risk_agent",
              "signature": "def get_drawdown_level(self) -> DrawdownLevel",
              "docstring": "Get current drawdown level for external queries.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "DrawdownLevel",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1139
            },
            {
              "name": "get_position_size_multiplier",
              "module": "risk_agent",
              "signature": "def get_position_size_multiplier(self) -> float",
              "docstring": "Get position size multiplier based on drawdown level.\n\nReturns:\n    1.0 for NORMAL/WARNING, configured reduction for REDUCE, 0.0 for HALT",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1143
            },
            {
              "name": "_check_rate_limit",
              "module": "risk_agent",
              "signature": "def _check_rate_limit(self) -> RiskCheckResult",
              "docstring": "Check order rate limit (anti-HFT: 10 orders/min).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1156
            },
            {
              "name": "_check_order_interval",
              "module": "risk_agent",
              "signature": "def _check_order_interval(self) -> RiskCheckResult",
              "docstring": "Check minimum order interval (anti-HFT: 100ms).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1177
            },
            {
              "name": "_get_risk_metrics",
              "module": "risk_agent",
              "signature": "def _get_risk_metrics(self) -> dict[str, float]",
              "docstring": "Get current risk metrics dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1198
            },
            {
              "name": "_refresh_portfolio_state",
              "module": "risk_agent",
              "signature": "async def _refresh_portfolio_state(self) -> None",
              "docstring": "Refresh portfolio state from broker.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1211
            },
            {
              "name": "_calculate_var",
              "module": "risk_agent",
              "signature": "def _calculate_var(self) -> None",
              "docstring": "Calculate Value at Risk (parametric method).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1283
            },
            {
              "name": "_check_cvar_alerts",
              "module": "risk_agent",
              "signature": "async def _check_cvar_alerts(self) -> None",
              "docstring": "Check CVaR (Expected Shortfall) against thresholds and issue alerts (#R13).\n\nThree alert levels:\n- WARNING: CVaR exceeds warning threshold (default 2.5%)\n- CRITICAL: CVaR exceeds critical threshold (default 4%)\n- HALT: CVaR exceeds halt threshold (default 5%), triggers trading halt",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1310
            },
            {
              "name": "_trigger_cvar_halt",
              "module": "risk_agent",
              "signature": "async def _trigger_cvar_halt(self, cvar: float) -> None",
              "docstring": "Trigger trading halt due to excessive CVaR (#R13).\n\nThis is a severe risk event requiring manual intervention.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "cvar",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1397
            },
            {
              "name": "get_cvar_alert_status",
              "module": "risk_agent",
              "signature": "def get_cvar_alert_status(self) -> dict",
              "docstring": "Get current CVaR alert status (#R13).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1419
            },
            {
              "name": "_should_recalculate_var",
              "module": "risk_agent",
              "signature": "def _should_recalculate_var(self) -> tuple[bool, str]",
              "docstring": "Determine if VaR should be recalculated based on position/exposure changes.\n\nTriggers recalculation when:\n1. Any single position changes by more than position_change_pct (default 5%)\n2. Total gross exposure changes by more than exposure_change_pct (default 10%)\n3. Maximum interval exceeded (default 1 hour)\n\nReturns:\n    Tuple of (should_recalc, reason)",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1436
            },
            {
              "name": "_maybe_recalculate_var",
              "module": "risk_agent",
              "signature": "async def _maybe_recalculate_var(self) -> None",
              "docstring": "Check if VaR recalculation is needed and perform it.\n\nThis is called after portfolio state refresh to ensure timely risk updates.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1505
            },
            {
              "name": "_perform_var_recalculation",
              "module": "risk_agent",
              "signature": "async def _perform_var_recalculation(self) -> None",
              "docstring": "Perform full VaR recalculation using all available methods.\n\nUses enhanced VaRCalculator if available, otherwise falls back to parametric.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1536
            },
            {
              "name": "trigger_var_recalculation",
              "module": "risk_agent",
              "signature": "def trigger_var_recalculation(self, reason: str) -> None",
              "docstring": "Manually trigger VaR recalculation.\n\nUseful for external systems that detect significant market events.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1585
            },
            {
              "name": "_activate_kill_switch",
              "module": "risk_agent",
              "signature": "async def _activate_kill_switch(self, reason: KillSwitchReason, action: KillSwitchAction, triggered_by: str) -> None",
              "docstring": "Activate kill-switch - halt all trading (MiFID II RTS 6 compliant).\n\nPer MiFID II RTS 6 Article 18, algorithmic trading systems must have:\n- Immediate ability to cancel all unexecuted orders\n- Ability to prevent new orders from being sent\n- Clear audit trail of all kill switch activations\n\nArgs:\n    reason: The reason for activation\n    action: The action to take (halt, cancel, close, shutdown)\n    triggered_by: Who/what triggered the kill switch",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "reason",
                  "type": "KillSwitchReason"
                },
                {
                  "name": "action",
                  "type": "KillSwitchAction"
                },
                {
                  "name": "triggered_by",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1602
            },
            {
              "name": "_cancel_all_pending_orders",
              "module": "risk_agent",
              "signature": "async def _cancel_all_pending_orders(self) -> None",
              "docstring": "Cancel all pending orders (MiFID II RTS 6 requirement).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1696
            },
            {
              "name": "_initiate_position_closure",
              "module": "risk_agent",
              "signature": "async def _initiate_position_closure(self) -> None",
              "docstring": "Initiate orderly closure of all positions.\n\nNote: This is a safety feature - actual closure requires\nproper execution through the execution agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1721
            },
            {
              "name": "check_latency_breach",
              "module": "risk_agent",
              "signature": "def check_latency_breach(self, latency_ms: float) -> bool",
              "docstring": "Check if latency exceeds threshold (MiFID II RTS 6).\n\nReturns True if latency is acceptable, False if breached.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "latency_ms",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1751
            },
            {
              "name": "activate_kill_switch_manual",
              "module": "risk_agent",
              "signature": "async def activate_kill_switch_manual(self, authorized_by: str, reason: str, action: KillSwitchAction) -> bool",
              "docstring": "Manually activate kill switch (requires authorization).\n\nArgs:\n    authorized_by: Username of person activating\n    reason: Reason for manual activation\n    action: Action to take\n\nReturns:\n    True if successfully activated",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "authorized_by",
                  "type": "str"
                },
                {
                  "name": "reason",
                  "type": "str"
                },
                {
                  "name": "action",
                  "type": "KillSwitchAction"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1764
            },
            {
              "name": "_reject_decision",
              "module": "risk_agent",
              "signature": "async def _reject_decision(self, decision: DecisionEvent, reason: str) -> None",
              "docstring": "Reject a decision and publish rejection event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1793
            },
            {
              "name": "deactivate_kill_switch",
              "module": "risk_agent",
              "signature": "def deactivate_kill_switch(self, authorized_by: str, second_authorization: ) -> tuple[bool, str]",
              "docstring": "Deactivate kill-switch (requires authorization, optionally dual).\n\nMiFID II RTS 6 recommends dual authorization for reactivation\nafter emergency halt.\n\nArgs:\n    authorized_by: Primary authorizing user\n    second_authorization: Second authorizing user (if dual auth required)\n\nReturns:\n    Tuple of (success, message)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "authorized_by",
                  "type": "str"
                },
                {
                  "name": "second_authorization",
                  "type": ""
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1806
            },
            {
              "name": "get_kill_switch_history",
              "module": "risk_agent",
              "signature": "def get_kill_switch_history(self) -> list[dict]",
              "docstring": "Get audit trail of all kill switch activations.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1895
            },
            {
              "name": "add_daily_return",
              "module": "risk_agent",
              "signature": "def add_daily_return(self, return_pct: float) -> None",
              "docstring": "Add a daily return to history for VaR calculation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "return_pct",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1899
            },
            {
              "name": "_check_greeks_limits",
              "module": "risk_agent",
              "signature": "async def _check_greeks_limits(self, decision: DecisionEvent) -> RiskCheckResult",
              "docstring": "Check portfolio Greeks limits with staleness validation.\n\nLimits:\n- max_delta: 500\n- max_gamma: 100\n- max_vega: 50000\n- max_theta: -10000\n\nStaleness:\n- Warning if Greeks older than 60 seconds\n- Reject options trades if Greeks older than 5 minutes",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1909
            },
            {
              "name": "_check_position_greeks_limits",
              "module": "risk_agent",
              "signature": "def _check_position_greeks_limits(self, symbol: str) -> RiskCheckResult",
              "docstring": "Check Greeks limits for a specific position (#R4).\n\nEnforces per-position limits:\n- max_position_delta: Maximum delta for single position\n- max_position_gamma: Maximum gamma for single position\n- max_position_vega: Maximum vega for single position\n\nReturns:\n    RiskCheckResult with pass/fail status",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2006
            },
            {
              "name": "_is_options_trade",
              "module": "risk_agent",
              "signature": "def _is_options_trade(self, decision: DecisionEvent) -> bool",
              "docstring": "Check if decision involves options.\n\nDetermines based on symbol pattern or metadata.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2066
            },
            {
              "name": "_check_liquidity",
              "module": "risk_agent",
              "signature": "async def _check_liquidity(self, decision: DecisionEvent) -> RiskCheckResult",
              "docstring": "Check liquidity risk.\n\nEnsures:\n- Position < 10% of ADV\n- Order < 5% of ADV",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 2088
            },
            {
              "name": "_check_stress_test_limits",
              "module": "risk_agent",
              "signature": "async def _check_stress_test_limits(self) -> RiskCheckResult",
              "docstring": "Check that portfolio passes stress test scenarios.\n\nEnsures worst-case scenario loss does not exceed limit.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 2145
            },
            {
              "name": "_check_market_data_staleness",
              "module": "risk_agent",
              "signature": "async def _check_market_data_staleness(self, decision: DecisionEvent) -> RiskCheckResult",
              "docstring": "Check if market data for the symbol is stale.\n\nRejects decisions if market data is critically stale (>30s by default).\nWarns if data is stale (>5s by default).\n\nThis prevents trading on outdated market information which could lead\nto significant slippage or adverse selection.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "RiskCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 2170
            },
            {
              "name": "update_greeks",
              "module": "risk_agent",
              "signature": "def update_greeks(self, delta: float, gamma: float, vega: float, theta: float, rho: float, update_time: ) -> None",
              "docstring": "Update portfolio Greeks with timestamp.\n\nArgs:\n    delta: Portfolio delta\n    gamma: Portfolio gamma\n    vega: Portfolio vega\n    theta: Portfolio theta\n    rho: Portfolio rho (optional)\n    update_time: Time of Greeks calculation (defaults to now)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "delta",
                  "type": "float"
                },
                {
                  "name": "gamma",
                  "type": "float"
                },
                {
                  "name": "vega",
                  "type": "float"
                },
                {
                  "name": "theta",
                  "type": "float"
                },
                {
                  "name": "rho",
                  "type": "float"
                },
                {
                  "name": "update_time",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2241
            },
            {
              "name": "update_position_greeks",
              "module": "risk_agent",
              "signature": "def update_position_greeks(self, symbol: str, delta: float, gamma: float, vega: float, theta: float, rho: float, contracts: int, update_time: ) -> None",
              "docstring": "Update Greeks for a specific position (#R4).\n\nArgs:\n    symbol: Position symbol\n    delta: Position delta\n    gamma: Position gamma\n    vega: Position vega\n    theta: Position theta\n    rho: Position rho (optional)\n    contracts: Number of contracts\n    update_time: Time of calculation (defaults to now)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "delta",
                  "type": "float"
                },
                {
                  "name": "gamma",
                  "type": "float"
                },
                {
                  "name": "vega",
                  "type": "float"
                },
                {
                  "name": "theta",
                  "type": "float"
                },
                {
                  "name": "rho",
                  "type": "float"
                },
                {
                  "name": "contracts",
                  "type": "int"
                },
                {
                  "name": "update_time",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2296
            },
            {
              "name": "get_position_greeks",
              "module": "risk_agent",
              "signature": "def get_position_greeks(self, symbol: str)",
              "docstring": "Get Greeks for a specific position (#R4).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2353
            },
            {
              "name": "get_all_position_greeks",
              "module": "risk_agent",
              "signature": "def get_all_position_greeks(self) -> dict[str, PositionGreeks]",
              "docstring": "Get Greeks for all positions (#R4).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, PositionGreeks]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2357
            },
            {
              "name": "clear_position_greeks",
              "module": "risk_agent",
              "signature": "def clear_position_greeks(self, symbol: ) -> None",
              "docstring": "Clear position Greeks data (#R4).\n\nArgs:\n    symbol: Specific symbol to clear, or None to clear all",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2361
            },
            {
              "name": "get_greeks_status",
              "module": "risk_agent",
              "signature": "def get_greeks_status(self) -> dict",
              "docstring": "Get detailed Greeks status including staleness.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2373
            },
            {
              "name": "update_liquidity_data",
              "module": "risk_agent",
              "signature": "def update_liquidity_data(self, symbol: str, avg_daily_volume: int) -> None",
              "docstring": "Update ADV data for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "avg_daily_volume",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2403
            },
            {
              "name": "update_stress_test_result",
              "module": "risk_agent",
              "signature": "def update_stress_test_result(self, pnl_impact: float, scenario_name: str) -> None",
              "docstring": "Update worst stress test result.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pnl_impact",
                  "type": "float"
                },
                {
                  "name": "scenario_name",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2414
            },
            {
              "name": "set_var_calculator",
              "module": "risk_agent",
              "signature": "def set_var_calculator(self, var_calculator) -> None",
              "docstring": "Set enhanced VaR calculator.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "var_calculator"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2420
            },
            {
              "name": "set_stress_tester",
              "module": "risk_agent",
              "signature": "def set_stress_tester(self, stress_tester) -> None",
              "docstring": "Set stress tester.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "stress_tester"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2424
            },
            {
              "name": "set_correlation_manager",
              "module": "risk_agent",
              "signature": "def set_correlation_manager(self, correlation_manager) -> None",
              "docstring": "Set correlation manager.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "correlation_manager"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2428
            },
            {
              "name": "set_risk_notifier",
              "module": "risk_agent",
              "signature": "def set_risk_notifier(self, risk_notifier) -> None",
              "docstring": "Set risk limit breach notifier (#R27).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "risk_notifier"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2432
            },
            {
              "name": "update_margin_state",
              "module": "risk_agent",
              "signature": "async def update_margin_state(self, initial_margin: float, maintenance_margin: float, available_margin: ) -> None",
              "docstring": "Update margin state for intraday monitoring (#R10).\n\nShould be called periodically (e.g., every trade or every minute)\nto monitor margin utilization throughout the day.\n\nArgs:\n    initial_margin: Required initial margin\n    maintenance_margin: Required maintenance margin\n    available_margin: Available margin (calculated if not provided)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "initial_margin",
                  "type": "float"
                },
                {
                  "name": "maintenance_margin",
                  "type": "float"
                },
                {
                  "name": "available_margin",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 2441
            },
            {
              "name": "_check_margin_alerts",
              "module": "risk_agent",
              "signature": "async def _check_margin_alerts(self, margin: MarginState) -> None",
              "docstring": "Check margin levels and publish alerts (#R10).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "margin",
                  "type": "MarginState"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 2494
            },
            {
              "name": "refresh_margin_from_broker",
              "module": "risk_agent",
              "signature": "async def refresh_margin_from_broker(self) -> None",
              "docstring": "Refresh margin state from broker (#R10).\n\nShould be called periodically for real-time margin monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 2545
            },
            {
              "name": "get_margin_status",
              "module": "risk_agent",
              "signature": "def get_margin_status(self) -> dict",
              "docstring": "Get current margin monitoring status (#R10).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2576
            },
            {
              "name": "reset_intraday_margin_tracking",
              "module": "risk_agent",
              "signature": "def reset_intraday_margin_tracking(self) -> None",
              "docstring": "Reset intraday margin tracking (call at start of day).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2604
            },
            {
              "name": "_update_drawdown_recovery_state",
              "module": "risk_agent",
              "signature": "def _update_drawdown_recovery_state(self, current_equity: float) -> None",
              "docstring": "Update drawdown recovery tracking state (#R11).\n\nCalled whenever portfolio equity changes to track:\n- When drawdowns begin\n- When troughs are reached\n- Recovery progress\n- Time to recover\n\nArgs:\n    current_equity: Current portfolio equity",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_equity",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2615
            },
            {
              "name": "get_drawdown_recovery_status",
              "module": "risk_agent",
              "signature": "def get_drawdown_recovery_status(self) -> dict",
              "docstring": "Get current drawdown recovery status (#R11).\n\nReturns detailed metrics about current and historical drawdowns.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2694
            },
            {
              "name": "run_stress_tests",
              "module": "risk_agent",
              "signature": "async def run_stress_tests(self) -> None",
              "docstring": "Run all stress tests and update state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 2749
            },
            {
              "name": "get_status",
              "module": "risk_agent",
              "signature": "def get_status(self) -> dict",
              "docstring": "Get current risk agent status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2781
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 283
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "dataclasses",
        "datetime",
        "typing",
        "enum",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "core.broker"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "core.broker"
      ]
    },
    "agents.risk_compliance_agent": {
      "name": "risk_compliance_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\risk_compliance_agent.py",
      "docstring": "Risk & Compliance Agent\n=======================\n\nValidates all trading decisions before execution.\nEnforces risk limits and regulatory compliance (EU/AMF).\n\nResponsibility: Risk validation and compliance checking ONLY.\nDoes NOT make trading decisions or send orders.",
      "classes": [
        {
          "name": "RiskState",
          "module": "risk_compliance_agent",
          "docstring": "Current risk state of the portfolio.",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "risk_compliance_agent",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 54
            }
          ],
          "class_attributes": [
            {
              "name": "net_liquidation",
              "type": "float"
            },
            {
              "name": "total_exposure",
              "type": "float"
            },
            {
              "name": "daily_pnl",
              "type": "float"
            },
            {
              "name": "daily_pnl_pct",
              "type": "float"
            },
            {
              "name": "max_drawdown_pct",
              "type": "float"
            },
            {
              "name": "peak_equity",
              "type": "float"
            },
            {
              "name": "var_95",
              "type": "float"
            },
            {
              "name": "positions",
              "type": "dict[str, int]"
            },
            {
              "name": "sector_exposure",
              "type": "dict[str, float]"
            },
            {
              "name": "orders_today",
              "type": "int"
            },
            {
              "name": "last_order_time",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 40
        },
        {
          "name": "RiskComplianceAgent",
          "module": "risk_compliance_agent",
          "docstring": "Risk & Compliance Agent.\n\nValidates all trading decisions against:\n1. Position limits\n2. Portfolio risk limits (VaR, drawdown)\n3. Rate limits (anti-HFT)\n4. Regulatory compliance (EU/AMF)\n\nEVERY decision must pass through this agent.",
          "bases": [
            "ValidationAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_compliance_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger, broker: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                },
                {
                  "name": "broker",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 72
            },
            {
              "name": "initialize",
              "module": "risk_compliance_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize risk state from broker.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 104
            },
            {
              "name": "get_subscribed_events",
              "module": "risk_compliance_agent",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Risk agent subscribes to decisions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 111
            },
            {
              "name": "process_event",
              "module": "risk_compliance_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Validate trading decisions.\n\nEvery decision must pass ALL checks before execution.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 115
            },
            {
              "name": "_validate_decision",
              "module": "risk_compliance_agent",
              "signature": "async def _validate_decision(self, decision: DecisionEvent) -> ValidatedDecisionEvent",
              "docstring": "Run all validation checks on a decision.\n\nReturns ValidatedDecisionEvent with approval status.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "ValidatedDecisionEvent",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 148
            },
            {
              "name": "_check_position_limit",
              "module": "risk_compliance_agent",
              "signature": "async def _check_position_limit(self, decision: DecisionEvent) -> tuple[bool, int]",
              "docstring": "Check if position size is within limits.\n\nReturns (passed, adjusted_quantity).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "tuple[bool, int]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 241
            },
            {
              "name": "_check_daily_loss_limit",
              "module": "risk_compliance_agent",
              "signature": "async def _check_daily_loss_limit(self) -> bool",
              "docstring": "Check if daily loss limit has been breached.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 277
            },
            {
              "name": "_check_drawdown_limit",
              "module": "risk_compliance_agent",
              "signature": "async def _check_drawdown_limit(self) -> bool",
              "docstring": "Check if max drawdown has been breached.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 288
            },
            {
              "name": "_check_leverage_limit",
              "module": "risk_compliance_agent",
              "signature": "async def _check_leverage_limit(self, decision: DecisionEvent) -> bool",
              "docstring": "Check if leverage limit would be breached.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 297
            },
            {
              "name": "_check_rate_limit",
              "module": "risk_compliance_agent",
              "signature": "def _check_rate_limit(self) -> bool",
              "docstring": "Check order rate limit (anti-HFT).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 304
            },
            {
              "name": "_check_order_interval",
              "module": "risk_compliance_agent",
              "signature": "def _check_order_interval(self) -> bool",
              "docstring": "Check minimum order interval (anti-HFT).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 316
            },
            {
              "name": "_calculate_risk_metrics",
              "module": "risk_compliance_agent",
              "signature": "async def _calculate_risk_metrics(self, decision: DecisionEvent) -> dict[str, float]",
              "docstring": "Calculate risk metrics for the decision.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 327
            },
            {
              "name": "_create_rejection",
              "module": "risk_compliance_agent",
              "signature": "def _create_rejection(self, decision: DecisionEvent, reason: str, checks_passed: list[str]) -> ValidatedDecisionEvent",
              "docstring": "Create a rejection event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                },
                {
                  "name": "reason",
                  "type": "str"
                },
                {
                  "name": "checks_passed",
                  "type": "list[str]"
                }
              ],
              "return_type": "ValidatedDecisionEvent",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 345
            },
            {
              "name": "_reject_decision",
              "module": "risk_compliance_agent",
              "signature": "async def _reject_decision(self, decision: DecisionEvent, reason: str) -> None",
              "docstring": "Reject a decision and publish rejection event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision",
                  "type": "DecisionEvent"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 362
            },
            {
              "name": "_halt_trading",
              "module": "risk_compliance_agent",
              "signature": "async def _halt_trading(self, reason: str) -> None",
              "docstring": "Halt all trading.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 378
            },
            {
              "name": "_update_portfolio_state",
              "module": "risk_compliance_agent",
              "signature": "async def _update_portfolio_state(self) -> None",
              "docstring": "Update risk state from broker.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 405
            },
            {
              "name": "resume_trading",
              "module": "risk_compliance_agent",
              "signature": "def resume_trading(self) -> None",
              "docstring": "Resume trading after halt (requires manual intervention).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 432
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 59
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "typing",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "core.broker"
      ],
      "dependencies": [
        "__future__",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger",
        "core.broker"
      ]
    },
    "agents.stat_arb_agent": {
      "name": "stat_arb_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\stat_arb_agent.py",
      "docstring": "Statistical Arbitrage Agent\n===========================\n\nGenerates signals based on statistical relationships between instruments.\nImplements pairs trading and mean reversion strategies.\n\nResponsibility: Statistical arbitrage signal generation ONLY.\nDoes NOT make trading decisions or send orders.",
      "classes": [
        {
          "name": "PairState",
          "module": "stat_arb_agent",
          "docstring": "State for a trading pair.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol_a",
              "type": "str"
            },
            {
              "name": "symbol_b",
              "type": "str"
            },
            {
              "name": "price_a",
              "type": "deque"
            },
            {
              "name": "price_b",
              "type": "deque"
            },
            {
              "name": "spread_history",
              "type": "deque"
            },
            {
              "name": "zscore",
              "type": "float"
            },
            {
              "name": "hedge_ratio",
              "type": "float"
            },
            {
              "name": "half_life",
              "type": "float"
            },
            {
              "name": "last_signal",
              "type": "SignalDirection"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 39
        },
        {
          "name": "StatArbAgent",
          "module": "stat_arb_agent",
          "docstring": "Statistical Arbitrage Agent.\n\nImplements pairs trading strategy based on cointegration.\n\nMethodology:\n1. Identify cointegrated pairs\n2. Calculate hedge ratio via OLS or Kalman filter\n3. Compute spread z-score\n4. Generate mean reversion signals\n\nSignal output:\n- Long/short pair signals when z-score exceeds threshold\n- Exit signals when z-score reverts",
          "bases": [
            "SignalAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "stat_arb_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 69
            },
            {
              "name": "initialize",
              "module": "stat_arb_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize pairs state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 87
            },
            {
              "name": "process_event",
              "module": "stat_arb_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process market data and generate stat arb signals.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 104
            },
            {
              "name": "_check_pair_signal",
              "module": "stat_arb_agent",
              "signature": "async def _check_pair_signal(self, pair_key: str, pair_state: PairState)",
              "docstring": "Check if pair generates a trading signal.\n\nTODO: Implement proper stat arb model:\n1. Estimate cointegration (Engle-Granger or Johansen)\n2. Calculate hedge ratio (OLS, TLS, or Kalman)\n3. Compute spread and z-score\n4. Check for entry/exit signals",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair_key",
                  "type": "str"
                },
                {
                  "name": "pair_state",
                  "type": "PairState"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 135
            },
            {
              "name": "_estimate_hedge_ratio",
              "module": "stat_arb_agent",
              "signature": "def _estimate_hedge_ratio(self, prices_a: np.ndarray, prices_b: np.ndarray) -> float",
              "docstring": "Estimate hedge ratio for the pair.\n\nTODO: Implement proper estimation:\n- OLS regression\n- Total Least Squares\n- Kalman filter for dynamic hedge ratio",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices_a",
                  "type": "np.ndarray"
                },
                {
                  "name": "prices_b",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 188
            },
            {
              "name": "_generate_zscore_signal",
              "module": "stat_arb_agent",
              "signature": "def _generate_zscore_signal(self, pair_key: str, pair_state: PairState, zscore: float)",
              "docstring": "Generate signal based on z-score.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair_key",
                  "type": "str"
                },
                {
                  "name": "pair_state",
                  "type": "PairState"
                },
                {
                  "name": "zscore",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 209
            },
            {
              "name": "_calculate_confidence",
              "module": "stat_arb_agent",
              "signature": "def _calculate_confidence(self, zscore: float) -> float",
              "docstring": "Calculate signal confidence based on z-score magnitude.\n\nTODO: Incorporate additional factors:\n- Cointegration test p-value\n- Half-life of mean reversion\n- Historical hit rate",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "zscore",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 271
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 52
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "collections",
        "dataclasses",
        "typing",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "core.agent_base",
        "core.events",
        "core.event_bus",
        "core.logger"
      ]
    },
    "agents.surveillance_agent": {
      "name": "surveillance_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\surveillance_agent.py",
      "docstring": "Market Surveillance Agent\n=========================\n\nImplements market abuse surveillance per MAR 2014/596/EU.\nDetects potential manipulation patterns for compliance.\n\nMonitors for:\n- Wash trading\n- Spoofing\n- Quote stuffing\n- Layering",
      "classes": [
        {
          "name": "SurveillanceAlertType",
          "module": "surveillance_agent",
          "docstring": "Types of surveillance alerts.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 32
        },
        {
          "name": "AlertSeverity",
          "module": "surveillance_agent",
          "docstring": "Alert severity levels.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 42
        },
        {
          "name": "STORStatus",
          "module": "surveillance_agent",
          "docstring": "STOR submission status per MAR Article 16.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 51
        },
        {
          "name": "SurveillanceAlert",
          "module": "surveillance_agent",
          "docstring": "Market abuse surveillance alert.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "surveillance_agent",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary for logging.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 75
            }
          ],
          "class_attributes": [
            {
              "name": "alert_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "alert_type",
              "type": "SurveillanceAlertType"
            },
            {
              "name": "severity",
              "type": "AlertSeverity"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "evidence",
              "type": "dict[str, Any]"
            },
            {
              "name": "orders_involved",
              "type": "list[str]"
            },
            {
              "name": "recommended_action",
              "type": "str"
            },
            {
              "name": "requires_review",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 62
        },
        {
          "name": "STORReport",
          "module": "surveillance_agent",
          "docstring": "Suspicious Transaction and Order Report (STOR) per MAR Article 16 (#C2).\n\nRequired fields per ESMA MAR Guidelines (2016/1452):\n- Reporting entity details\n- Suspicious order/transaction details\n- Description of suspicious behavior\n- Supporting documentation",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "surveillance_agent",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary for submission.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 141
            },
            {
              "name": "to_xml",
              "module": "surveillance_agent",
              "signature": "def to_xml(self) -> str",
              "docstring": "Convert to XML format for NCA submission.\n\nFormat follows ESMA MAR STOR reporting schema.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 186
            }
          ],
          "class_attributes": [
            {
              "name": "stor_id",
              "type": "str"
            },
            {
              "name": "created_timestamp",
              "type": "datetime"
            },
            {
              "name": "status",
              "type": "STORStatus"
            },
            {
              "name": "reporting_entity_lei",
              "type": "str"
            },
            {
              "name": "reporting_entity_name",
              "type": "str"
            },
            {
              "name": "reporting_entity_country",
              "type": "str"
            },
            {
              "name": "contact_person_name",
              "type": "str"
            },
            {
              "name": "contact_person_email",
              "type": "str"
            },
            {
              "name": "contact_person_phone",
              "type": "str"
            },
            {
              "name": "instrument_isin",
              "type": "str"
            },
            {
              "name": "instrument_name",
              "type": "str"
            },
            {
              "name": "trading_venue_mic",
              "type": "str"
            },
            {
              "name": "description_of_suspicion",
              "type": "str"
            },
            {
              "name": "type_of_suspicious_activity",
              "type": "str"
            },
            {
              "name": "start_date",
              "type": ""
            },
            {
              "name": "end_date",
              "type": ""
            },
            {
              "name": "orders_involved",
              "type": "list[str]"
            },
            {
              "name": "transactions_involved",
              "type": "list[str]"
            },
            {
              "name": "total_volume_involved",
              "type": "float"
            },
            {
              "name": "total_value_involved",
              "type": "float"
            },
            {
              "name": "evidence_summary",
              "type": "str"
            },
            {
              "name": "analysis_methodology",
              "type": "str"
            },
            {
              "name": "related_alerts",
              "type": "list[str]"
            },
            {
              "name": "submitted_timestamp",
              "type": ""
            },
            {
              "name": "nca_reference",
              "type": "str"
            },
            {
              "name": "nca_acknowledgement_timestamp",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 92
        },
        {
          "name": "OrderRecord",
          "module": "surveillance_agent",
          "docstring": "Record of an order for surveillance analysis.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "order_type",
              "type": "str"
            },
            {
              "name": "price",
              "type": ""
            },
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "fill_price",
              "type": ""
            },
            {
              "name": "fill_quantity",
              "type": "int"
            },
            {
              "name": "cancel_timestamp",
              "type": ""
            },
            {
              "name": "modify_count",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 224
        },
        {
          "name": "SurveillanceAgent",
          "module": "surveillance_agent",
          "docstring": "Market abuse surveillance agent.\n\nMonitors trading activity for potential market manipulation\npatterns as required by MAR 2014/596/EU.",
          "bases": [
            "BaseAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "surveillance_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus, audit_logger, surveillance_config: )",
              "docstring": "Initialize surveillance agent.\n\nArgs:\n    config: Agent configuration\n    event_bus: Event bus for subscriptions\n    audit_logger: Audit logger\n    surveillance_config: Surveillance-specific configuration",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus"
                },
                {
                  "name": "audit_logger"
                },
                {
                  "name": "surveillance_config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 248
            },
            {
              "name": "initialize",
              "module": "surveillance_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize the agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 346
            },
            {
              "name": "set_compliance_notifier",
              "module": "surveillance_agent",
              "signature": "def set_compliance_notifier(self, compliance_notifier) -> None",
              "docstring": "Set compliance officer notifier (#C33).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "compliance_notifier"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 350
            },
            {
              "name": "get_subscribed_events",
              "module": "surveillance_agent",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Subscribe to order and fill events.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 355
            },
            {
              "name": "process_event",
              "module": "surveillance_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process incoming events for surveillance.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 359
            },
            {
              "name": "_process_order",
              "module": "surveillance_agent",
              "signature": "async def _process_order(self, event: OrderEvent) -> None",
              "docstring": "Process an order event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "OrderEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 366
            },
            {
              "name": "_process_fill",
              "module": "surveillance_agent",
              "signature": "async def _process_fill(self, event: FillEvent) -> None",
              "docstring": "Process a fill event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "FillEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 391
            },
            {
              "name": "record_order_cancelled",
              "module": "surveillance_agent",
              "signature": "def record_order_cancelled(self, order_id: str) -> None",
              "docstring": "Record an order cancellation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 409
            },
            {
              "name": "_run_detections",
              "module": "surveillance_agent",
              "signature": "async def _run_detections(self, symbol: str) -> None",
              "docstring": "Run all enabled detection algorithms for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 423
            },
            {
              "name": "_detect_wash_trading",
              "module": "surveillance_agent",
              "signature": "async def _detect_wash_trading(self, symbol: str) -> None",
              "docstring": "Detect potential wash trading.\n\nWash trading: Simultaneous or near-simultaneous buy and sell\norders in the same instrument that result in no change in\nbeneficial ownership.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 437
            },
            {
              "name": "_detect_spoofing",
              "module": "surveillance_agent",
              "signature": "async def _detect_spoofing(self, symbol: str) -> None",
              "docstring": "Detect potential spoofing.\n\nSpoofing: Entering orders with intent to cancel before execution\nto create false impression of demand/supply.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 501
            },
            {
              "name": "_detect_quote_stuffing",
              "module": "surveillance_agent",
              "signature": "async def _detect_quote_stuffing(self, symbol: str) -> None",
              "docstring": "Detect potential quote stuffing.\n\nQuote stuffing: Rapidly entering and canceling orders to\nslow down other traders or create confusion.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 574
            },
            {
              "name": "_detect_layering",
              "module": "surveillance_agent",
              "signature": "async def _detect_layering(self, symbol: str) -> None",
              "docstring": "Detect potential layering.\n\nLayering: Entering multiple orders at different price levels\nto create artificial depth, then cancelling after execution\non the opposite side.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 613
            },
            {
              "name": "_generate_alert",
              "module": "surveillance_agent",
              "signature": "def _generate_alert(self, alert_type: SurveillanceAlertType, severity: AlertSeverity, symbol: str, description: str, evidence: dict[str, Any], orders_involved: , recommended_action: str) -> SurveillanceAlert",
              "docstring": "Generate and store a surveillance alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_type",
                  "type": "SurveillanceAlertType"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "description",
                  "type": "str"
                },
                {
                  "name": "evidence",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "orders_involved",
                  "type": ""
                },
                {
                  "name": "recommended_action",
                  "type": "str"
                }
              ],
              "return_type": "SurveillanceAlert",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 672
            },
            {
              "name": "_should_generate_stor",
              "module": "surveillance_agent",
              "signature": "def _should_generate_stor(self, severity: AlertSeverity) -> bool",
              "docstring": "Check if severity meets threshold for STOR generation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 716
            },
            {
              "name": "_create_stor_from_alert",
              "module": "surveillance_agent",
              "signature": "def _create_stor_from_alert(self, alert: SurveillanceAlert) -> STORReport",
              "docstring": "Create a STOR from a surveillance alert (#C2).\n\nPer MAR Article 16, firms must report suspicious transactions\n\"without delay\" to the competent authority.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "SurveillanceAlert"
                }
              ],
              "return_type": "STORReport",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 722
            },
            {
              "name": "submit_stor",
              "module": "surveillance_agent",
              "signature": "def submit_stor(self, stor_id: str) -> bool",
              "docstring": "Submit a STOR to the National Competent Authority (#C2).\n\nPer MAR Article 16(1), submission must be made \"without delay\"\nto the competent authority of the most relevant market.\n\nIn production, this would submit to:\n- AMF (France): https://stor.amf-france.org/\n- FCA (UK): https://stor.fca.org.uk/\n- BaFin (Germany), etc.\n\nReturns:\n    True if submission successful",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "stor_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 811
            },
            {
              "name": "_validate_stor",
              "module": "surveillance_agent",
              "signature": "def _validate_stor(self, stor: STORReport) -> list[str]",
              "docstring": "Validate STOR before submission per MAR Article 16 requirements.\n\nMAR Article 16 required fields:\n1. Reporting entity identification (LEI, name, country)\n2. Contact person details\n3. Instrument identification (ISIN or name + venue)\n4. Description and type of suspicious activity\n5. Dates of suspicious activity\n6. Evidence and supporting documentation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "stor",
                  "type": "STORReport"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 863
            },
            {
              "name": "get_stor_by_id",
              "module": "surveillance_agent",
              "signature": "def get_stor_by_id(self, stor_id: str)",
              "docstring": "Get a STOR by its ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "stor_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 928
            },
            {
              "name": "get_pending_stors",
              "module": "surveillance_agent",
              "signature": "def get_pending_stors(self) -> list[STORReport]",
              "docstring": "Get STORs that need to be submitted.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[STORReport]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 935
            },
            {
              "name": "get_stor_summary",
              "module": "surveillance_agent",
              "signature": "def get_stor_summary(self) -> dict[str, Any]",
              "docstring": "Get summary of STOR reports (#C2).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 942
            },
            {
              "name": "_trim_history",
              "module": "surveillance_agent",
              "signature": "def _trim_history(self) -> None",
              "docstring": "Trim old order history to prevent memory growth.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 958
            },
            {
              "name": "get_alerts",
              "module": "surveillance_agent",
              "signature": "def get_alerts(self, hours: int, alert_type: , severity: ) -> list[SurveillanceAlert]",
              "docstring": "Get recent surveillance alerts.\n\nArgs:\n    hours: Lookback period\n    alert_type: Filter by alert type\n    severity: Filter by severity\n\nReturns:\n    List of alerts",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hours",
                  "type": "int"
                },
                {
                  "name": "alert_type",
                  "type": ""
                },
                {
                  "name": "severity",
                  "type": ""
                }
              ],
              "return_type": "list[SurveillanceAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 970
            },
            {
              "name": "get_symbol_metrics",
              "module": "surveillance_agent",
              "signature": "def get_symbol_metrics(self, symbol: str) -> dict[str, Any]",
              "docstring": "Get surveillance metrics for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 999
            },
            {
              "name": "get_status",
              "module": "surveillance_agent",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get agent status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1003
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 240
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "collections",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.agent_base",
        "core.events"
      ],
      "dependencies": [
        "__future__",
        "core.agent_base",
        "core.events"
      ]
    },
    "agents.transaction_reporting_agent": {
      "name": "transaction_reporting_agent",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\transaction_reporting_agent.py",
      "docstring": "Transaction Reporting Agent\n===========================\n\nImplements ESMA RTS 22/23 transaction reporting requirements.\nGenerates reports within 15 minutes of execution per MiFID II.\n\nFeatures:\n- LEI validation\n- AMF BDIF format support\n- 65 required field population\n- Report queue management",
      "classes": [
        {
          "name": "ReportStatus",
          "module": "transaction_reporting_agent",
          "docstring": "Status of a transaction report.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 33
        },
        {
          "name": "TransactionType",
          "module": "transaction_reporting_agent",
          "docstring": "Transaction type codes per ESMA RTS.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 42
        },
        {
          "name": "BuySellIndicator",
          "module": "transaction_reporting_agent",
          "docstring": "Buy/Sell indicator.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 49
        },
        {
          "name": "LEIInfo",
          "module": "transaction_reporting_agent",
          "docstring": "Legal Entity Identifier information.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "lei",
              "type": "str"
            },
            {
              "name": "legal_name",
              "type": "str"
            },
            {
              "name": "country",
              "type": "str"
            },
            {
              "name": "is_valid",
              "type": "bool"
            },
            {
              "name": "validation_date",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 56
        },
        {
          "name": "TransactionReport",
          "module": "transaction_reporting_agent",
          "docstring": "Transaction report per ESMA RTS 22/23.\n\nContains the 65 required fields for MiFID II transaction reporting.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "transaction_reporting_agent",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 168
            },
            {
              "name": "to_bdif_format",
              "module": "transaction_reporting_agent",
              "signature": "def to_bdif_format(self) -> dict[str, Any]",
              "docstring": "Convert to AMF BDIF (Banque de France Data Input Format).\n\nReturns structured format for French regulator submission.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 186
            }
          ],
          "class_attributes": [
            {
              "name": "report_id",
              "type": "str"
            },
            {
              "name": "reporting_timestamp",
              "type": "datetime"
            },
            {
              "name": "status",
              "type": "ReportStatus"
            },
            {
              "name": "transaction_reference_number",
              "type": "str"
            },
            {
              "name": "trading_venue_transaction_id",
              "type": "str"
            },
            {
              "name": "executing_entity_id",
              "type": "str"
            },
            {
              "name": "investment_firm_covered",
              "type": "bool"
            },
            {
              "name": "submitting_entity_id",
              "type": "str"
            },
            {
              "name": "buyer_identification_code",
              "type": "str"
            },
            {
              "name": "buyer_country",
              "type": "str"
            },
            {
              "name": "buyer_first_name",
              "type": "str"
            },
            {
              "name": "buyer_surname",
              "type": "str"
            },
            {
              "name": "buyer_date_of_birth",
              "type": "str"
            },
            {
              "name": "buyer_decision_maker_code",
              "type": "str"
            },
            {
              "name": "buyer_decision_maker_country",
              "type": "str"
            },
            {
              "name": "buyer_decision_maker_first_name",
              "type": "str"
            },
            {
              "name": "buyer_decision_maker_surname",
              "type": "str"
            },
            {
              "name": "buyer_decision_maker_dob",
              "type": "str"
            },
            {
              "name": "seller_identification_code",
              "type": "str"
            },
            {
              "name": "seller_country",
              "type": "str"
            },
            {
              "name": "seller_first_name",
              "type": "str"
            },
            {
              "name": "seller_surname",
              "type": "str"
            },
            {
              "name": "seller_date_of_birth",
              "type": "str"
            },
            {
              "name": "seller_decision_maker_code",
              "type": "str"
            },
            {
              "name": "seller_decision_maker_country",
              "type": "str"
            },
            {
              "name": "seller_decision_maker_first_name",
              "type": "str"
            },
            {
              "name": "seller_decision_maker_surname",
              "type": "str"
            },
            {
              "name": "seller_decision_maker_dob",
              "type": "str"
            },
            {
              "name": "transmission_indicator",
              "type": "bool"
            },
            {
              "name": "transmitting_firm_buyer",
              "type": "str"
            },
            {
              "name": "transmitting_firm_seller",
              "type": "str"
            },
            {
              "name": "trading_date_time",
              "type": ""
            },
            {
              "name": "trading_capacity",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "float"
            },
            {
              "name": "quantity_currency",
              "type": "str"
            },
            {
              "name": "derivative_notional_increase",
              "type": "float"
            },
            {
              "name": "derivative_notional_decrease",
              "type": "float"
            },
            {
              "name": "price",
              "type": "float"
            },
            {
              "name": "price_currency",
              "type": "str"
            },
            {
              "name": "net_amount",
              "type": "float"
            },
            {
              "name": "venue",
              "type": "str"
            },
            {
              "name": "country_of_branch",
              "type": "str"
            },
            {
              "name": "upfront_payment",
              "type": "float"
            },
            {
              "name": "upfront_payment_currency",
              "type": "str"
            },
            {
              "name": "instrument_identification_code",
              "type": "str"
            },
            {
              "name": "instrument_full_name",
              "type": "str"
            },
            {
              "name": "instrument_classification",
              "type": "str"
            },
            {
              "name": "notional_currency_1",
              "type": "str"
            },
            {
              "name": "notional_currency_2",
              "type": "str"
            },
            {
              "name": "price_multiplier",
              "type": "float"
            },
            {
              "name": "underlying_instrument_code",
              "type": "str"
            },
            {
              "name": "underlying_index_name",
              "type": "str"
            },
            {
              "name": "underlying_index_term",
              "type": "str"
            },
            {
              "name": "option_type",
              "type": "str"
            },
            {
              "name": "strike_price",
              "type": "float"
            },
            {
              "name": "strike_price_currency",
              "type": "str"
            },
            {
              "name": "option_exercise_style",
              "type": "str"
            },
            {
              "name": "maturity_date",
              "type": "str"
            },
            {
              "name": "expiry_date",
              "type": "str"
            },
            {
              "name": "delivery_type",
              "type": "str"
            },
            {
              "name": "investment_decision_within_firm",
              "type": "str"
            },
            {
              "name": "country_of_investment_decision_branch",
              "type": "str"
            },
            {
              "name": "execution_within_firm",
              "type": "str"
            },
            {
              "name": "country_of_execution_branch",
              "type": "str"
            },
            {
              "name": "waiver_indicator",
              "type": "str"
            },
            {
              "name": "short_selling_indicator",
              "type": "str"
            },
            {
              "name": "otc_post_trade_indicator",
              "type": "str"
            },
            {
              "name": "commodity_derivative_indicator",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 66
        },
        {
          "name": "TransactionReportingAgent",
          "module": "transaction_reporting_agent",
          "docstring": "Transaction reporting agent for MiFID II compliance.\n\nGenerates and submits transaction reports within 15 minutes\nof execution as required by ESMA RTS 22/23.",
          "bases": [
            "BaseAgent"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "transaction_reporting_agent",
              "signature": "def __init__(self, config: AgentConfig, event_bus, audit_logger, reporting_config: )",
              "docstring": "Initialize transaction reporting agent.\n\nArgs:\n    config: Agent configuration\n    event_bus: Event bus\n    audit_logger: Audit logger\n    reporting_config: Reporting-specific configuration",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus"
                },
                {
                  "name": "audit_logger"
                },
                {
                  "name": "reporting_config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 233
            },
            {
              "name": "initialize",
              "module": "transaction_reporting_agent",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize the agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 283
            },
            {
              "name": "stop",
              "module": "transaction_reporting_agent",
              "signature": "async def stop(self) -> None",
              "docstring": "Stop the agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 313
            },
            {
              "name": "get_subscribed_events",
              "module": "transaction_reporting_agent",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Subscribe to fill events.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 323
            },
            {
              "name": "process_event",
              "module": "transaction_reporting_agent",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process incoming events.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 327
            },
            {
              "name": "_process_fill",
              "module": "transaction_reporting_agent",
              "signature": "async def _process_fill(self, event: FillEvent) -> None",
              "docstring": "Process a fill event and generate transaction report.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "FillEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 332
            },
            {
              "name": "_create_report_from_fill",
              "module": "transaction_reporting_agent",
              "signature": "def _create_report_from_fill(self, fill: FillEvent) -> TransactionReport",
              "docstring": "Create a transaction report from a fill event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fill",
                  "type": "FillEvent"
                }
              ],
              "return_type": "TransactionReport",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 348
            },
            {
              "name": "_submission_loop",
              "module": "transaction_reporting_agent",
              "signature": "async def _submission_loop(self) -> None",
              "docstring": "Background loop to submit pending reports.\n\nChecks every 15 seconds (not 60) to ensure timely reporting (#C4).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 405
            },
            {
              "name": "_process_pending_reports",
              "module": "transaction_reporting_agent",
              "signature": "async def _process_pending_reports(self) -> None",
              "docstring": "Process and submit pending reports with deadline enforcement (#C4).\n\nImplements:\n- Warning at 10 minutes (2/3 of deadline)\n- Critical alert at deadline\n- Deadline breach tracking for audit",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 422
            },
            {
              "name": "_submit_report",
              "module": "transaction_reporting_agent",
              "signature": "async def _submit_report(self, report: TransactionReport) -> bool",
              "docstring": "Submit report to regulator.\n\nIn production, this would send to the NCA (National Competent Authority).\nFor now, we simulate and log.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report",
                  "type": "TransactionReport"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 498
            },
            {
              "name": "_validate_report",
              "module": "transaction_reporting_agent",
              "signature": "def _validate_report(self, report: TransactionReport) -> list[str]",
              "docstring": "Validate transaction report.\n\nReturns list of validation errors, empty if valid.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report",
                  "type": "TransactionReport"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 527
            },
            {
              "name": "_validate_lei",
              "module": "transaction_reporting_agent",
              "signature": "def _validate_lei(self, lei: str) -> bool",
              "docstring": "Validate Legal Entity Identifier format.\n\nLEI is 20 alphanumeric characters.\nRejects known placeholder patterns per Issue #I3.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lei",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 575
            },
            {
              "name": "set_firm_lei",
              "module": "transaction_reporting_agent",
              "signature": "def set_firm_lei(self, lei: str) -> bool",
              "docstring": "Set the firm's LEI.\n\nArgs:\n    lei: Legal Entity Identifier\n\nReturns:\n    True if valid and set",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lei",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 605
            },
            {
              "name": "add_isin_mapping",
              "module": "transaction_reporting_agent",
              "signature": "def add_isin_mapping(self, symbol: str, isin: str) -> None",
              "docstring": "Add symbol to ISIN mapping.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "isin",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 620
            },
            {
              "name": "get_pending_count",
              "module": "transaction_reporting_agent",
              "signature": "def get_pending_count(self) -> int",
              "docstring": "Get number of pending reports.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 624
            },
            {
              "name": "get_submitted_reports",
              "module": "transaction_reporting_agent",
              "signature": "def get_submitted_reports(self, hours: int, limit: int) -> list[TransactionReport]",
              "docstring": "Get recently submitted reports.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hours",
                  "type": "int"
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[TransactionReport]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 628
            },
            {
              "name": "get_report_by_id",
              "module": "transaction_reporting_agent",
              "signature": "def get_report_by_id(self, report_id: str)",
              "docstring": "Get a specific report by ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 643
            },
            {
              "name": "generate_daily_summary",
              "module": "transaction_reporting_agent",
              "signature": "def generate_daily_summary(self, report_date: ) -> dict[str, Any]",
              "docstring": "Generate daily reporting summary.\n\nArgs:\n    report_date: Date to summarize (default: today)\n\nReturns:\n    Summary dictionary",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_date",
                  "type": ""
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 653
            },
            {
              "name": "get_status",
              "module": "transaction_reporting_agent",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get agent status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 695
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 225
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "re",
        "collections",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.agent_base",
        "core.events"
      ],
      "dependencies": [
        "__future__",
        "core.agent_base",
        "core.events"
      ]
    },
    "agents.__init__": {
      "name": "__init__",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\agents\\__init__.py",
      "docstring": "AI Trading Firm - Agents Module\n================================\n\nMulti-agent architecture with strict separation of responsibilities.\nPer CLAUDE.md: Each agent has a single, well-defined responsibility.",
      "classes": [],
      "functions": [],
      "constants": [],
      "imports": [
        "agents.macro_agent",
        "agents.stat_arb_agent",
        "agents.momentum_agent",
        "agents.market_making_agent",
        "agents.options_vol_agent",
        "agents.cio_agent",
        "agents.risk_agent",
        "agents.compliance_agent",
        "agents.execution_agent",
        "agents.risk_compliance_agent"
      ],
      "dependencies": [
        "agents.macro_agent",
        "agents.stat_arb_agent",
        "agents.momentum_agent",
        "agents.market_making_agent",
        "agents.options_vol_agent",
        "agents.cio_agent",
        "agents.risk_agent",
        "agents.compliance_agent",
        "agents.execution_agent",
        "agents.risk_compliance_agent"
      ]
    },
    "core.agent_base": {
      "name": "agent_base",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\agent_base.py",
      "docstring": "Base Agent\n==========\n\nAbstract base class for all agents in the trading system.\nEnforces single-responsibility principle and stateless design.",
      "classes": [
        {
          "name": "AgentConfig",
          "module": "agent_base",
          "docstring": "Configuration for an agent.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "enabled",
              "type": "bool"
            },
            {
              "name": "timeout_seconds",
              "type": "float"
            },
            {
              "name": "shutdown_timeout_seconds",
              "type": "float"
            },
            {
              "name": "parameters",
              "type": "dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 29
        },
        {
          "name": "ShutdownState",
          "module": "agent_base",
          "docstring": "Tracks agent shutdown state for graceful termination.",
          "bases": [],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 38
        },
        {
          "name": "BaseAgent",
          "module": "agent_base",
          "docstring": "Abstract base class for all trading system agents.\n\nDesign principles:\n- Single responsibility per agent\n- Stateless where possible (state in events)\n- All actions logged for audit\n- Timeout and fault tolerance built-in",
          "bases": [
            "ABC"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "agent_base",
              "signature": "def __init__(self, config: AgentConfig, event_bus: EventBus, audit_logger: AuditLogger)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "AgentConfig"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 56
            },
            {
              "name": "name",
              "module": "agent_base",
              "signature": "def name(self) -> str",
              "docstring": "Agent name.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 78
            },
            {
              "name": "is_running",
              "module": "agent_base",
              "signature": "def is_running(self) -> bool",
              "docstring": "Check if agent is running.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 83
            },
            {
              "name": "is_enabled",
              "module": "agent_base",
              "signature": "def is_enabled(self) -> bool",
              "docstring": "Check if agent is enabled.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 88
            },
            {
              "name": "initialize",
              "module": "agent_base",
              "signature": "async def initialize(self) -> None",
              "docstring": "Initialize the agent.\n\nCalled once before start. Use for setup that requires async.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [
                "abstractmethod"
              ],
              "is_async": true,
              "line_number": 93
            },
            {
              "name": "process_event",
              "module": "agent_base",
              "signature": "async def process_event(self, event: Event) -> None",
              "docstring": "Process an incoming event.\n\nThis is the main event handler for the agent.\nMust be implemented by all agents.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [
                "abstractmethod"
              ],
              "is_async": true,
              "line_number": 102
            },
            {
              "name": "get_subscribed_events",
              "module": "agent_base",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Return list of event types this agent subscribes to.\n\nUsed by orchestrator to set up event routing.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [
                "abstractmethod"
              ],
              "is_async": false,
              "line_number": 112
            },
            {
              "name": "start",
              "module": "agent_base",
              "signature": "async def start(self) -> None",
              "docstring": "Start the agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 120
            },
            {
              "name": "stop",
              "module": "agent_base",
              "signature": "async def stop(self, timeout: ) -> bool",
              "docstring": "Stop the agent gracefully with timeout (#S3).\n\nGraceful shutdown sequence:\n1. Stop accepting new events\n2. Wait for pending tasks to complete (with timeout)\n3. Run cleanup handlers\n4. Unsubscribe from events\n5. Log shutdown\n\nArgs:\n    timeout: Override shutdown timeout (uses config default if None)\n\nReturns:\n    True if shutdown completed gracefully, False if forced/timed out",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "timeout",
                  "type": ""
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 146
            },
            {
              "name": "_on_shutdown",
              "module": "agent_base",
              "signature": "async def _on_shutdown(self) -> None",
              "docstring": "Subclass hook for custom shutdown logic.\n\nOverride this method to add cleanup specific to the agent type.\nCalled after pending tasks complete but before unsubscribing from events.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 240
            },
            {
              "name": "add_cleanup_handler",
              "module": "agent_base",
              "signature": "def add_cleanup_handler(self, handler: Callable[, Coroutine[Any, Any, None]]) -> None",
              "docstring": "Add a cleanup handler to run during shutdown.\n\nArgs:\n    handler: Async function to call during shutdown",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "handler",
                  "type": "Callable[, Coroutine[Any, Any, None]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 249
            },
            {
              "name": "track_task",
              "module": "agent_base",
              "signature": "def track_task(self, task: asyncio.Task) -> None",
              "docstring": "Track an async task for graceful shutdown.\n\nCall this for any background tasks started by the agent.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "task",
                  "type": "asyncio.Task"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 258
            },
            {
              "name": "is_shutting_down",
              "module": "agent_base",
              "signature": "def is_shutting_down(self) -> bool",
              "docstring": "Check if agent is in shutdown state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 268
            },
            {
              "name": "wait_for_shutdown",
              "module": "agent_base",
              "signature": "async def wait_for_shutdown(self) -> None",
              "docstring": "Wait until agent has fully stopped.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 272
            },
            {
              "name": "_handle_event",
              "module": "agent_base",
              "signature": "async def _handle_event(self, event: Event) -> None",
              "docstring": "Internal event handler with error handling and metrics.\n\nRespects shutdown state by not processing new events during shutdown.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 276
            },
            {
              "name": "_get_uptime_seconds",
              "module": "agent_base",
              "signature": "def _get_uptime_seconds(self) -> float",
              "docstring": "Get agent uptime in seconds.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 321
            },
            {
              "name": "get_status",
              "module": "agent_base",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get agent status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 327
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 45
        },
        {
          "name": "SignalAgent",
          "module": "agent_base",
          "docstring": "Base class for signal-generating agents.\n\nSignal agents:\n- Subscribe to market data\n- Generate SignalEvents (advisory only)\n- Run in parallel (fan-out)\n- NEVER send orders directly",
          "bases": [
            "BaseAgent"
          ],
          "methods": [
            {
              "name": "start",
              "module": "agent_base",
              "signature": "async def start(self) -> None",
              "docstring": "Start and register as signal agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 354
            },
            {
              "name": "get_subscribed_events",
              "module": "agent_base",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Signal agents subscribe to market data by default.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 359
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 343
        },
        {
          "name": "DecisionAgent",
          "module": "agent_base",
          "docstring": "Base class for decision-making agents.\n\nIn this system, there is exactly ONE decision agent: the CIO.",
          "bases": [
            "BaseAgent"
          ],
          "methods": [
            {
              "name": "get_subscribed_events",
              "module": "agent_base",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Decision agent subscribes to signals.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 371
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 364
        },
        {
          "name": "ValidationAgent",
          "module": "agent_base",
          "docstring": "Base class for validation agents (Risk, Compliance).",
          "bases": [
            "BaseAgent"
          ],
          "methods": [
            {
              "name": "get_subscribed_events",
              "module": "agent_base",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Validation agents subscribe to decisions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 381
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 376
        },
        {
          "name": "ExecutionAgent",
          "module": "agent_base",
          "docstring": "Base class for execution agent.\n\nONLY this agent can send orders to the broker.",
          "bases": [
            "BaseAgent"
          ],
          "methods": [
            {
              "name": "get_subscribed_events",
              "module": "agent_base",
              "signature": "def get_subscribed_events(self) -> list[EventType]",
              "docstring": "Execution agent subscribes to validated decisions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[EventType]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 393
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 386
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "abc",
        "dataclasses",
        "datetime",
        "typing",
        "core.events",
        "core.event_bus",
        "core.logger"
      ],
      "dependencies": [
        "__future__",
        "abc",
        "core.events",
        "core.event_bus",
        "core.logger"
      ]
    },
    "core.agent_factory": {
      "name": "agent_factory",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\agent_factory.py",
      "docstring": "Agent Factory\n=============\n\nFactory for creating and configuring trading agents.\n\nThis module extracts agent creation logic from TradingFirmOrchestrator\nfollowing the Single Responsibility Principle (SRP).\n\nThe factory:\n- Creates signal agents (parallel execution)\n- Creates decision agent (CIO - single authority)\n- Creates validation agents (Risk, Compliance)\n- Creates execution agent\n- Creates compliance/surveillance agents (EU/AMF)",
      "classes": [
        {
          "name": "AgentFactoryConfig",
          "module": "agent_factory",
          "docstring": "Configuration for agent factory.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "agents_config",
              "type": "dict[str, Any]"
            },
            {
              "name": "risk_config",
              "type": "dict[str, Any]"
            },
            {
              "name": "compliance_config",
              "type": "dict[str, Any]"
            },
            {
              "name": "surveillance_config",
              "type": "dict[str, Any]"
            },
            {
              "name": "transaction_reporting_config",
              "type": "dict[str, Any]"
            },
            {
              "name": "sector_map",
              "type": "dict[str, str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 36
        },
        {
          "name": "CreatedAgents",
          "module": "agent_factory",
          "docstring": "Container for all created agents.",
          "bases": [],
          "methods": [
            {
              "name": "get_all_agents",
              "module": "agent_factory",
              "signature": "def get_all_agents(self) -> list[Any]",
              "docstring": "Get all non-None agents as a list.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 57
            }
          ],
          "class_attributes": [
            {
              "name": "signal_agents",
              "type": "list[Any]"
            },
            {
              "name": "cio_agent",
              "type": "Any"
            },
            {
              "name": "risk_agent",
              "type": "Any"
            },
            {
              "name": "compliance_agent",
              "type": "Any"
            },
            {
              "name": "execution_agent",
              "type": "Any"
            },
            {
              "name": "surveillance_agent",
              "type": "Any"
            },
            {
              "name": "transaction_reporting_agent",
              "type": "Any"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 47
        },
        {
          "name": "AgentFactory",
          "module": "agent_factory",
          "docstring": "Factory for creating trading system agents.\n\nCentralizes agent creation logic, improving testability\nand following Single Responsibility Principle.\n\nUsage:\n    factory = AgentFactory(event_bus, audit_logger, broker, config)\n    agents = factory.create_all_agents()",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "agent_factory",
              "signature": "def __init__(self, event_bus: EventBus, audit_logger: AuditLogger, broker: IBBroker | None, config: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "audit_logger",
                  "type": "AuditLogger"
                },
                {
                  "name": "broker",
                  "type": "IBBroker | None"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "create_all_agents",
              "module": "agent_factory",
              "signature": "def create_all_agents(self) -> CreatedAgents",
              "docstring": "Create all trading agents.\n\nReturns:\n    CreatedAgents container with all initialized agents",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "CreatedAgents",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 99
            },
            {
              "name": "_create_signal_agents",
              "module": "agent_factory",
              "signature": "def _create_signal_agents(self) -> list[Any]",
              "docstring": "Create all signal agents (parallel fan-out).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 129
            },
            {
              "name": "_create_cio_agent",
              "module": "agent_factory",
              "signature": "def _create_cio_agent(self) -> Any",
              "docstring": "Create CIO agent (THE decision maker).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 215
            },
            {
              "name": "_create_risk_agent",
              "module": "agent_factory",
              "signature": "def _create_risk_agent(self) -> Any",
              "docstring": "Create Risk agent.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 230
            },
            {
              "name": "_create_compliance_agent",
              "module": "agent_factory",
              "signature": "def _create_compliance_agent(self) -> Any",
              "docstring": "Create Compliance agent (EU/AMF).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 264
            },
            {
              "name": "_create_execution_agent",
              "module": "agent_factory",
              "signature": "def _create_execution_agent(self) -> Any",
              "docstring": "Create Execution agent (ONLY agent that sends orders).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 287
            },
            {
              "name": "_create_surveillance_agent",
              "module": "agent_factory",
              "signature": "def _create_surveillance_agent(self)",
              "docstring": "Create Surveillance agent (MAR 2014/596/EU).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 303
            },
            {
              "name": "_create_transaction_reporting_agent",
              "module": "agent_factory",
              "signature": "def _create_transaction_reporting_agent(self)",
              "docstring": "Create Transaction Reporting agent (ESMA RTS 22/23).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 335
            },
            {
              "name": "_log_agent_summary",
              "module": "agent_factory",
              "signature": "def _log_agent_summary(self, agents: CreatedAgents) -> None",
              "docstring": "Log summary of created agents.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agents",
                  "type": "CreatedAgents"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 365
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 75
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.agent_base",
        "core.event_bus",
        "core.logger",
        "core.broker",
        "agents.macro_agent",
        "agents.stat_arb_agent",
        "agents.momentum_agent",
        "agents.market_making_agent",
        "agents.options_vol_agent",
        "agents.cio_agent",
        "agents.risk_agent",
        "agents.compliance_agent",
        "agents.execution_agent",
        "agents.surveillance_agent",
        "agents.transaction_reporting_agent"
      ],
      "dependencies": [
        "__future__",
        "core.agent_base",
        "core.event_bus",
        "core.logger",
        "core.broker",
        "agents.macro_agent",
        "agents.stat_arb_agent",
        "agents.momentum_agent",
        "agents.market_making_agent",
        "agents.options_vol_agent",
        "agents.cio_agent",
        "agents.risk_agent",
        "agents.compliance_agent",
        "agents.execution_agent",
        "agents.surveillance_agent",
        "agents.transaction_reporting_agent"
      ]
    },
    "core.attribution": {
      "name": "attribution",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\attribution.py",
      "docstring": "Performance Attribution\n=======================\n\nTracks and attributes P&L to strategies, enabling performance analysis\nand dynamic weight adjustment. Essential for institutional-grade\nportfolio management and compliance.",
      "classes": [
        {
          "name": "TradeOutcome",
          "module": "attribution",
          "docstring": "Trade outcome classification.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 25
        },
        {
          "name": "TradeRecord",
          "module": "attribution",
          "docstring": "Record of a single trade for attribution.",
          "bases": [],
          "methods": [
            {
              "name": "gross_pnl",
              "module": "attribution",
              "signature": "def gross_pnl(self) -> float",
              "docstring": "Gross P&L before costs.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 51
            },
            {
              "name": "net_pnl",
              "module": "attribution",
              "signature": "def net_pnl(self) -> float",
              "docstring": "Net P&L after costs.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 59
            },
            {
              "name": "outcome",
              "module": "attribution",
              "signature": "def outcome(self) -> TradeOutcome",
              "docstring": "Classify trade outcome.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "TradeOutcome",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 64
            },
            {
              "name": "holding_period_hours",
              "module": "attribution",
              "signature": "def holding_period_hours(self)",
              "docstring": "Calculate holding period in hours.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 76
            },
            {
              "name": "to_dict",
              "module": "attribution",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 83
            }
          ],
          "class_attributes": [
            {
              "name": "trade_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "strategy",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "entry_price",
              "type": "float"
            },
            {
              "name": "exit_price",
              "type": ""
            },
            {
              "name": "exit_timestamp",
              "type": ""
            },
            {
              "name": "realized_pnl",
              "type": "float"
            },
            {
              "name": "commission",
              "type": "float"
            },
            {
              "name": "slippage",
              "type": "float"
            },
            {
              "name": "is_closed",
              "type": "bool"
            },
            {
              "name": "tags",
              "type": "dict[str, str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 33
        },
        {
          "name": "StrategyMetrics",
          "module": "attribution",
          "docstring": "Aggregated metrics for a strategy.",
          "bases": [],
          "methods": [
            {
              "name": "annualization_factor",
              "module": "attribution",
              "signature": "def annualization_factor(self) -> float",
              "docstring": "Get annualization factor based on data frequency.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 138
            },
            {
              "name": "win_rate",
              "module": "attribution",
              "signature": "def win_rate(self) -> float",
              "docstring": "Calculate win rate.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 143
            },
            {
              "name": "profit_factor",
              "module": "attribution",
              "signature": "def profit_factor(self) -> float",
              "docstring": "Calculate profit factor (gross wins / gross losses).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 151
            },
            {
              "name": "sharpe_ratio",
              "module": "attribution",
              "signature": "def sharpe_ratio(self) -> float",
              "docstring": "Calculate annualized Sharpe ratio using excess returns.\n\nUses proper annualization based on data frequency:\n- daily: sqrt(252)\n- hourly: sqrt(252 * 6.5)\n- minute: sqrt(252 * 6.5 * 60)\netc.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 160
            },
            {
              "name": "sortino_ratio",
              "module": "attribution",
              "signature": "def sortino_ratio(self) -> float",
              "docstring": "Calculate Sortino ratio using excess returns and downside deviation.\n\nUses proper annualization based on data frequency.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 207
            },
            {
              "name": "max_drawdown",
              "module": "attribution",
              "signature": "def max_drawdown(self) -> float",
              "docstring": "Calculate maximum drawdown.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 239
            },
            {
              "name": "expectancy",
              "module": "attribution",
              "signature": "def expectancy(self) -> float",
              "docstring": "Calculate trade expectancy (expected P&L per trade).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 269
            },
            {
              "name": "to_dict",
              "module": "attribution",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 275
            }
          ],
          "class_attributes": [
            {
              "name": "strategy",
              "type": "str"
            },
            {
              "name": "total_trades",
              "type": "int"
            },
            {
              "name": "winning_trades",
              "type": "int"
            },
            {
              "name": "losing_trades",
              "type": "int"
            },
            {
              "name": "breakeven_trades",
              "type": "int"
            },
            {
              "name": "total_pnl",
              "type": "float"
            },
            {
              "name": "gross_pnl",
              "type": "float"
            },
            {
              "name": "total_commission",
              "type": "float"
            },
            {
              "name": "total_slippage",
              "type": "float"
            },
            {
              "name": "largest_win",
              "type": "float"
            },
            {
              "name": "largest_loss",
              "type": "float"
            },
            {
              "name": "avg_win",
              "type": "float"
            },
            {
              "name": "avg_loss",
              "type": "float"
            },
            {
              "name": "avg_holding_hours",
              "type": "float"
            },
            {
              "name": "returns",
              "type": "list[float]"
            },
            {
              "name": "pnl_history",
              "type": "list[tuple[datetime, float]]"
            },
            {
              "name": "risk_free_rate",
              "type": "float"
            },
            {
              "name": "data_frequency",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 105
        },
        {
          "name": "PerformanceAttribution",
          "module": "attribution",
          "docstring": "Comprehensive performance attribution system.\n\nFeatures:\n- Trade-to-strategy mapping\n- P&L attribution by strategy\n- Risk-adjusted metrics (Sharpe, Sortino)\n- Win rate and profit factor tracking\n- Rolling performance windows",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "attribution",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize attribution system.\n\nArgs:\n    config: Configuration with:\n        - rolling_window_days: Window for rolling metrics (default: 30)\n        - risk_free_rate: Annual risk-free rate (default: 0.05)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 310
            },
            {
              "name": "record_trade_entry",
              "module": "attribution",
              "signature": "def record_trade_entry(self, strategy: str, symbol: str, side: str, quantity: int, entry_price: float, commission: float, tags: ) -> str",
              "docstring": "Record a new trade entry.\n\nArgs:\n    strategy: Strategy name\n    symbol: Instrument symbol\n    side: \"buy\" or \"sell\"\n    quantity: Number of units\n    entry_price: Entry price\n    commission: Entry commission\n    tags: Optional tags for categorization\n\nReturns:\n    Trade ID for future reference",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "entry_price",
                  "type": "float"
                },
                {
                  "name": "commission",
                  "type": "float"
                },
                {
                  "name": "tags",
                  "type": ""
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 343
            },
            {
              "name": "record_trade_exit",
              "module": "attribution",
              "signature": "def record_trade_exit(self, trade_id: str, exit_price: float, commission: float, slippage: float)",
              "docstring": "Record trade exit and calculate P&L.\n\nArgs:\n    trade_id: Trade ID from entry\n    exit_price: Exit price\n    commission: Exit commission\n    slippage: Execution slippage\n\nReturns:\n    Closed TradeRecord, or None if not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trade_id",
                  "type": "str"
                },
                {
                  "name": "exit_price",
                  "type": "float"
                },
                {
                  "name": "commission",
                  "type": "float"
                },
                {
                  "name": "slippage",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 394
            },
            {
              "name": "_update_strategy_metrics",
              "module": "attribution",
              "signature": "def _update_strategy_metrics(self, trade: TradeRecord) -> None",
              "docstring": "Update strategy metrics with closed trade.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trade",
                  "type": "TradeRecord"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 445
            },
            {
              "name": "get_strategy_metrics",
              "module": "attribution",
              "signature": "def get_strategy_metrics(self, strategy: str)",
              "docstring": "Get metrics for a specific strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 494
            },
            {
              "name": "get_all_strategy_metrics",
              "module": "attribution",
              "signature": "def get_all_strategy_metrics(self) -> dict[str, StrategyMetrics]",
              "docstring": "Get metrics for all strategies.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, StrategyMetrics]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 498
            },
            {
              "name": "get_strategy_pnl",
              "module": "attribution",
              "signature": "def get_strategy_pnl(self, strategy: str) -> float",
              "docstring": "Get total P&L for a strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 502
            },
            {
              "name": "get_strategy_sharpe",
              "module": "attribution",
              "signature": "def get_strategy_sharpe(self, strategy: str) -> float",
              "docstring": "Get Sharpe ratio for a strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 507
            },
            {
              "name": "get_strategy_win_rate",
              "module": "attribution",
              "signature": "def get_strategy_win_rate(self, strategy: str) -> float",
              "docstring": "Get win rate for a strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 512
            },
            {
              "name": "record_portfolio_value",
              "module": "attribution",
              "signature": "def record_portfolio_value(self, timestamp: datetime, value: float) -> None",
              "docstring": "P1-15: Record portfolio NAV for TWR calculation.\n\nShould be called daily (or at each valuation point).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "timestamp",
                  "type": "datetime"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 521
            },
            {
              "name": "record_cash_flow",
              "module": "attribution",
              "signature": "def record_cash_flow(self, timestamp: datetime, amount: float) -> None",
              "docstring": "P1-15: Record external cash flow for MWR calculation.\n\nArgs:\n    timestamp: When the cash flow occurred\n    amount: Positive for deposits, negative for withdrawals",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "timestamp",
                  "type": "datetime"
                },
                {
                  "name": "amount",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 529
            },
            {
              "name": "calculate_twr",
              "module": "attribution",
              "signature": "def calculate_twr(self, start_date: ) -> float",
              "docstring": "P1-15: Calculate Time-Weighted Return (TWR).\n\nTWR eliminates the effect of cash flows, showing pure investment\nperformance. Used for comparing manager skill regardless of\ndeposit/withdrawal timing.\n\nFormula: TWR = ((1 + r1) * (1 + r2) * ... * (1 + rn)) - 1\nwhere rn is the sub-period return between cash flows.\n\nReturns:\n    Annualized TWR as decimal (e.g., 0.15 = 15%)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 539
            },
            {
              "name": "calculate_mwr",
              "module": "attribution",
              "signature": "def calculate_mwr(self, start_date: ) -> float",
              "docstring": "P1-15: Calculate Money-Weighted Return (MWR / IRR).\n\nMWR reflects actual investor experience including the timing\nof deposits and withdrawals. Higher weight given to returns\nwhen more capital was invested.\n\nUses Newton-Raphson iteration to solve for IRR.\n\nReturns:\n    Annualized MWR as decimal (e.g., 0.12 = 12%)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 608
            },
            {
              "name": "get_return_comparison",
              "module": "attribution",
              "signature": "def get_return_comparison(self) -> dict",
              "docstring": "P1-15: Get TWR vs MWR comparison.\n\nA large difference between TWR and MWR indicates poor timing\nof deposits/withdrawals relative to market performance.\n\nReturns:\n    Dictionary with TWR, MWR, and difference analysis",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 706
            },
            {
              "name": "get_rolling_metrics",
              "module": "attribution",
              "signature": "def get_rolling_metrics(self, strategy: str, days: )",
              "docstring": "Calculate metrics for a rolling window.\n\nArgs:\n    strategy: Strategy name\n    days: Window size (default: configured rolling_window_days)\n\nReturns:\n    StrategyMetrics for the window, or None if insufficient data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "days",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 737
            },
            {
              "name": "get_pnl_attribution",
              "module": "attribution",
              "signature": "def get_pnl_attribution(self) -> dict[str, float]",
              "docstring": "Get P&L attribution by strategy.\n\nReturns:\n    Dictionary mapping strategy to total P&L",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 785
            },
            {
              "name": "get_pnl_contribution",
              "module": "attribution",
              "signature": "def get_pnl_contribution(self) -> dict[str, float]",
              "docstring": "Get P&L contribution percentages by strategy.\n\nReturns:\n    Dictionary mapping strategy to contribution percentage",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 797
            },
            {
              "name": "get_recommended_weights",
              "module": "attribution",
              "signature": "def get_recommended_weights(self, method: str) -> dict[str, float]",
              "docstring": "Calculate recommended strategy weights based on performance.\n\nArgs:\n    method: Weighting method - \"sharpe\", \"win_rate\", \"profit_factor\", \"equal\"\n\nReturns:\n    Normalized weights by strategy",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "method",
                  "type": "str"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 812
            },
            {
              "name": "get_symbol_attribution",
              "module": "attribution",
              "signature": "def get_symbol_attribution(self) -> dict[str, float]",
              "docstring": "Get P&L attribution by symbol.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 855
            },
            {
              "name": "get_open_trades",
              "module": "attribution",
              "signature": "def get_open_trades(self, strategy: ) -> list[TradeRecord]",
              "docstring": "Get open trades.\n\nArgs:\n    strategy: Filter by strategy (optional)\n\nReturns:\n    List of open trades",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": ""
                }
              ],
              "return_type": "list[TradeRecord]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 865
            },
            {
              "name": "get_trade_history",
              "module": "attribution",
              "signature": "def get_trade_history(self, strategy: , symbol: , limit: int) -> list[TradeRecord]",
              "docstring": "Get trade history.\n\nArgs:\n    strategy: Filter by strategy (optional)\n    symbol: Filter by symbol (optional)\n    limit: Maximum trades to return\n\nReturns:\n    List of trade records",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": ""
                },
                {
                  "name": "symbol",
                  "type": ""
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[TradeRecord]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 882
            },
            {
              "name": "get_daily_pnl_series",
              "module": "attribution",
              "signature": "def get_daily_pnl_series(self, days: int) -> list[tuple[datetime, float]]",
              "docstring": "Get daily P&L time series.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "list[tuple[datetime, float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 911
            },
            {
              "name": "get_portfolio_summary",
              "module": "attribution",
              "signature": "def get_portfolio_summary(self) -> dict[str, Any]",
              "docstring": "Get portfolio-level summary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 919
            },
            {
              "name": "get_status",
              "module": "attribution",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get attribution system status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 940
            },
            {
              "name": "export_to_dataframe",
              "module": "attribution",
              "signature": "def export_to_dataframe(self)",
              "docstring": "Export trades to pandas DataFrame.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 958
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 298
        },
        {
          "name": "ExposureLimit",
          "module": "attribution",
          "docstring": "Limit definition for a sector or factor (#P6).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "limit_type",
              "type": "str"
            },
            {
              "name": "max_long",
              "type": "float"
            },
            {
              "name": "max_short",
              "type": "float"
            },
            {
              "name": "max_gross",
              "type": "float"
            },
            {
              "name": "max_net",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 975
        },
        {
          "name": "SectorFactorExposureManager",
          "module": "attribution",
          "docstring": "Manages sector and factor exposure constraints (#P6).\n\nTracks and enforces limits on:\n- Sector exposures (Technology, Healthcare, etc.)\n- Factor exposures (Value, Momentum, Size, etc.)\n- Geographic exposures",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "attribution",
              "signature": "def __init__(self, portfolio_value: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1006
            },
            {
              "name": "_initialize_default_limits",
              "module": "attribution",
              "signature": "def _initialize_default_limits(self)",
              "docstring": "Set up default exposure limits.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1015
            },
            {
              "name": "set_sector",
              "module": "attribution",
              "signature": "def set_sector(self, symbol: str, sector: str) -> None",
              "docstring": "Set sector classification for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "sector",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1041
            },
            {
              "name": "set_limit",
              "module": "attribution",
              "signature": "def set_limit(self, limit: ExposureLimit, limit_type: str) -> None",
              "docstring": "Set an exposure limit.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit",
                  "type": "ExposureLimit"
                },
                {
                  "name": "limit_type",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1045
            },
            {
              "name": "update_portfolio_value",
              "module": "attribution",
              "signature": "def update_portfolio_value(self, value: float) -> None",
              "docstring": "Update portfolio value for percentage calculations.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1050
            },
            {
              "name": "calculate_sector_exposures",
              "module": "attribution",
              "signature": "def calculate_sector_exposures(self, positions: dict[str, float]) -> dict[str, dict]",
              "docstring": "Calculate current sector exposures (#P6).\n\nArgs:\n    positions: Map of symbols to notional positions\n\nReturns:\n    Exposure by sector",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "dict[str, dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1054
            },
            {
              "name": "check_exposure_limits",
              "module": "attribution",
              "signature": "def check_exposure_limits(self, positions: dict[str, float]) -> list[dict]",
              "docstring": "Check all exposure limits and return violations (#P6).\n\nArgs:\n    positions: Map of symbols to notional positions\n\nReturns:\n    List of limit violations",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1101
            },
            {
              "name": "get_exposure_summary",
              "module": "attribution",
              "signature": "def get_exposure_summary(self) -> dict",
              "docstring": "Get summary of all exposures for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1157
            }
          ],
          "class_attributes": [
            {
              "name": "DEFAULT_SECTOR_MAP",
              "type": "dict[str, str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 985
        },
        {
          "name": "CashManager",
          "module": "attribution",
          "docstring": "Manages portfolio cash and liquidity (#P7).\n\nHandles:\n- Cash balance tracking\n- Minimum cash reserves\n- Cash sweep logic\n- T+2 settlement tracking",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "attribution",
              "signature": "def __init__(self, initial_cash: float, min_cash_reserve_pct: float, target_cash_pct: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "initial_cash",
                  "type": "float"
                },
                {
                  "name": "min_cash_reserve_pct",
                  "type": "float"
                },
                {
                  "name": "target_cash_pct",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1181
            },
            {
              "name": "update_cash",
              "module": "attribution",
              "signature": "def update_cash(self, amount: float, reason: str) -> float",
              "docstring": "Update cash balance (#P7).\n\nArgs:\n    amount: Cash change (positive = inflow, negative = outflow)\n    reason: Reason for cash change\n\nReturns:\n    New cash balance",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "amount",
                  "type": "float"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1193
            },
            {
              "name": "get_available_cash",
              "module": "attribution",
              "signature": "def get_available_cash(self, portfolio_value: float) -> float",
              "docstring": "Get cash available for trading (#P7).\n\nSubtracts minimum reserve and pending settlements.\n\nArgs:\n    portfolio_value: Total portfolio value\n\nReturns:\n    Available cash for new positions",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1208
            },
            {
              "name": "add_pending_settlement",
              "module": "attribution",
              "signature": "def add_pending_settlement(self, amount: float, settlement_date: datetime, trade_id: str) -> None",
              "docstring": "Add pending settlement (#P7).\n\nArgs:\n    amount: Settlement amount (positive = receive, negative = pay)\n    settlement_date: Expected settlement date\n    trade_id: Associated trade ID",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "amount",
                  "type": "float"
                },
                {
                  "name": "settlement_date",
                  "type": "datetime"
                },
                {
                  "name": "trade_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1227
            },
            {
              "name": "process_settlements",
              "module": "attribution",
              "signature": "def process_settlements(self) -> list[dict]",
              "docstring": "Process due settlements (#P7).\n\nReturns:\n    List of processed settlements",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1248
            },
            {
              "name": "calculate_cash_sweep",
              "module": "attribution",
              "signature": "def calculate_cash_sweep(self, portfolio_value: float) -> dict",
              "docstring": "Calculate cash sweep to maintain target allocation (#P7).\n\nArgs:\n    portfolio_value: Total portfolio value\n\nReturns:\n    Sweep recommendation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1269
            },
            {
              "name": "get_cash_status",
              "module": "attribution",
              "signature": "def get_cash_status(self) -> dict",
              "docstring": "Get cash management status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1306
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1170
        },
        {
          "name": "DividendRecord",
          "module": "attribution",
          "docstring": "Record of a dividend event (#P8).",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "attribution",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1336
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "ex_date",
              "type": "datetime"
            },
            {
              "name": "record_date",
              "type": "datetime"
            },
            {
              "name": "pay_date",
              "type": "datetime"
            },
            {
              "name": "amount_per_share",
              "type": "float"
            },
            {
              "name": "dividend_type",
              "type": "str"
            },
            {
              "name": "shares_held",
              "type": "int"
            },
            {
              "name": "total_amount",
              "type": "float"
            },
            {
              "name": "currency",
              "type": "str"
            },
            {
              "name": "withheld_tax",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1323
        },
        {
          "name": "DividendManager",
          "module": "attribution",
          "docstring": "Manages dividend tracking and processing (#P8).\n\nHandles:\n- Ex-date tracking\n- Dividend accrual\n- Tax withholding\n- DRIP (dividend reinvestment)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "attribution",
              "signature": "def __init__(self, enable_drip: bool, default_tax_rate: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "enable_drip",
                  "type": "bool"
                },
                {
                  "name": "default_tax_rate",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1351
            },
            {
              "name": "add_upcoming_dividend",
              "module": "attribution",
              "signature": "def add_upcoming_dividend(self, symbol: str, ex_date: datetime, record_date: datetime, pay_date: datetime, amount_per_share: float, shares_held: int, dividend_type: str) -> DividendRecord",
              "docstring": "Register an upcoming dividend (#P8).\n\nArgs:\n    symbol: Stock symbol\n    ex_date: Ex-dividend date\n    record_date: Record date\n    pay_date: Payment date\n    amount_per_share: Dividend per share\n    shares_held: Number of shares held\n    dividend_type: Type of dividend\n\nReturns:\n    Dividend record",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "ex_date",
                  "type": "datetime"
                },
                {
                  "name": "record_date",
                  "type": "datetime"
                },
                {
                  "name": "pay_date",
                  "type": "datetime"
                },
                {
                  "name": "amount_per_share",
                  "type": "float"
                },
                {
                  "name": "shares_held",
                  "type": "int"
                },
                {
                  "name": "dividend_type",
                  "type": "str"
                }
              ],
              "return_type": "DividendRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1358
            },
            {
              "name": "process_ex_dates",
              "module": "attribution",
              "signature": "def process_ex_dates(self, current_positions: dict[str, int], as_of: ) -> list[DividendRecord]",
              "docstring": "Process dividends going ex (#P8).\n\nArgs:\n    current_positions: Current share positions\n    as_of: Processing date (default: now)\n\nReturns:\n    Dividends going ex",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_positions",
                  "type": "dict[str, int]"
                },
                {
                  "name": "as_of",
                  "type": ""
                }
              ],
              "return_type": "list[DividendRecord]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1397
            },
            {
              "name": "process_payments",
              "module": "attribution",
              "signature": "def process_payments(self, as_of: ) -> list[dict]",
              "docstring": "Process dividend payments (#P8).\n\nArgs:\n    as_of: Processing date (default: now)\n\nReturns:\n    Processed payments",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "as_of",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1434
            },
            {
              "name": "get_dividend_forecast",
              "module": "attribution",
              "signature": "def get_dividend_forecast(self, days: int) -> dict",
              "docstring": "Get forecast of upcoming dividends.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1469
            },
            {
              "name": "get_ytd_dividends",
              "module": "attribution",
              "signature": "def get_ytd_dividends(self) -> dict",
              "docstring": "Get year-to-date dividend summary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1484
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1340
        },
        {
          "name": "CorporateActionType",
          "module": "attribution",
          "docstring": "Types of corporate actions (#P9).",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1501
        },
        {
          "name": "CorporateAction",
          "module": "attribution",
          "docstring": "Corporate action record (#P9).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "action_type",
              "type": "CorporateActionType"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "effective_date",
              "type": "datetime"
            },
            {
              "name": "details",
              "type": "dict"
            },
            {
              "name": "processed",
              "type": "bool"
            },
            {
              "name": "processed_date",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1516
        },
        {
          "name": "CorporateActionProcessor",
          "module": "attribution",
          "docstring": "Processes corporate actions (#P9).\n\nHandles:\n- Stock splits and reverse splits\n- Mergers and acquisitions\n- Spin-offs\n- Symbol changes",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "attribution",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1537
            },
            {
              "name": "add_corporate_action",
              "module": "attribution",
              "signature": "def add_corporate_action(self, action: CorporateAction) -> None",
              "docstring": "Add a corporate action to process.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "action",
                  "type": "CorporateAction"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1541
            },
            {
              "name": "process_split",
              "module": "attribution",
              "signature": "def process_split(self, action: CorporateAction, current_shares: int, cost_basis: float) -> dict",
              "docstring": "Process stock split (#P9).\n\nArgs:\n    action: Split action\n    current_shares: Current share count\n    cost_basis: Current cost basis\n\nReturns:\n    Adjusted position details",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "action",
                  "type": "CorporateAction"
                },
                {
                  "name": "current_shares",
                  "type": "int"
                },
                {
                  "name": "cost_basis",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1545
            },
            {
              "name": "process_spinoff",
              "module": "attribution",
              "signature": "def process_spinoff(self, action: CorporateAction, parent_shares: int, parent_cost_basis: float) -> dict",
              "docstring": "Process spin-off (#P9).\n\nArgs:\n    action: Spin-off action\n    parent_shares: Parent company shares held\n    parent_cost_basis: Parent cost basis\n\nReturns:\n    New position and adjusted basis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "action",
                  "type": "CorporateAction"
                },
                {
                  "name": "parent_shares",
                  "type": "int"
                },
                {
                  "name": "parent_cost_basis",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1584
            },
            {
              "name": "process_merger",
              "module": "attribution",
              "signature": "def process_merger(self, action: CorporateAction, target_shares: int, target_cost_basis: float) -> dict",
              "docstring": "Process merger/acquisition (#P9).\n\nArgs:\n    action: Merger action\n    target_shares: Target company shares held\n    target_cost_basis: Target cost basis\n\nReturns:\n    Conversion details",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "action",
                  "type": "CorporateAction"
                },
                {
                  "name": "target_shares",
                  "type": "int"
                },
                {
                  "name": "target_cost_basis",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1620
            },
            {
              "name": "process_pending_actions",
              "module": "attribution",
              "signature": "def process_pending_actions(self, positions: dict[str, tuple[int, float]], as_of: ) -> list[dict]",
              "docstring": "Process all pending corporate actions (#P9).\n\nArgs:\n    positions: Current positions\n    as_of: Processing date\n\nReturns:\n    List of processed action results",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, tuple[int, float]]"
                },
                {
                  "name": "as_of",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1663
            },
            {
              "name": "get_pending_actions",
              "module": "attribution",
              "signature": "def get_pending_actions(self) -> list[dict]",
              "docstring": "Get list of pending corporate actions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1712
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1526
        },
        {
          "name": "TaxLot",
          "module": "attribution",
          "docstring": "Individual tax lot for a position (#P10).",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "attribution",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1742
            },
            {
              "name": "is_long_term",
              "module": "attribution",
              "signature": "def is_long_term(self) -> bool",
              "docstring": "Check if lot qualifies for long-term capital gains (>1 year).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 1748
            },
            {
              "name": "adjusted_cost_basis",
              "module": "attribution",
              "signature": "def adjusted_cost_basis(self) -> float",
              "docstring": "Get cost basis adjusted for wash sale disallowance.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 1753
            }
          ],
          "class_attributes": [
            {
              "name": "lot_id",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "purchase_date",
              "type": "datetime"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "cost_per_share",
              "type": "float"
            },
            {
              "name": "total_cost",
              "type": "float"
            },
            {
              "name": "remaining_quantity",
              "type": "int"
            },
            {
              "name": "wash_sale_disallowed",
              "type": "float"
            },
            {
              "name": "holding_period_days",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1730
        },
        {
          "name": "TaxLotManager",
          "module": "attribution",
          "docstring": "Manages tax lots for cost basis tracking (#P10).\n\nSupports:\n- FIFO (First In First Out)\n- LIFO (Last In First Out)\n- Specific identification\n- Average cost\n- Highest cost\n- Lowest cost",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "attribution",
              "signature": "def __init__(self, default_method: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "default_method",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1771
            },
            {
              "name": "add_lot",
              "module": "attribution",
              "signature": "def add_lot(self, symbol: str, purchase_date: datetime, quantity: int, cost_per_share: float) -> TaxLot",
              "docstring": "Add a new tax lot (#P10).\n\nArgs:\n    symbol: Stock symbol\n    purchase_date: Purchase date\n    quantity: Number of shares\n    cost_per_share: Cost per share\n\nReturns:\n    Created tax lot",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "purchase_date",
                  "type": "datetime"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "cost_per_share",
                  "type": "float"
                }
              ],
              "return_type": "TaxLot",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1776
            },
            {
              "name": "select_lots_for_sale",
              "module": "attribution",
              "signature": "def select_lots_for_sale(self, symbol: str, quantity: int, method: ) -> list[tuple[TaxLot, int]]",
              "docstring": "Select lots for a sale using specified method (#P10).\n\nArgs:\n    symbol: Stock symbol\n    quantity: Shares to sell\n    method: Selection method (fifo, lifo, hifo, lofo, specific)\n\nReturns:\n    List of (lot, shares_to_sell) tuples",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "method",
                  "type": ""
                }
              ],
              "return_type": "list[tuple[TaxLot, int]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1810
            },
            {
              "name": "execute_sale",
              "module": "attribution",
              "signature": "def execute_sale(self, symbol: str, quantity: int, sale_price: float, sale_date: datetime, method: ) -> dict",
              "docstring": "Execute a sale and calculate gain/loss (#P10).\n\nArgs:\n    symbol: Stock symbol\n    quantity: Shares to sell\n    sale_price: Sale price per share\n    sale_date: Sale date\n    method: Lot selection method\n\nReturns:\n    Sale details with gain/loss",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "sale_price",
                  "type": "float"
                },
                {
                  "name": "sale_date",
                  "type": "datetime"
                },
                {
                  "name": "method",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1869
            },
            {
              "name": "get_lots_summary",
              "module": "attribution",
              "signature": "def get_lots_summary(self, symbol: str) -> dict",
              "docstring": "Get summary of lots for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1934
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1758
        },
        {
          "name": "BrinsonAttributor",
          "module": "attribution",
          "docstring": "Brinson performance attribution model (#P11).\n\nDecomposes portfolio return into:\n- Allocation effect (sector weight decisions)\n- Selection effect (security selection within sectors)\n- Interaction effect (combined effect)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "attribution",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1968
            },
            {
              "name": "calculate_attribution",
              "module": "attribution",
              "signature": "def calculate_attribution(self, portfolio_weights: dict[str, float], portfolio_returns: dict[str, float], benchmark_weights: dict[str, float], benchmark_returns: dict[str, float]) -> dict",
              "docstring": "Calculate Brinson attribution (#P11).\n\nArgs:\n    portfolio_weights: Portfolio sector weights\n    portfolio_returns: Portfolio sector returns\n    benchmark_weights: Benchmark sector weights\n    benchmark_returns: Benchmark sector returns\n\nReturns:\n    Attribution breakdown",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_weights",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_returns",
                  "type": "dict[str, float]"
                },
                {
                  "name": "benchmark_weights",
                  "type": "dict[str, float]"
                },
                {
                  "name": "benchmark_returns",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1971
            },
            {
              "name": "get_cumulative_attribution",
              "module": "attribution",
              "signature": "def get_cumulative_attribution(self, periods: int) -> dict",
              "docstring": "Get cumulative attribution over multiple periods.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "periods",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2053
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1958
        },
        {
          "name": "BenchmarkData",
          "module": "attribution",
          "docstring": "Benchmark data point (#P12).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "value",
              "type": "float"
            },
            {
              "name": "return_pct",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 2073
        },
        {
          "name": "BenchmarkTracker",
          "module": "attribution",
          "docstring": "Tracks portfolio performance against benchmarks (#P12).\n\nSupports multiple benchmarks and calculates:\n- Tracking error\n- Information ratio\n- Active return\n- Beta and alpha",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "attribution",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2091
            },
            {
              "name": "add_benchmark",
              "module": "attribution",
              "signature": "def add_benchmark(self, name: str) -> None",
              "docstring": "Add a benchmark to track.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2096
            },
            {
              "name": "set_active_benchmark",
              "module": "attribution",
              "signature": "def set_active_benchmark(self, name: str) -> None",
              "docstring": "Set the primary benchmark for comparison.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2101
            },
            {
              "name": "record_benchmark_value",
              "module": "attribution",
              "signature": "def record_benchmark_value(self, benchmark: str, timestamp: datetime, value: float) -> None",
              "docstring": "Record benchmark value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "benchmark",
                  "type": "str"
                },
                {
                  "name": "timestamp",
                  "type": "datetime"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2105
            },
            {
              "name": "record_portfolio_value",
              "module": "attribution",
              "signature": "def record_portfolio_value(self, timestamp: datetime, value: float) -> None",
              "docstring": "Record portfolio value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "timestamp",
                  "type": "datetime"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2119
            },
            {
              "name": "calculate_tracking_error",
              "module": "attribution",
              "signature": "def calculate_tracking_error(self, benchmark: , lookback_days: int)",
              "docstring": "Calculate tracking error vs benchmark (#P12).\n\nTracking error = std dev of (portfolio return - benchmark return)\n\nArgs:\n    benchmark: Benchmark name (uses active if None)\n    lookback_days: Days of history to use\n\nReturns:\n    Annualized tracking error",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "benchmark",
                  "type": ""
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2123
            },
            {
              "name": "calculate_information_ratio",
              "module": "attribution",
              "signature": "def calculate_information_ratio(self, benchmark: , lookback_days: int)",
              "docstring": "Calculate information ratio (#P12).\n\nIR = Active Return / Tracking Error\n\nArgs:\n    benchmark: Benchmark name\n    lookback_days: Days of history\n\nReturns:\n    Information ratio",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "benchmark",
                  "type": ""
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2179
            },
            {
              "name": "get_benchmark_comparison",
              "module": "attribution",
              "signature": "def get_benchmark_comparison(self, benchmark: ) -> dict",
              "docstring": "Get comparison of portfolio vs benchmark.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "benchmark",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2215
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 2080
        },
        {
          "name": "PortfolioHeatMapGenerator",
          "module": "attribution",
          "docstring": "Generates heat map data for portfolio visualization (#P13).\n\nCreates visualizations for:\n- Sector/asset performance\n- Risk contribution\n- Correlation matrix\n- P&L by position",
          "bases": [],
          "methods": [
            {
              "name": "generate_performance_heatmap",
              "module": "attribution",
              "signature": "def generate_performance_heatmap(positions: dict[str, dict], group_by: str) -> dict",
              "docstring": "Generate performance heat map data (#P13).\n\nArgs:\n    positions: Position data with returns\n    group_by: Grouping field (sector, asset_class, etc.)\n\nReturns:\n    Heat map data structure",
              "parameters": [
                {
                  "name": "positions",
                  "type": "dict[str, dict]"
                },
                {
                  "name": "group_by",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 2258
            },
            {
              "name": "generate_risk_contribution_heatmap",
              "module": "attribution",
              "signature": "def generate_risk_contribution_heatmap(risk_contributions: dict[str, float], positions: dict[str, dict]) -> dict",
              "docstring": "Generate risk contribution heat map (#P13).\n\nArgs:\n    risk_contributions: Risk contribution by symbol\n    positions: Position data for grouping\n\nReturns:\n    Heat map data structure",
              "parameters": [
                {
                  "name": "risk_contributions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "positions",
                  "type": "dict[str, dict]"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 2308
            },
            {
              "name": "generate_correlation_heatmap",
              "module": "attribution",
              "signature": "def generate_correlation_heatmap(correlation_matrix: dict[str, dict[str, float]]) -> dict",
              "docstring": "Generate correlation matrix heat map (#P13).\n\nArgs:\n    correlation_matrix: Pairwise correlations\n\nReturns:\n    Heat map data structure",
              "parameters": [
                {
                  "name": "correlation_matrix",
                  "type": "dict[str, dict[str, float]]"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 2342
            },
            {
              "name": "generate_pnl_heatmap",
              "module": "attribution",
              "signature": "def generate_pnl_heatmap(daily_pnl: dict[str, list[float]], dates: list[str]) -> dict",
              "docstring": "Generate P&L calendar heat map (#P13).\n\nArgs:\n    daily_pnl: Daily P&L by symbol\n    dates: List of date strings\n\nReturns:\n    Heat map data structure for calendar view",
              "parameters": [
                {
                  "name": "daily_pnl",
                  "type": "dict[str, list[float]]"
                },
                {
                  "name": "dates",
                  "type": "list[str]"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 2382
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 2246
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "collections",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy",
        "pandas"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "pandas"
      ]
    },
    "core.backtest": {
      "name": "backtest",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\backtest.py",
      "docstring": "Backtesting Framework\n=====================\n\nComprehensive backtesting engine for strategy validation (Issue #Q7).\n\nFeatures:\n- Historical data simulation\n- Multiple strategy support\n- Transaction cost modeling\n- Slippage simulation\n- Performance metrics calculation\n- Walk-forward analysis support\n- Multi-asset portfolio backtesting",
      "classes": [
        {
          "name": "BacktestMode",
          "module": "backtest",
          "docstring": "Backtest execution mode.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 32
        },
        {
          "name": "FillModel",
          "module": "backtest",
          "docstring": "Order fill simulation model.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 38
        },
        {
          "name": "Bar",
          "module": "backtest",
          "docstring": "Single OHLCV bar.",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "backtest",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 59
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "open",
              "type": "float"
            },
            {
              "name": "high",
              "type": "float"
            },
            {
              "name": "low",
              "type": "float"
            },
            {
              "name": "close",
              "type": "float"
            },
            {
              "name": "volume",
              "type": "float"
            },
            {
              "name": "vwap",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 48
        },
        {
          "name": "BacktestOrder",
          "module": "backtest",
          "docstring": "Order in backtest.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "order_type",
              "type": "str"
            },
            {
              "name": "limit_price",
              "type": ""
            },
            {
              "name": "strategy_id",
              "type": "str"
            },
            {
              "name": "signal_strength",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 66
        },
        {
          "name": "BacktestFill",
          "module": "backtest",
          "docstring": "Fill result in backtest.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "fill_time",
              "type": "datetime"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "fill_price",
              "type": "float"
            },
            {
              "name": "commission",
              "type": "float"
            },
            {
              "name": "slippage",
              "type": "float"
            },
            {
              "name": "strategy_id",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 80
        },
        {
          "name": "BacktestPosition",
          "module": "backtest",
          "docstring": "Position tracking in backtest.",
          "bases": [],
          "methods": [
            {
              "name": "update",
              "module": "backtest",
              "signature": "def update(self, fill: BacktestFill, current_price: float) -> float",
              "docstring": "Update position from fill, return realized P&L.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fill",
                  "type": "BacktestFill"
                },
                {
                  "name": "current_price",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 103
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "avg_cost",
              "type": "float"
            },
            {
              "name": "realized_pnl",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "strategy_id",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 94
        },
        {
          "name": "TransactionCostModel",
          "module": "backtest",
          "docstring": "Transaction cost model for realistic backtesting (Issue #Q10).",
          "bases": [],
          "methods": [
            {
              "name": "calculate_commission",
              "module": "backtest",
              "signature": "def calculate_commission(self, quantity: int, price: float) -> float",
              "docstring": "Calculate commission for trade.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 155
            },
            {
              "name": "calculate_slippage",
              "module": "backtest",
              "signature": "def calculate_slippage(self, quantity: int, price: float, volatility: float, adv: ) -> float",
              "docstring": "Calculate expected slippage.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "adv",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 167
            }
          ],
          "class_attributes": [
            {
              "name": "commission_per_share",
              "type": "float"
            },
            {
              "name": "commission_minimum",
              "type": "float"
            },
            {
              "name": "commission_maximum",
              "type": "float"
            },
            {
              "name": "spread_bps",
              "type": "float"
            },
            {
              "name": "market_impact_bps",
              "type": "float"
            },
            {
              "name": "slippage_volatility_mult",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 146
        },
        {
          "name": "BacktestMetrics",
          "module": "backtest",
          "docstring": "Comprehensive backtest performance metrics.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "backtest",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 240
            }
          ],
          "class_attributes": [
            {
              "name": "total_return",
              "type": "float"
            },
            {
              "name": "annualized_return",
              "type": "float"
            },
            {
              "name": "cagr",
              "type": "float"
            },
            {
              "name": "volatility",
              "type": "float"
            },
            {
              "name": "max_drawdown",
              "type": "float"
            },
            {
              "name": "max_drawdown_duration",
              "type": "int"
            },
            {
              "name": "var_95",
              "type": "float"
            },
            {
              "name": "cvar_95",
              "type": "float"
            },
            {
              "name": "sharpe_ratio",
              "type": "float"
            },
            {
              "name": "sortino_ratio",
              "type": "float"
            },
            {
              "name": "calmar_ratio",
              "type": "float"
            },
            {
              "name": "information_ratio",
              "type": "float"
            },
            {
              "name": "total_trades",
              "type": "int"
            },
            {
              "name": "winning_trades",
              "type": "int"
            },
            {
              "name": "losing_trades",
              "type": "int"
            },
            {
              "name": "win_rate",
              "type": "float"
            },
            {
              "name": "profit_factor",
              "type": "float"
            },
            {
              "name": "avg_win",
              "type": "float"
            },
            {
              "name": "avg_loss",
              "type": "float"
            },
            {
              "name": "largest_win",
              "type": "float"
            },
            {
              "name": "largest_loss",
              "type": "float"
            },
            {
              "name": "avg_trade_duration",
              "type": "float"
            },
            {
              "name": "total_commission",
              "type": "float"
            },
            {
              "name": "total_slippage",
              "type": "float"
            },
            {
              "name": "total_costs",
              "type": "float"
            },
            {
              "name": "best_month",
              "type": "float"
            },
            {
              "name": "worst_month",
              "type": "float"
            },
            {
              "name": "positive_months",
              "type": "int"
            },
            {
              "name": "total_months",
              "type": "int"
            },
            {
              "name": "avg_exposure",
              "type": "float"
            },
            {
              "name": "max_exposure",
              "type": "float"
            },
            {
              "name": "time_in_market",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 192
        },
        {
          "name": "BacktestStrategy",
          "module": "backtest",
          "docstring": "Abstract base class for backtestable strategies.",
          "bases": [
            "ABC"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "backtest",
              "signature": "def __init__(self, strategy_id: str, params: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy_id",
                  "type": "str"
                },
                {
                  "name": "params",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 285
            },
            {
              "name": "on_bar",
              "module": "backtest",
              "signature": "def on_bar(self, bar: Bar, position: , portfolio_value: float)",
              "docstring": "Generate signal on new bar.\n\nReturns order if action needed, None otherwise.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "Bar"
                },
                {
                  "name": "position",
                  "type": ""
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "abstractmethod"
              ],
              "is_async": false,
              "line_number": 290
            },
            {
              "name": "on_fill",
              "module": "backtest",
              "signature": "def on_fill(self, fill: BacktestFill) -> None",
              "docstring": "Called when order is filled.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fill",
                  "type": "BacktestFill"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 303
            },
            {
              "name": "on_start",
              "module": "backtest",
              "signature": "def on_start(self, start_date: datetime, initial_capital: float) -> None",
              "docstring": "Called at backtest start.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": "datetime"
                },
                {
                  "name": "initial_capital",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 307
            },
            {
              "name": "on_end",
              "module": "backtest",
              "signature": "def on_end(self, end_date: datetime, final_value: float) -> None",
              "docstring": "Called at backtest end.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "end_date",
                  "type": "datetime"
                },
                {
                  "name": "final_value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 311
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 282
        },
        {
          "name": "BacktestEngine",
          "module": "backtest",
          "docstring": "Main backtesting engine.\n\nSupports:\n- Multiple strategies\n- Realistic execution simulation\n- Transaction costs\n- Performance analytics",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "backtest",
              "signature": "def __init__(self, initial_capital: float, fill_model: FillModel, cost_model: , risk_free_rate: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "initial_capital",
                  "type": "float"
                },
                {
                  "name": "fill_model",
                  "type": "FillModel"
                },
                {
                  "name": "cost_model",
                  "type": ""
                },
                {
                  "name": "risk_free_rate",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 327
            },
            {
              "name": "add_strategy",
              "module": "backtest",
              "signature": "def add_strategy(self, strategy: BacktestStrategy) -> None",
              "docstring": "Add strategy to backtest.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "BacktestStrategy"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 358
            },
            {
              "name": "run",
              "module": "backtest",
              "signature": "def run(self, data: dict[str, list[Bar]], start_date: , end_date: ) -> BacktestMetrics",
              "docstring": "Run backtest on historical data.\n\nArgs:\n    data: Dictionary mapping symbol to list of bars\n    start_date: Optional start date filter\n    end_date: Optional end date filter\n\nReturns:\n    BacktestMetrics with performance results",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "dict[str, list[Bar]]"
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "BacktestMetrics",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 362
            },
            {
              "name": "_merge_bars",
              "module": "backtest",
              "signature": "def _merge_bars(self, data: dict[str, list[Bar]], start_date: , end_date: ) -> list[Bar]",
              "docstring": "Merge and sort bars from all symbols.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "dict[str, list[Bar]]"
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "list[Bar]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 469
            },
            {
              "name": "_reset",
              "module": "backtest",
              "signature": "def _reset(self) -> None",
              "docstring": "Reset engine state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 488
            },
            {
              "name": "_process_pending_orders",
              "module": "backtest",
              "signature": "def _process_pending_orders(self, bar: Bar) -> None",
              "docstring": "Process pending orders against current bar.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "Bar"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 502
            },
            {
              "name": "_get_fill_price",
              "module": "backtest",
              "signature": "def _get_fill_price(self, order: BacktestOrder, bar: Bar)",
              "docstring": "Determine fill price based on fill model.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order",
                  "type": "BacktestOrder"
                },
                {
                  "name": "bar",
                  "type": "Bar"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 573
            },
            {
              "name": "_get_volatility",
              "module": "backtest",
              "signature": "def _get_volatility(self, symbol: str) -> float",
              "docstring": "Get estimated volatility for symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 596
            },
            {
              "name": "_calculate_portfolio_value",
              "module": "backtest",
              "signature": "def _calculate_portfolio_value(self) -> float",
              "docstring": "Calculate total portfolio value.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 603
            },
            {
              "name": "_calculate_metrics",
              "module": "backtest",
              "signature": "def _calculate_metrics(self, start_date: datetime, end_date: datetime) -> BacktestMetrics",
              "docstring": "Calculate comprehensive backtest metrics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": "datetime"
                },
                {
                  "name": "end_date",
                  "type": "datetime"
                }
              ],
              "return_type": "BacktestMetrics",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 614
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 316
        },
        {
          "name": "WalkForwardAnalyzer",
          "module": "backtest",
          "docstring": "Walk-forward analysis for strategy validation (Issue #Q8 partial).\n\nHelps detect overfitting by validating on out-of-sample data.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "backtest",
              "signature": "def __init__(self, train_period_days: int, test_period_days: int, step_days: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "train_period_days",
                  "type": "int"
                },
                {
                  "name": "test_period_days",
                  "type": "int"
                },
                {
                  "name": "step_days",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 725
            },
            {
              "name": "generate_windows",
              "module": "backtest",
              "signature": "def generate_windows(self, start_date: datetime, end_date: datetime) -> Iterator[tuple[datetime, datetime, datetime, datetime]]",
              "docstring": "Generate train/test windows.\n\nYields: (train_start, train_end, test_start, test_end)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": "datetime"
                },
                {
                  "name": "end_date",
                  "type": "datetime"
                }
              ],
              "return_type": "Iterator[tuple[datetime, datetime, datetime, datetime]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 735
            },
            {
              "name": "run",
              "module": "backtest",
              "signature": "def run(self, engine_factory: Callable[, BacktestEngine], strategy_factory: Callable[, BacktestStrategy], data: dict[str, list[Bar]], param_optimizer: ) -> list[dict]",
              "docstring": "Run walk-forward analysis.\n\nArgs:\n    engine_factory: Function that creates new BacktestEngine\n    strategy_factory: Function that creates strategy with params\n    data: Historical data\n    param_optimizer: Optional function to optimize params on train set\n\nReturns:\n    List of results per window",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "engine_factory",
                  "type": "Callable[, BacktestEngine]"
                },
                {
                  "name": "strategy_factory",
                  "type": "Callable[, BacktestStrategy]"
                },
                {
                  "name": "data",
                  "type": "dict[str, list[Bar]]"
                },
                {
                  "name": "param_optimizer",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 759
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 718
        },
        {
          "name": "BacktestComparison",
          "module": "backtest",
          "docstring": "Compare multiple backtest results.",
          "bases": [],
          "methods": [
            {
              "name": "add_result",
              "module": "backtest",
              "signature": "def add_result(self, name: str, metrics: BacktestMetrics) -> None",
              "docstring": "Add backtest result.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "metrics",
                  "type": "BacktestMetrics"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 827
            },
            {
              "name": "get_comparison_table",
              "module": "backtest",
              "signature": "def get_comparison_table(self) -> list[dict]",
              "docstring": "Get comparison as table rows.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 831
            },
            {
              "name": "get_best_by_sharpe",
              "module": "backtest",
              "signature": "def get_best_by_sharpe(self)",
              "docstring": "Get strategy name with best Sharpe ratio.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 851
            },
            {
              "name": "get_best_by_return",
              "module": "backtest",
              "signature": "def get_best_by_return(self)",
              "docstring": "Get strategy name with best total return.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 857
            }
          ],
          "class_attributes": [
            {
              "name": "results",
              "type": "dict[str, BacktestMetrics]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 823
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "abc",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "math",
        "statistics",
        "collections"
      ],
      "dependencies": [
        "__future__",
        "abc"
      ]
    },
    "core.best_execution": {
      "name": "best_execution",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\best_execution.py",
      "docstring": "Best Execution Analysis\n=======================\n\nImplements MiFID II / RTS 27/28 best execution requirements.\nTracks execution quality benchmarks and generates compliance reports.",
      "classes": [
        {
          "name": "ExecutionBenchmark",
          "module": "best_execution",
          "docstring": "Benchmark types for execution quality.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 24
        },
        {
          "name": "ExecutionRecord",
          "module": "best_execution",
          "docstring": "Record of a single execution for analysis.",
          "bases": [],
          "methods": [
            {
              "name": "arrival_slippage_bps",
              "module": "best_execution",
              "signature": "def arrival_slippage_bps(self)",
              "docstring": "Calculate slippage vs arrival price in basis points.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 62
            },
            {
              "name": "vwap_slippage_bps",
              "module": "best_execution",
              "signature": "def vwap_slippage_bps(self)",
              "docstring": "Calculate slippage vs VWAP in basis points.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 75
            },
            {
              "name": "implementation_shortfall",
              "module": "best_execution",
              "signature": "def implementation_shortfall(self)",
              "docstring": "Calculate implementation shortfall.\n\nIS = (Execution Price - Decision Price) * Quantity\nFor sells, sign is reversed.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 88
            },
            {
              "name": "total_cost",
              "module": "best_execution",
              "signature": "def total_cost(self) -> float",
              "docstring": "Total execution cost including commission and slippage.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 104
            },
            {
              "name": "execution_latency_ms",
              "module": "best_execution",
              "signature": "def execution_latency_ms(self)",
              "docstring": "Latency from order to fill in milliseconds.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 110
            },
            {
              "name": "to_dict",
              "module": "best_execution",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 117
            }
          ],
          "class_attributes": [
            {
              "name": "execution_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "fill_price",
              "type": "float"
            },
            {
              "name": "commission",
              "type": "float"
            },
            {
              "name": "arrival_price",
              "type": ""
            },
            {
              "name": "vwap_price",
              "type": ""
            },
            {
              "name": "twap_price",
              "type": ""
            },
            {
              "name": "close_price",
              "type": ""
            },
            {
              "name": "midpoint_at_execution",
              "type": ""
            },
            {
              "name": "venue",
              "type": "str"
            },
            {
              "name": "algo_used",
              "type": "str"
            },
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "decision_timestamp",
              "type": ""
            },
            {
              "name": "order_timestamp",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 35
        },
        {
          "name": "ExecutionStats",
          "module": "best_execution",
          "docstring": "Aggregated execution statistics.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "best_execution",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 169
            }
          ],
          "class_attributes": [
            {
              "name": "period",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": ""
            },
            {
              "name": "total_executions",
              "type": "int"
            },
            {
              "name": "total_volume",
              "type": "int"
            },
            {
              "name": "total_notional",
              "type": "float"
            },
            {
              "name": "total_commission",
              "type": "float"
            },
            {
              "name": "avg_arrival_slippage_bps",
              "type": "float"
            },
            {
              "name": "avg_vwap_slippage_bps",
              "type": "float"
            },
            {
              "name": "max_slippage_bps",
              "type": "float"
            },
            {
              "name": "min_slippage_bps",
              "type": "float"
            },
            {
              "name": "std_slippage_bps",
              "type": "float"
            },
            {
              "name": "total_is",
              "type": "float"
            },
            {
              "name": "avg_is_per_trade",
              "type": "float"
            },
            {
              "name": "avg_latency_ms",
              "type": "float"
            },
            {
              "name": "max_latency_ms",
              "type": "float"
            },
            {
              "name": "volume_by_venue",
              "type": "dict[str, int]"
            },
            {
              "name": "volume_by_algo",
              "type": "dict[str, int]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 139
        },
        {
          "name": "BestExecutionAnalyzer",
          "module": "best_execution",
          "docstring": "Best execution analysis and reporting.\n\nCompliant with MiFID II RTS 27/28 requirements:\n- Execution quality monitoring\n- Benchmark tracking (Arrival, VWAP, TWAP)\n- Slippage analysis\n- Quarterly reporting",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "best_execution",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize best execution analyzer.\n\nArgs:\n    config: Configuration with:\n        - benchmark: Primary benchmark (default: \"vwap\")\n        - slippage_alert_bps: Alert threshold in bps (default: 50)\n        - report_retention_quarters: Quarters to retain (default: 8)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 199
            },
            {
              "name": "record_execution",
              "module": "best_execution",
              "signature": "def record_execution(self, symbol: str, side: str, quantity: int, fill_price: float, commission: float, arrival_price: , vwap_price: , twap_price: , venue: str, algo_used: str, order_id: str, decision_timestamp: , order_timestamp: ) -> ExecutionRecord",
              "docstring": "Record an execution for analysis.\n\nArgs:\n    symbol: Instrument symbol\n    side: \"buy\" or \"sell\"\n    quantity: Executed quantity\n    fill_price: Fill price\n    commission: Commission paid\n    arrival_price: Price at decision time\n    vwap_price: VWAP benchmark\n    twap_price: TWAP benchmark\n    venue: Execution venue\n    algo_used: Algorithm used\n    order_id: Original order ID\n    decision_timestamp: When decision was made\n    order_timestamp: When order was sent\n\nReturns:\n    ExecutionRecord",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "fill_price",
                  "type": "float"
                },
                {
                  "name": "commission",
                  "type": "float"
                },
                {
                  "name": "arrival_price",
                  "type": ""
                },
                {
                  "name": "vwap_price",
                  "type": ""
                },
                {
                  "name": "twap_price",
                  "type": ""
                },
                {
                  "name": "venue",
                  "type": "str"
                },
                {
                  "name": "algo_used",
                  "type": "str"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "decision_timestamp",
                  "type": ""
                },
                {
                  "name": "order_timestamp",
                  "type": ""
                }
              ],
              "return_type": "ExecutionRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 232
            },
            {
              "name": "_check_slippage_alert",
              "module": "best_execution",
              "signature": "def _check_slippage_alert(self, record: ExecutionRecord) -> None",
              "docstring": "Check if execution exceeds slippage threshold.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record",
                  "type": "ExecutionRecord"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 305
            },
            {
              "name": "calculate_stats",
              "module": "best_execution",
              "signature": "def calculate_stats(self, period: , symbol: , start_date: , end_date: ) -> ExecutionStats",
              "docstring": "Calculate execution statistics.\n\nArgs:\n    period: Period label (e.g., \"2025-Q1\")\n    symbol: Filter by symbol (None for all)\n    start_date: Start of period\n    end_date: End of period\n\nReturns:\n    ExecutionStats for the period",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "period",
                  "type": ""
                },
                {
                  "name": "symbol",
                  "type": ""
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "ExecutionStats",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 330
            },
            {
              "name": "generate_quarterly_report",
              "module": "best_execution",
              "signature": "def generate_quarterly_report(self, year: int, quarter: int) -> dict[str, Any]",
              "docstring": "Generate RTS 27/28 compliant quarterly report.\n\nArgs:\n    year: Report year\n    quarter: Quarter (1-4)\n\nReturns:\n    Report dictionary",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "year",
                  "type": "int"
                },
                {
                  "name": "quarter",
                  "type": "int"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 424
            },
            {
              "name": "get_slippage_distribution",
              "module": "best_execution",
              "signature": "def get_slippage_distribution(self, benchmark: ExecutionBenchmark, symbol: ) -> dict[str, Any]",
              "docstring": "Get slippage distribution statistics.\n\nArgs:\n    benchmark: Benchmark to use\n    symbol: Filter by symbol\n\nReturns:\n    Distribution statistics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "benchmark",
                  "type": "ExecutionBenchmark"
                },
                {
                  "name": "symbol",
                  "type": ""
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 542
            },
            {
              "name": "get_recent_executions",
              "module": "best_execution",
              "signature": "def get_recent_executions(self, limit: int, symbol: ) -> list[ExecutionRecord]",
              "docstring": "Get recent executions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit",
                  "type": "int"
                },
                {
                  "name": "symbol",
                  "type": ""
                }
              ],
              "return_type": "list[ExecutionRecord]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 587
            },
            {
              "name": "get_alerts",
              "module": "best_execution",
              "signature": "def get_alerts(self, hours: int) -> list[dict[str, Any]]",
              "docstring": "Get recent alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hours",
                  "type": "int"
                }
              ],
              "return_type": "list[dict[str, Any]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 598
            },
            {
              "name": "compare_algos",
              "module": "best_execution",
              "signature": "def compare_algos(self, start_date: , end_date: ) -> dict[str, dict[str, Any]]",
              "docstring": "Compare execution quality across algorithms.\n\nArgs:\n    start_date: Start of period\n    end_date: End of period\n\nReturns:\n    Comparison by algorithm",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "dict[str, dict[str, Any]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 606
            },
            {
              "name": "get_status",
              "module": "best_execution",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get analyzer status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 648
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 188
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "collections",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy"
      ],
      "dependencies": [
        "__future__",
        "numpy"
      ]
    },
    "core.broker": {
      "name": "broker",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\broker.py",
      "docstring": "Interactive Brokers Integration\n===============================\n\nExclusive broker interface for market data, portfolio state, and execution.\nPaper trading is the default mode (port 7497).\n\nIMPORTANT: Ensure TWS or IB Gateway is running before connecting.\n- TWS Paper: port 7497\n- TWS Live: port 7496\n- Gateway Paper: port 4002\n- Gateway Live: port 4001",
      "classes": [
        {
          "name": "ConnectionState",
          "module": "broker",
          "docstring": "Broker connection state.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 67
        },
        {
          "name": "BrokerConfig",
          "module": "broker",
          "docstring": "Interactive Brokers connection configuration.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "host",
              "type": "str"
            },
            {
              "name": "port",
              "type": "int"
            },
            {
              "name": "client_id",
              "type": "int"
            },
            {
              "name": "timeout_seconds",
              "type": "float"
            },
            {
              "name": "readonly",
              "type": "bool"
            },
            {
              "name": "account",
              "type": "str"
            },
            {
              "name": "auto_reconnect",
              "type": "bool"
            },
            {
              "name": "max_reconnect_attempts",
              "type": "int"
            },
            {
              "name": "initial_reconnect_delay_seconds",
              "type": "float"
            },
            {
              "name": "max_reconnect_delay_seconds",
              "type": "float"
            },
            {
              "name": "reconnect_backoff_multiplier",
              "type": "float"
            },
            {
              "name": "staleness_warning_seconds",
              "type": "float"
            },
            {
              "name": "staleness_critical_seconds",
              "type": "float"
            },
            {
              "name": "staleness_check_enabled",
              "type": "bool"
            },
            {
              "name": "environment",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 76
        },
        {
          "name": "MarketDataStaleness",
          "module": "broker",
          "docstring": "Tracks staleness status for market data.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "last_update",
              "type": "datetime"
            },
            {
              "name": "age_seconds",
              "type": "float"
            },
            {
              "name": "is_stale",
              "type": "bool"
            },
            {
              "name": "is_critical",
              "type": "bool"
            },
            {
              "name": "has_data",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 99
        },
        {
          "name": "Position",
          "module": "broker",
          "docstring": "Current position in a symbol.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "avg_cost",
              "type": "float"
            },
            {
              "name": "market_value",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "realized_pnl",
              "type": "float"
            },
            {
              "name": "exchange",
              "type": "str"
            },
            {
              "name": "currency",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 110
        },
        {
          "name": "PortfolioState",
          "module": "broker",
          "docstring": "Current portfolio state.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "net_liquidation",
              "type": "float"
            },
            {
              "name": "total_cash",
              "type": "float"
            },
            {
              "name": "buying_power",
              "type": "float"
            },
            {
              "name": "positions",
              "type": "dict[str, Position]"
            },
            {
              "name": "daily_pnl",
              "type": "float"
            },
            {
              "name": "account_id",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 123
        },
        {
          "name": "OrderStatus",
          "module": "broker",
          "docstring": "Order status tracking.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "order_id",
              "type": "int"
            },
            {
              "name": "client_order_id",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "OrderSide"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "filled_quantity",
              "type": "int"
            },
            {
              "name": "avg_fill_price",
              "type": "float"
            },
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "last_update",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 135
        },
        {
          "name": "IBRateLimiter",
          "module": "broker",
          "docstring": "IB API Rate Limiter (P0-1 fix).\n\nInteractive Brokers enforces rate limits:\n- Max 60 requests per 10 minutes (600 seconds) for market data\n- No duplicate requests within 15 seconds\n- Exceeding limits causes temporary bans\n\nThis class implements a sliding window rate limiter to prevent\nhitting IB's rate limits and causing connection issues.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "broker",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 166
            },
            {
              "name": "_clean_old_requests",
              "module": "broker",
              "signature": "def _clean_old_requests(self) -> None",
              "docstring": "Remove requests older than the window.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 172
            },
            {
              "name": "can_make_request",
              "module": "broker",
              "signature": "def can_make_request(self, request_key: ) -> tuple[bool, str]",
              "docstring": "Check if a request can be made within rate limits.\n\nArgs:\n    request_key: Optional key for duplicate detection (e.g., \"mktdata:AAPL\")\n\nReturns:\n    Tuple of (can_request, reason_if_not)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "request_key",
                  "type": ""
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 178
            },
            {
              "name": "record_request",
              "module": "broker",
              "signature": "def record_request(self, request_key: ) -> None",
              "docstring": "Record that a request was made.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "request_key",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 206
            },
            {
              "name": "get_remaining_requests",
              "module": "broker",
              "signature": "def get_remaining_requests(self) -> int",
              "docstring": "Get number of requests remaining in current window.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 213
            },
            {
              "name": "get_wait_time",
              "module": "broker",
              "signature": "def get_wait_time(self, request_key: ) -> float",
              "docstring": "Get seconds to wait before next request is allowed.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "request_key",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 218
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 148
        },
        {
          "name": "IBBroker",
          "module": "broker",
          "docstring": "Interactive Brokers integration using ib_insync.\n\nResponsibilities:\n- Connect to TWS/Gateway\n- Stream real-time market data\n- Query portfolio state\n- Execute orders (paper trading by default)\n\nThis is the ONLY interface to the market.\nAll market access goes through this class.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "broker",
              "signature": "def __init__(self, config: BrokerConfig)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "BrokerConfig"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 260
            },
            {
              "name": "is_connected",
              "module": "broker",
              "signature": "def is_connected(self) -> bool",
              "docstring": "Check if connected to IB.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 319
            },
            {
              "name": "connection_state",
              "module": "broker",
              "signature": "def connection_state(self) -> ConnectionState",
              "docstring": "Get current connection state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "ConnectionState",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 324
            },
            {
              "name": "account_id",
              "module": "broker",
              "signature": "def account_id(self) -> str",
              "docstring": "Get the connected account ID.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 329
            },
            {
              "name": "circuit_breaker",
              "module": "broker",
              "signature": "def circuit_breaker(self) -> CircuitBreaker",
              "docstring": "Get the circuit breaker for this broker (#S6).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "CircuitBreaker",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 334
            },
            {
              "name": "rate_limiter",
              "module": "broker",
              "signature": "def rate_limiter(self) -> IBRateLimiter",
              "docstring": "Get the IB API rate limiter (P0-1).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "IBRateLimiter",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 339
            },
            {
              "name": "_validate_paper_vs_live_config",
              "module": "broker",
              "signature": "def _validate_paper_vs_live_config(self) -> None",
              "docstring": "Validate that environment setting matches port configuration (P0-2).\n\nCRITICAL SAFETY CHECK: Prevents accidentally trading live when\nexpecting paper trading, or vice versa.\n\nRaises:\n    ValueError: If environment doesn't match port",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 343
            },
            {
              "name": "_validate_paper_account",
              "module": "broker",
              "signature": "def _validate_paper_account(self) -> bool",
              "docstring": "Validate that account ID matches expected paper/live configuration (P0-2).\n\nReturns:\n    True if account appears to match environment, False otherwise.\n    Returns True for live trading (can't distinguish live accounts).\n\nNote:\n    Paper accounts typically start with 'D' (e.g., 'DU1234567').\n    This is a heuristic check, not guaranteed.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 393
            },
            {
              "name": "_on_circuit_state_change",
              "module": "broker",
              "signature": "def _on_circuit_state_change(self, old_state: CircuitState, new_state: CircuitState) -> None",
              "docstring": "Handle circuit breaker state changes (#S6).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "old_state",
                  "type": "CircuitState"
                },
                {
                  "name": "new_state",
                  "type": "CircuitState"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 429
            },
            {
              "name": "connect",
              "module": "broker",
              "signature": "async def connect(self) -> bool",
              "docstring": "Connect to Interactive Brokers TWS or Gateway.\n\nReturns True if connected successfully.\n\nIMPORTANT: TWS or IB Gateway must be running with API enabled.\nConfigure in TWS: Edit > Global Configuration > API > Settings\n- Enable ActiveX and Socket Clients\n- Socket port: 7497 (paper) or 7496 (live)\n- Allow connections from localhost",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 447
            },
            {
              "name": "disconnect",
              "module": "broker",
              "signature": "async def disconnect(self) -> None",
              "docstring": "Disconnect from Interactive Brokers.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 526
            },
            {
              "name": "_reconnect_with_backoff",
              "module": "broker",
              "signature": "async def _reconnect_with_backoff(self) -> None",
              "docstring": "Attempt to reconnect with exponential backoff.\n\nUses configurable delays and max attempts.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 550
            },
            {
              "name": "_resubscribe_market_data",
              "module": "broker",
              "signature": "async def _resubscribe_market_data(self) -> None",
              "docstring": "Re-subscribe to market data after reconnection.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 603
            },
            {
              "name": "_reconcile_orders_on_reconnect",
              "module": "broker",
              "signature": "async def _reconcile_orders_on_reconnect(self) -> None",
              "docstring": "Reconcile order state on broker reconnection (Issue #I2).\n\nCompares local order tracking with broker's actual order state\nand resolves any discrepancies.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 621
            },
            {
              "name": "get_reconciliation_status",
              "module": "broker",
              "signature": "def get_reconciliation_status(self) -> dict",
              "docstring": "Get the last order reconciliation status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 732
            },
            {
              "name": "on_disconnect",
              "module": "broker",
              "signature": "def on_disconnect(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for disconnection events.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 736
            },
            {
              "name": "on_reconnect",
              "module": "broker",
              "signature": "def on_reconnect(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for reconnection events.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 740
            },
            {
              "name": "enable_auto_reconnect",
              "module": "broker",
              "signature": "def enable_auto_reconnect(self) -> None",
              "docstring": "Enable automatic reconnection.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 744
            },
            {
              "name": "disable_auto_reconnect",
              "module": "broker",
              "signature": "def disable_auto_reconnect(self) -> None",
              "docstring": "Disable automatic reconnection.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 750
            },
            {
              "name": "get_connection_stats",
              "module": "broker",
              "signature": "def get_connection_stats(self) -> dict[str, Any]",
              "docstring": "Get connection statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 757
            },
            {
              "name": "on_market_data",
              "module": "broker",
              "signature": "def on_market_data(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for market data updates.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 773
            },
            {
              "name": "on_fill",
              "module": "broker",
              "signature": "def on_fill(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for order fills.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 777
            },
            {
              "name": "_create_contract",
              "module": "broker",
              "signature": "def _create_contract(self, symbol: str, exchange: str, currency: str, sec_type: str) -> Contract",
              "docstring": "Create an IB contract for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "exchange",
                  "type": "str"
                },
                {
                  "name": "currency",
                  "type": "str"
                },
                {
                  "name": "sec_type",
                  "type": "str"
                }
              ],
              "return_type": "Contract",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 781
            },
            {
              "name": "_get_front_month_future",
              "module": "broker",
              "signature": "async def _get_front_month_future(self, symbol: str, exchange: str, currency: str)",
              "docstring": "Get the front month (nearest expiration) futures contract.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "exchange",
                  "type": "str"
                },
                {
                  "name": "currency",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 817
            },
            {
              "name": "subscribe_market_data",
              "module": "broker",
              "signature": "async def subscribe_market_data(self, symbol: str, exchange: str, currency: str, sec_type: str) -> bool",
              "docstring": "Subscribe to real-time market data for a symbol.\n\nArgs:\n    symbol: Ticker symbol (e.g., \"AAPL\", \"MSFT\")\n    exchange: Exchange (default SMART for IB routing)\n    currency: Currency (default USD)\n    sec_type: Security type (STK, OPT, FUT, CASH)\n\nReturns True if subscribed successfully.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "exchange",
                  "type": "str"
                },
                {
                  "name": "currency",
                  "type": "str"
                },
                {
                  "name": "sec_type",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 860
            },
            {
              "name": "unsubscribe_market_data",
              "module": "broker",
              "signature": "async def unsubscribe_market_data(self, symbol: str) -> None",
              "docstring": "Unsubscribe from market data for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 942
            },
            {
              "name": "get_portfolio_state",
              "module": "broker",
              "signature": "async def get_portfolio_state(self) -> PortfolioState",
              "docstring": "Get current portfolio state from IB.\n\nReturns positions, cash, P&L, etc.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "PortfolioState",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 956
            },
            {
              "name": "place_order",
              "module": "broker",
              "signature": "async def place_order(self, order_event: OrderEvent)",
              "docstring": "Place an order with Interactive Brokers.\n\nArgs:\n    order_event: The order to place\n\nReturns:\n    Broker order ID if successful, None otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_event",
                  "type": "OrderEvent"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1022
            },
            {
              "name": "cancel_order",
              "module": "broker",
              "signature": "async def cancel_order(self, broker_order_id: int) -> bool",
              "docstring": "Cancel an order.\n\nReturns True if cancellation was submitted successfully.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "broker_order_id",
                  "type": "int"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1142
            },
            {
              "name": "get_historical_data",
              "module": "broker",
              "signature": "async def get_historical_data(self, symbol: str, duration: str, bar_size: str, what_to_show: str, exchange: str, currency: str) -> list[dict]",
              "docstring": "Get historical data from IB.\n\nArgs:\n    symbol: Ticker symbol\n    duration: Duration string (e.g., \"1 D\", \"1 W\", \"1 M\", \"1 Y\")\n    bar_size: Bar size (e.g., \"1 min\", \"5 mins\", \"1 hour\", \"1 day\")\n    what_to_show: Data type (TRADES, MIDPOINT, BID, ASK)\n    exchange: Exchange (default SMART)\n    currency: Currency (default USD)\n\nReturns:\n    List of bar dictionaries with OHLCV data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "duration",
                  "type": "str"
                },
                {
                  "name": "bar_size",
                  "type": "str"
                },
                {
                  "name": "what_to_show",
                  "type": "str"
                },
                {
                  "name": "exchange",
                  "type": "str"
                },
                {
                  "name": "currency",
                  "type": "str"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1167
            },
            {
              "name": "get_realtime_bars",
              "module": "broker",
              "signature": "async def get_realtime_bars(self, symbol: str, bar_size: int, what_to_show: str) -> None",
              "docstring": "Subscribe to real-time bars (5-second bars).\n\nArgs:\n    symbol: Ticker symbol\n    bar_size: Bar size in seconds (5 for real-time bars)\n    what_to_show: Data type (TRADES, MIDPOINT, BID, ASK)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "bar_size",
                  "type": "int"
                },
                {
                  "name": "what_to_show",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1236
            },
            {
              "name": "_on_connected",
              "module": "broker",
              "signature": "def _on_connected(self) -> None",
              "docstring": "Handle connection event.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1276
            },
            {
              "name": "_on_disconnected",
              "module": "broker",
              "signature": "def _on_disconnected(self) -> None",
              "docstring": "Handle disconnection event.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1292
            },
            {
              "name": "_on_error",
              "module": "broker",
              "signature": "def _on_error(self, reqId: int, errorCode: int, errorString: str, contract: Contract) -> None",
              "docstring": "Handle error event from IB.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "reqId",
                  "type": "int"
                },
                {
                  "name": "errorCode",
                  "type": "int"
                },
                {
                  "name": "errorString",
                  "type": "str"
                },
                {
                  "name": "contract",
                  "type": "Contract"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1310
            },
            {
              "name": "_on_order_status",
              "module": "broker",
              "signature": "def _on_order_status(self, trade: Trade) -> None",
              "docstring": "Handle order status update.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trade",
                  "type": "Trade"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1322
            },
            {
              "name": "_on_exec_details",
              "module": "broker",
              "signature": "def _on_exec_details(self, trade: Trade, fill: Fill) -> None",
              "docstring": "Handle execution/fill details.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trade",
                  "type": "Trade"
                },
                {
                  "name": "fill",
                  "type": "Fill"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1339
            },
            {
              "name": "_safe_int",
              "module": "broker",
              "signature": "def _safe_int(self, value: Any) -> int",
              "docstring": "Safely convert value to int, handling NaN and None.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "value",
                  "type": "Any"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1370
            },
            {
              "name": "_safe_float",
              "module": "broker",
              "signature": "def _safe_float(self, value: Any) -> float",
              "docstring": "Safely convert value to float, handling NaN and None.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "value",
                  "type": "Any"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1382
            },
            {
              "name": "_on_ticker_update",
              "module": "broker",
              "signature": "def _on_ticker_update(self, ticker: Ticker, subscription_key: str) -> None",
              "docstring": "Handle ticker update from IB.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "ticker",
                  "type": "Ticker"
                },
                {
                  "name": "subscription_key",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1394
            },
            {
              "name": "get_open_orders",
              "module": "broker",
              "signature": "def get_open_orders(self) -> list[dict]",
              "docstring": "Get all open orders.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1432
            },
            {
              "name": "get_executions",
              "module": "broker",
              "signature": "def get_executions(self) -> list[dict]",
              "docstring": "Get today's executions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1450
            },
            {
              "name": "request_market_data_type",
              "module": "broker",
              "signature": "async def request_market_data_type(self, market_data_type: int) -> None",
              "docstring": "Set market data type.\n\nArgs:\n    market_data_type:\n        1 = Live (requires market data subscription)\n        2 = Frozen (last available)\n        3 = Delayed (15-20 min delay, free)\n        4 = Delayed Frozen",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "market_data_type",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1466
            },
            {
              "name": "set_contract_specs_manager",
              "module": "broker",
              "signature": "def set_contract_specs_manager(self, manager) -> None",
              "docstring": "Set the contract specifications manager for margin and multiplier lookups.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "manager"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1480
            },
            {
              "name": "check_data_staleness",
              "module": "broker",
              "signature": "def check_data_staleness(self, symbol: str) -> MarketDataStaleness",
              "docstring": "Check staleness of market data for a symbol.\n\nArgs:\n    symbol: The symbol to check\n\nReturns:\n    MarketDataStaleness with detailed status",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "MarketDataStaleness",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1487
            },
            {
              "name": "check_all_data_staleness",
              "module": "broker",
              "signature": "def check_all_data_staleness(self) -> dict[str, MarketDataStaleness]",
              "docstring": "Check staleness of all subscribed market data.\n\nReturns:\n    Dict mapping symbol to MarketDataStaleness",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, MarketDataStaleness]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1523
            },
            {
              "name": "get_stale_symbols",
              "module": "broker",
              "signature": "def get_stale_symbols(self) -> list[str]",
              "docstring": "Get list of symbols with stale data.\n\nReturns:\n    List of symbols where data is stale (warning level)",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1537
            },
            {
              "name": "get_critical_stale_symbols",
              "module": "broker",
              "signature": "def get_critical_stale_symbols(self) -> list[str]",
              "docstring": "Get list of symbols with critically stale data.\n\nReturns:\n    List of symbols where data is critically stale",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1553
            },
            {
              "name": "is_data_fresh",
              "module": "broker",
              "signature": "def is_data_fresh(self, symbol: str) -> bool",
              "docstring": "Quick check if data is fresh (not stale at all).\n\nArgs:\n    symbol: The symbol to check\n\nReturns:\n    True if data is fresh, False otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1569
            },
            {
              "name": "is_data_usable",
              "module": "broker",
              "signature": "def is_data_usable(self, symbol: str) -> bool",
              "docstring": "Check if data is usable (not critically stale).\n\nArgs:\n    symbol: The symbol to check\n\nReturns:\n    True if data can be used for trading decisions",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1582
            },
            {
              "name": "on_staleness_alert",
              "module": "broker",
              "signature": "def on_staleness_alert(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for staleness alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1609
            },
            {
              "name": "get_data_age",
              "module": "broker",
              "signature": "def get_data_age(self, symbol: str) -> float",
              "docstring": "Get age of market data in seconds.\n\nArgs:\n    symbol: The symbol to check\n\nReturns:\n    Age in seconds, or float('inf') if no data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1613
            },
            {
              "name": "get_staleness_summary",
              "module": "broker",
              "signature": "def get_staleness_summary(self) -> dict",
              "docstring": "Get summary of all market data staleness.\n\nReturns:\n    Dict with staleness statistics",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1628
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 246
        }
      ],
      "functions": [],
      "constants": [
        {
          "name": "PAPER_PORTS",
          "line": 242
        },
        {
          "name": "LIVE_PORTS",
          "line": 243
        }
      ],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "dataclasses",
        "datetime",
        "collections",
        "typing",
        "enum",
        "nest_asyncio",
        "ib_insync",
        "core.events",
        "core.circuit_breaker",
        "math",
        "math",
        "datetime",
        "core.events"
      ],
      "dependencies": [
        "__future__",
        "nest_asyncio",
        "ib_insync",
        "core.events",
        "core.circuit_breaker",
        "core.events"
      ]
    },
    "core.cache_manager": {
      "name": "cache_manager",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\cache_manager.py",
      "docstring": "Cache Manager Module\n====================\n\nMemory-bounded caching (Issue #S13).\nInternal API rate limiting (Issue #S14).\n\nFeatures:\n- LRU cache with memory limits\n- TTL-based expiration\n- Memory pressure monitoring\n- Rate limiting for internal services",
      "classes": [
        {
          "name": "CacheStats",
          "module": "cache_manager",
          "docstring": "Statistics for a cache.",
          "bases": [],
          "methods": [
            {
              "name": "hit_rate",
              "module": "cache_manager",
              "signature": "def hit_rate(self) -> float",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 44
            },
            {
              "name": "to_dict",
              "module": "cache_manager",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 48
            }
          ],
          "class_attributes": [
            {
              "name": "hits",
              "type": "int"
            },
            {
              "name": "misses",
              "type": "int"
            },
            {
              "name": "evictions",
              "type": "int"
            },
            {
              "name": "current_size",
              "type": "int"
            },
            {
              "name": "max_size",
              "type": "int"
            },
            {
              "name": "current_memory_bytes",
              "type": "int"
            },
            {
              "name": "max_memory_bytes",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 33
        },
        {
          "name": "CacheEntry",
          "module": "cache_manager",
          "docstring": "A single cache entry.\n\nAll timestamps are float values from time.time() (Unix epoch seconds)\nfor consistency across the caching system.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "key",
              "type": "str"
            },
            {
              "name": "value",
              "type": "Any"
            },
            {
              "name": "created_at",
              "type": "float"
            },
            {
              "name": "expires_at",
              "type": ""
            },
            {
              "name": "size_bytes",
              "type": "int"
            },
            {
              "name": "access_count",
              "type": "int"
            },
            {
              "name": "last_accessed",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 63
        },
        {
          "name": "BoundedLRUCache",
          "module": "cache_manager",
          "docstring": "Memory-bounded LRU cache (#S13).\n\nFeatures:\n- Maximum item count\n- Maximum memory usage\n- TTL-based expiration\n- LRU eviction",
          "bases": [
            "Generic[...]"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "cache_manager",
              "signature": "def __init__(self, name: str, max_items: int, max_memory_bytes: int, default_ttl_seconds: , on_evict: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "max_items",
                  "type": "int"
                },
                {
                  "name": "max_memory_bytes",
                  "type": "int"
                },
                {
                  "name": "default_ttl_seconds",
                  "type": ""
                },
                {
                  "name": "on_evict",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 89
            },
            {
              "name": "get",
              "module": "cache_manager",
              "signature": "def get(self, key: str, default: )",
              "docstring": "Get value from cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "default",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 108
            },
            {
              "name": "set",
              "module": "cache_manager",
              "signature": "def set(self, key: str, value: T, ttl_seconds: ) -> None",
              "docstring": "Set value in cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "T"
                },
                {
                  "name": "ttl_seconds",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 134
            },
            {
              "name": "delete",
              "module": "cache_manager",
              "signature": "def delete(self, key: str) -> bool",
              "docstring": "Delete entry from cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 170
            },
            {
              "name": "clear",
              "module": "cache_manager",
              "signature": "def clear(self) -> None",
              "docstring": "Clear all entries.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 178
            },
            {
              "name": "_remove",
              "module": "cache_manager",
              "signature": "def _remove(self, key: str) -> None",
              "docstring": "Remove entry (internal, lock must be held).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 187
            },
            {
              "name": "_ensure_capacity",
              "module": "cache_manager",
              "signature": "def _ensure_capacity(self, needed_bytes: int) -> None",
              "docstring": "Ensure we have capacity for new entry (lock must be held).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "needed_bytes",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 198
            },
            {
              "name": "_evict_lru",
              "module": "cache_manager",
              "signature": "def _evict_lru(self) -> None",
              "docstring": "Evict least recently used entry (lock must be held).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 211
            },
            {
              "name": "_evict_expired",
              "module": "cache_manager",
              "signature": "def _evict_expired(self) -> None",
              "docstring": "Evict all expired entries (lock must be held).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 219
            },
            {
              "name": "_estimate_size",
              "module": "cache_manager",
              "signature": "def _estimate_size(self, value: Any) -> int",
              "docstring": "Estimate memory size of value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "value",
                  "type": "Any"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 230
            },
            {
              "name": "get_stats",
              "module": "cache_manager",
              "signature": "def get_stats(self) -> CacheStats",
              "docstring": "Get cache statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "CacheStats",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 238
            },
            {
              "name": "contains",
              "module": "cache_manager",
              "signature": "def contains(self, key: str) -> bool",
              "docstring": "Check if key exists and is not expired.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 245
            },
            {
              "name": "keys",
              "module": "cache_manager",
              "signature": "def keys(self) -> list[str]",
              "docstring": "Get all non-expired keys.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 249
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 78
        },
        {
          "name": "CacheManager",
          "module": "cache_manager",
          "docstring": "Manages multiple named caches (#S13).\n\nProvides centralized cache management with memory monitoring.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "cache_manager",
              "signature": "def __init__(self, total_max_memory_bytes: int, memory_pressure_threshold: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "total_max_memory_bytes",
                  "type": "int"
                },
                {
                  "name": "memory_pressure_threshold",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 263
            },
            {
              "name": "create_cache",
              "module": "cache_manager",
              "signature": "def create_cache(self, name: str, max_items: int, max_memory_bytes: int, default_ttl_seconds: ) -> BoundedLRUCache",
              "docstring": "Create or get a named cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "max_items",
                  "type": "int"
                },
                {
                  "name": "max_memory_bytes",
                  "type": "int"
                },
                {
                  "name": "default_ttl_seconds",
                  "type": ""
                }
              ],
              "return_type": "BoundedLRUCache",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 274
            },
            {
              "name": "get_cache",
              "module": "cache_manager",
              "signature": "def get_cache(self, name: str)",
              "docstring": "Get cache by name.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 307
            },
            {
              "name": "delete_cache",
              "module": "cache_manager",
              "signature": "def delete_cache(self, name: str) -> bool",
              "docstring": "Delete a cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 311
            },
            {
              "name": "get_memory_usage",
              "module": "cache_manager",
              "signature": "def get_memory_usage(self) -> dict",
              "docstring": "Get memory usage across all caches.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 321
            },
            {
              "name": "check_memory_pressure",
              "module": "cache_manager",
              "signature": "def check_memory_pressure(self) -> bool",
              "docstring": "Check if memory pressure is high and trigger cleanup if needed.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 345
            },
            {
              "name": "_cleanup_under_pressure",
              "module": "cache_manager",
              "signature": "def _cleanup_under_pressure(self) -> None",
              "docstring": "Cleanup caches when under memory pressure.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 356
            },
            {
              "name": "get_all_stats",
              "module": "cache_manager",
              "signature": "def get_all_stats(self) -> dict",
              "docstring": "Get statistics for all caches.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 379
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 256
        },
        {
          "name": "RateLimitConfig",
          "module": "cache_manager",
          "docstring": "Rate limit configuration.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "requests_per_second",
              "type": "float"
            },
            {
              "name": "burst_size",
              "type": "int"
            },
            {
              "name": "retry_after_seconds",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 391
        },
        {
          "name": "RateLimitResult",
          "module": "cache_manager",
          "docstring": "Result of rate limit check.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "allowed",
              "type": "bool"
            },
            {
              "name": "wait_seconds",
              "type": "float"
            },
            {
              "name": "tokens_remaining",
              "type": "float"
            },
            {
              "name": "limit_config",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 399
        },
        {
          "name": "TokenBucketRateLimiter",
          "module": "cache_manager",
          "docstring": "Token bucket rate limiter for internal APIs (#S14).\n\nFeatures:\n- Smooth rate limiting\n- Burst allowance\n- Multiple rate limit tiers",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "cache_manager",
              "signature": "def __init__(self, name: str, requests_per_second: float, burst_size: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "requests_per_second",
                  "type": "float"
                },
                {
                  "name": "burst_size",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 417
            },
            {
              "name": "acquire",
              "module": "cache_manager",
              "signature": "def acquire(self, tokens: int) -> RateLimitResult",
              "docstring": "Try to acquire tokens.\n\nReturns RateLimitResult with allowed status and wait time if rejected.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "tokens",
                  "type": "int"
                }
              ],
              "return_type": "RateLimitResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 436
            },
            {
              "name": "get_stats",
              "module": "cache_manager",
              "signature": "def get_stats(self) -> dict",
              "docstring": "Get rate limiter statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 482
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 407
        },
        {
          "name": "RateLimiterManager",
          "module": "cache_manager",
          "docstring": "Manages rate limiters for internal APIs (#S14).\n\nProvides centralized rate limit management.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "cache_manager",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 504
            },
            {
              "name": "create_limiter",
              "module": "cache_manager",
              "signature": "def create_limiter(self, name: str, requests_per_second: float, burst_size: int) -> TokenBucketRateLimiter",
              "docstring": "Create or get a rate limiter.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "requests_per_second",
                  "type": "float"
                },
                {
                  "name": "burst_size",
                  "type": "int"
                }
              ],
              "return_type": "TokenBucketRateLimiter",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 508
            },
            {
              "name": "get_limiter",
              "module": "cache_manager",
              "signature": "def get_limiter(self, name: str)",
              "docstring": "Get limiter by name.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 526
            },
            {
              "name": "check_rate_limit",
              "module": "cache_manager",
              "signature": "def check_rate_limit(self, name: str, tokens: int) -> RateLimitResult",
              "docstring": "Check rate limit for a named limiter.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "tokens",
                  "type": "int"
                }
              ],
              "return_type": "RateLimitResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 530
            },
            {
              "name": "get_all_stats",
              "module": "cache_manager",
              "signature": "def get_all_stats(self) -> dict",
              "docstring": "Get statistics for all rate limiters.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 539
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 497
        },
        {
          "name": "RateLimitExceeded",
          "module": "cache_manager",
          "docstring": "Exception raised when rate limit is exceeded.",
          "bases": [
            "Exception"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 583
        }
      ],
      "functions": [
        {
          "name": "rate_limited",
          "module": "cache_manager",
          "signature": "def rate_limited(limiter_name: str, manager: , on_reject: )",
          "docstring": "Decorator for rate-limited functions.\n\nArgs:\n    limiter_name: Name of the rate limiter to use\n    manager: RateLimiterManager instance (required)\n    on_reject: Callback when rate limited (default raises exception)",
          "parameters": [
            {
              "name": "limiter_name",
              "type": "str"
            },
            {
              "name": "manager",
              "type": ""
            },
            {
              "name": "on_reject",
              "type": ""
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 547
        },
        {
          "name": "get_cache_manager",
          "module": "cache_manager",
          "signature": "def get_cache_manager() -> CacheManager",
          "docstring": "Get global cache manager instance.",
          "parameters": [],
          "return_type": "CacheManager",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 593
        },
        {
          "name": "get_rate_limiter_manager",
          "module": "cache_manager",
          "signature": "def get_rate_limiter_manager() -> RateLimiterManager",
          "docstring": "Get global rate limiter manager instance.",
          "parameters": [],
          "return_type": "RateLimiterManager",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 601
        }
      ],
      "constants": [
        {
          "name": "T",
          "line": 29
        }
      ],
      "imports": [
        "__future__",
        "logging",
        "time",
        "threading",
        "sys",
        "dataclasses",
        "datetime",
        "typing",
        "collections",
        "functools"
      ],
      "dependencies": [
        "__future__",
        "time",
        "threading"
      ]
    },
    "core.circuit_breaker": {
      "name": "circuit_breaker",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\circuit_breaker.py",
      "docstring": "Circuit Breaker Pattern\n=======================\n\nImplements the circuit breaker pattern for fault tolerance.\nAddresses issue #S6: No circuit breaker pattern for broker connection.\n\nThe circuit breaker prevents cascading failures by:\n1. Monitoring failure rates\n2. Opening the circuit when failures exceed threshold\n3. Failing fast when circuit is open (no wasted resources)\n4. Periodically testing if service has recovered (half-open state)\n5. Closing the circuit when service is healthy again\n\nStates:\n- CLOSED: Normal operation, requests pass through\n- OPEN: Service is down, requests fail immediately\n- HALF_OPEN: Testing if service recovered\n\nReference: Martin Fowler's Circuit Breaker pattern",
      "classes": [
        {
          "name": "CircuitState",
          "module": "circuit_breaker",
          "docstring": "Circuit breaker states.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 41
        },
        {
          "name": "CircuitBreakerConfig",
          "module": "circuit_breaker",
          "docstring": "Configuration for circuit breaker.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "failure_threshold",
              "type": "int"
            },
            {
              "name": "failure_rate_threshold",
              "type": "float"
            },
            {
              "name": "min_calls_for_rate",
              "type": "int"
            },
            {
              "name": "reset_timeout_seconds",
              "type": "float"
            },
            {
              "name": "half_open_max_calls",
              "type": "int"
            },
            {
              "name": "success_threshold",
              "type": "int"
            },
            {
              "name": "window_size_seconds",
              "type": "float"
            },
            {
              "name": "call_timeout_seconds",
              "type": "float"
            },
            {
              "name": "failure_exceptions",
              "type": "tuple[type, Ellipsis]"
            },
            {
              "name": "ignore_exceptions",
              "type": "tuple[type, Ellipsis]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 49
        },
        {
          "name": "CircuitStats",
          "module": "circuit_breaker",
          "docstring": "Statistics for circuit breaker monitoring.",
          "bases": [],
          "methods": [
            {
              "name": "update_time",
              "module": "circuit_breaker",
              "signature": "def update_time(self) -> None",
              "docstring": "Update time in current state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 89
            },
            {
              "name": "to_dict",
              "module": "circuit_breaker",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 95
            }
          ],
          "class_attributes": [
            {
              "name": "state",
              "type": "CircuitState"
            },
            {
              "name": "total_calls",
              "type": "int"
            },
            {
              "name": "successful_calls",
              "type": "int"
            },
            {
              "name": "failed_calls",
              "type": "int"
            },
            {
              "name": "rejected_calls",
              "type": "int"
            },
            {
              "name": "consecutive_successes",
              "type": "int"
            },
            {
              "name": "consecutive_failures",
              "type": "int"
            },
            {
              "name": "last_failure_time",
              "type": ""
            },
            {
              "name": "last_success_time",
              "type": ""
            },
            {
              "name": "last_state_change",
              "type": "datetime"
            },
            {
              "name": "time_in_current_state_seconds",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 75
        },
        {
          "name": "CircuitBreakerError",
          "module": "circuit_breaker",
          "docstring": "Base exception for circuit breaker errors.",
          "bases": [
            "Exception"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 120
        },
        {
          "name": "CircuitOpenError",
          "module": "circuit_breaker",
          "docstring": "Raised when circuit is open and call is rejected.",
          "bases": [
            "CircuitBreakerError"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "circuit_breaker",
              "signature": "def __init__(self, circuit_name: str, retry_after_seconds: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "circuit_name",
                  "type": "str"
                },
                {
                  "name": "retry_after_seconds",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 127
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 125
        },
        {
          "name": "CallRecord",
          "module": "circuit_breaker",
          "docstring": "Record of a single call for sliding window tracking.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "circuit_breaker",
              "signature": "def __init__(self, timestamp: datetime, success: bool)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "timestamp",
                  "type": "datetime"
                },
                {
                  "name": "success",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 139
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 135
        },
        {
          "name": "CircuitBreaker",
          "module": "circuit_breaker",
          "docstring": "Circuit breaker implementation with sliding window failure tracking.\n\nUsage:\n    breaker = CircuitBreaker(\"broker\", config)\n\n    # As decorator\n    @breaker.protect\n    async def call_broker():\n        ...\n\n    # Or manually\n    async with breaker:\n        await call_broker()\n\n    # Or\n    result = await breaker.call(call_broker)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "circuit_breaker",
              "signature": "def __init__(self, name: str, config: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 164
            },
            {
              "name": "name",
              "module": "circuit_breaker",
              "signature": "def name(self) -> str",
              "docstring": "Get circuit breaker name.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 187
            },
            {
              "name": "state",
              "module": "circuit_breaker",
              "signature": "def state(self) -> CircuitState",
              "docstring": "Get current circuit state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "CircuitState",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 192
            },
            {
              "name": "is_closed",
              "module": "circuit_breaker",
              "signature": "def is_closed(self) -> bool",
              "docstring": "Check if circuit is closed (normal operation).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 197
            },
            {
              "name": "is_open",
              "module": "circuit_breaker",
              "signature": "def is_open(self) -> bool",
              "docstring": "Check if circuit is open (failing fast).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 202
            },
            {
              "name": "is_half_open",
              "module": "circuit_breaker",
              "signature": "def is_half_open(self) -> bool",
              "docstring": "Check if circuit is half-open (testing recovery).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 207
            },
            {
              "name": "on_state_change",
              "module": "circuit_breaker",
              "signature": "def on_state_change(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for state changes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 211
            },
            {
              "name": "on_failure",
              "module": "circuit_breaker",
              "signature": "def on_failure(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for failures.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 217
            },
            {
              "name": "get_stats",
              "module": "circuit_breaker",
              "signature": "def get_stats(self) -> CircuitStats",
              "docstring": "Get current statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "CircuitStats",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 221
            },
            {
              "name": "_transition_to",
              "module": "circuit_breaker",
              "signature": "async def _transition_to(self, new_state: CircuitState) -> None",
              "docstring": "Transition to a new state.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "new_state",
                  "type": "CircuitState"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 227
            },
            {
              "name": "_cleanup_old_records",
              "module": "circuit_breaker",
              "signature": "def _cleanup_old_records(self) -> None",
              "docstring": "Remove records outside the sliding window.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 252
            },
            {
              "name": "_calculate_failure_rate",
              "module": "circuit_breaker",
              "signature": "def _calculate_failure_rate(self) -> tuple[float, int]",
              "docstring": "Calculate failure rate from sliding window.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[float, int]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 259
            },
            {
              "name": "_should_allow_call",
              "module": "circuit_breaker",
              "signature": "async def _should_allow_call(self) -> bool",
              "docstring": "Determine if a call should be allowed.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 270
            },
            {
              "name": "_record_success",
              "module": "circuit_breaker",
              "signature": "async def _record_success(self) -> None",
              "docstring": "Record a successful call.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 292
            },
            {
              "name": "_record_failure",
              "module": "circuit_breaker",
              "signature": "async def _record_failure(self, exc: Exception) -> None",
              "docstring": "Record a failed call.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exc",
                  "type": "Exception"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 309
            },
            {
              "name": "call",
              "module": "circuit_breaker",
              "signature": "async def call(self, func: Callable[Ellipsis, Any]) -> Any",
              "docstring": "Execute a function through the circuit breaker.\n\nArgs:\n    func: Async function to call\n    *args: Positional arguments\n    **kwargs: Keyword arguments\n\nReturns:\n    Result of the function\n\nRaises:\n    CircuitOpenError: If circuit is open\n    Exception: Any exception from the wrapped function",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "func",
                  "type": "Callable[Ellipsis, Any]"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 362
            },
            {
              "name": "protect",
              "module": "circuit_breaker",
              "signature": "def protect(self, func: )",
              "docstring": "Decorator to protect a function with the circuit breaker.\n\nArgs:\n    func: Function to protect\n    fallback: Optional fallback function when circuit is open\n\nUsage:\n    @breaker.protect\n    async def my_func():\n        ...\n\n    @breaker.protect(fallback=my_fallback)\n    async def my_func():\n        ...",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "func",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 433
            },
            {
              "name": "__aenter__",
              "module": "circuit_breaker",
              "signature": "async def __aenter__(self)",
              "docstring": "Context manager entry.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 471
            },
            {
              "name": "__aexit__",
              "module": "circuit_breaker",
              "signature": "async def __aexit__(self, exc_type, exc_val, exc_tb)",
              "docstring": "Context manager exit.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exc_type"
                },
                {
                  "name": "exc_val"
                },
                {
                  "name": "exc_tb"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 489
            },
            {
              "name": "force_open",
              "module": "circuit_breaker",
              "signature": "def force_open(self) -> None",
              "docstring": "Force the circuit to open (for testing or manual intervention).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 500
            },
            {
              "name": "force_close",
              "module": "circuit_breaker",
              "signature": "def force_close(self) -> None",
              "docstring": "Force the circuit to close (for testing or manual intervention).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 506
            },
            {
              "name": "reset",
              "module": "circuit_breaker",
              "signature": "def reset(self) -> None",
              "docstring": "Reset the circuit breaker to initial state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 512
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 144
        },
        {
          "name": "CircuitBreakerRegistry",
          "module": "circuit_breaker",
          "docstring": "Registry for managing multiple circuit breakers.\n\nProvides centralized access and monitoring for all circuit breakers.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "circuit_breaker",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 531
            },
            {
              "name": "register",
              "module": "circuit_breaker",
              "signature": "def register(self, name: str, config: ) -> CircuitBreaker",
              "docstring": "Register a new circuit breaker.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "CircuitBreaker",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 535
            },
            {
              "name": "get",
              "module": "circuit_breaker",
              "signature": "def get(self, name: str)",
              "docstring": "Get a circuit breaker by name.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 550
            },
            {
              "name": "get_or_create",
              "module": "circuit_breaker",
              "signature": "def get_or_create(self, name: str, config: ) -> CircuitBreaker",
              "docstring": "Get existing or create new circuit breaker.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "CircuitBreaker",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 554
            },
            {
              "name": "get_all_stats",
              "module": "circuit_breaker",
              "signature": "def get_all_stats(self) -> dict[str, dict[str, Any]]",
              "docstring": "Get stats for all circuit breakers.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, dict[str, Any]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 564
            },
            {
              "name": "get_open_circuits",
              "module": "circuit_breaker",
              "signature": "def get_open_circuits(self) -> list[str]",
              "docstring": "Get names of all open circuits.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 571
            },
            {
              "name": "reset_all",
              "module": "circuit_breaker",
              "signature": "def reset_all(self) -> None",
              "docstring": "Reset all circuit breakers.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 578
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 524
        }
      ],
      "functions": [
        {
          "name": "get_circuit_registry",
          "module": "circuit_breaker",
          "signature": "def get_circuit_registry() -> CircuitBreakerRegistry",
          "docstring": "Get or create the global circuit breaker registry.",
          "parameters": [],
          "return_type": "CircuitBreakerRegistry",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 588
        },
        {
          "name": "get_circuit_breaker",
          "module": "circuit_breaker",
          "signature": "def get_circuit_breaker(name: str, config: ) -> CircuitBreaker",
          "docstring": "Get or create a circuit breaker from the global registry.",
          "parameters": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "config",
              "type": ""
            }
          ],
          "return_type": "CircuitBreaker",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 596
        }
      ],
      "constants": [
        {
          "name": "T",
          "line": 38
        }
      ],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "functools",
        "time"
      ],
      "dependencies": [
        "__future__",
        "time"
      ]
    },
    "core.commodity_analytics": {
      "name": "commodity_analytics",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\commodity_analytics.py",
      "docstring": "Commodity Analytics Module\n==========================\n\nAddresses issues:\n- #F18: Commodity sector rotation not implemented\n- #F19: No commodity index tracking\n- #F20: Missing commodity correlation matrix\n- #F21: No commodity fundamental data feeds\n\nFeatures:\n- Sector rotation signals for commodities\n- Index tracking (CRB, GSCI, BCOM)\n- Correlation analysis across commodity groups\n- Fundamental data integration framework",
      "classes": [
        {
          "name": "CommoditySector",
          "module": "commodity_analytics",
          "docstring": "Commodity sectors for rotation analysis.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 39
        },
        {
          "name": "CommodityIndex",
          "module": "commodity_analytics",
          "docstring": "Major commodity indices.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 49
        },
        {
          "name": "SectorMetrics",
          "module": "commodity_analytics",
          "docstring": "Metrics for a commodity sector.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "commodity_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 120
            }
          ],
          "class_attributes": [
            {
              "name": "sector",
              "type": "CommoditySector"
            },
            {
              "name": "return_1d",
              "type": "float"
            },
            {
              "name": "return_1w",
              "type": "float"
            },
            {
              "name": "return_1m",
              "type": "float"
            },
            {
              "name": "return_3m",
              "type": "float"
            },
            {
              "name": "return_6m",
              "type": "float"
            },
            {
              "name": "return_ytd",
              "type": "float"
            },
            {
              "name": "volatility_20d",
              "type": "float"
            },
            {
              "name": "momentum_score",
              "type": "float"
            },
            {
              "name": "relative_strength",
              "type": "float"
            },
            {
              "name": "trend_score",
              "type": "float"
            },
            {
              "name": "rank",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 105
        },
        {
          "name": "SectorRotationSignal",
          "module": "commodity_analytics",
          "docstring": "Sector rotation trading signal (#F18).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "commodity_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 152
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "overweight_sectors",
              "type": "list[CommoditySector]"
            },
            {
              "name": "underweight_sectors",
              "type": "list[CommoditySector]"
            },
            {
              "name": "neutral_sectors",
              "type": "list[CommoditySector]"
            },
            {
              "name": "recommended_weights",
              "type": "dict[CommoditySector, float]"
            },
            {
              "name": "signal_strength",
              "type": "float"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "reasoning",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 141
        },
        {
          "name": "CommoditySectorRotation",
          "module": "commodity_analytics",
          "docstring": "Commodity sector rotation strategy (#F18).\n\nAnalyzes momentum and relative strength across commodity sectors\nto generate rotation signals.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "commodity_analytics",
              "signature": "def __init__(self, lookback_momentum: int, lookback_trend: int, rebalance_threshold: float)",
              "docstring": "Initialize sector rotation analyzer.\n\nArgs:\n    lookback_momentum: Days for momentum calculation\n    lookback_trend: Days for trend calculation\n    rebalance_threshold: Min change for rebalance signal",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lookback_momentum",
                  "type": "int"
                },
                {
                  "name": "lookback_trend",
                  "type": "int"
                },
                {
                  "name": "rebalance_threshold",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 174
            },
            {
              "name": "update_sector_price",
              "module": "commodity_analytics",
              "signature": "def update_sector_price(self, sector: CommoditySector, date: datetime, price: float) -> None",
              "docstring": "Update sector price (typically from sector ETF or index).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "sector",
                  "type": "CommoditySector"
                },
                {
                  "name": "date",
                  "type": "datetime"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 198
            },
            {
              "name": "calculate_sector_metrics",
              "module": "commodity_analytics",
              "signature": "def calculate_sector_metrics(self) -> list[SectorMetrics]",
              "docstring": "Calculate metrics for all sectors.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[SectorMetrics]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 211
            },
            {
              "name": "generate_rotation_signal",
              "module": "commodity_analytics",
              "signature": "def generate_rotation_signal(self)",
              "docstring": "Generate sector rotation signal.\n\nReturns signal with recommended over/underweight sectors.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 290
            },
            {
              "name": "_generate_reasoning",
              "module": "commodity_analytics",
              "signature": "def _generate_reasoning(self, metrics: list[SectorMetrics]) -> str",
              "docstring": "Generate reasoning for signal.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metrics",
                  "type": "list[SectorMetrics]"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 359
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 166
        },
        {
          "name": "IndexComposition",
          "module": "commodity_analytics",
          "docstring": "Composition of a commodity index.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "commodity_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 386
            }
          ],
          "class_attributes": [
            {
              "name": "index",
              "type": "CommodityIndex"
            },
            {
              "name": "components",
              "type": "dict[str, float]"
            },
            {
              "name": "last_updated",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 380
        },
        {
          "name": "CommodityIndexTracker",
          "module": "commodity_analytics",
          "docstring": "Tracks commodity indices (#F19).\n\nReplicates index performance and calculates tracking error.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "commodity_analytics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 442
            },
            {
              "name": "update_price",
              "module": "commodity_analytics",
              "signature": "def update_price(self, symbol: str, date: datetime, price: float) -> None",
              "docstring": "Update component price.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "date",
                  "type": "datetime"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 446
            },
            {
              "name": "calculate_index_value",
              "module": "commodity_analytics",
              "signature": "def calculate_index_value(self, index: CommodityIndex, as_of: )",
              "docstring": "Calculate theoretical index value.\n\nArgs:\n    index: Index to calculate\n    as_of: Date (default: latest)\n\nReturns:\n    Index value or None if insufficient data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "index",
                  "type": "CommodityIndex"
                },
                {
                  "name": "as_of",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 450
            },
            {
              "name": "get_index_returns",
              "module": "commodity_analytics",
              "signature": "def get_index_returns(self, index: CommodityIndex, period_days: int) -> dict[str, float]",
              "docstring": "Get index returns for different periods.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "index",
                  "type": "CommodityIndex"
                },
                {
                  "name": "period_days",
                  "type": "int"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 499
            },
            {
              "name": "calculate_tracking_error",
              "module": "commodity_analytics",
              "signature": "def calculate_tracking_error(self, portfolio_returns: list[float], index_returns: list[float]) -> float",
              "docstring": "Calculate tracking error vs benchmark.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_returns",
                  "type": "list[float]"
                },
                {
                  "name": "index_returns",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 521
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 395
        },
        {
          "name": "CorrelationMatrix",
          "module": "commodity_analytics",
          "docstring": "Correlation matrix for commodities.",
          "bases": [],
          "methods": [
            {
              "name": "get_correlation",
              "module": "commodity_analytics",
              "signature": "def get_correlation(self, symbol1: str, symbol2: str)",
              "docstring": "Get correlation between two symbols.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol1",
                  "type": "str"
                },
                {
                  "name": "symbol2",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 546
            },
            {
              "name": "get_highly_correlated",
              "module": "commodity_analytics",
              "signature": "def get_highly_correlated(self, threshold: float) -> list[tuple[str, str, float]]",
              "docstring": "Get pairs with correlation above threshold.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "threshold",
                  "type": "float"
                }
              ],
              "return_type": "list[tuple[str, str, float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 555
            },
            {
              "name": "to_dict",
              "module": "commodity_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 566
            }
          ],
          "class_attributes": [
            {
              "name": "symbols",
              "type": "list[str]"
            },
            {
              "name": "correlations",
              "type": "list[list[float]]"
            },
            {
              "name": "as_of_date",
              "type": "datetime"
            },
            {
              "name": "lookback_days",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 539
        },
        {
          "name": "CommodityCorrelationAnalyzer",
          "module": "commodity_analytics",
          "docstring": "Analyzes correlations across commodities (#F20).\n\nTracks rolling correlations and detects regime changes.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "commodity_analytics",
              "signature": "def __init__(self, lookback_days: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 583
            },
            {
              "name": "update_return",
              "module": "commodity_analytics",
              "signature": "def update_return(self, symbol: str, daily_return: float) -> None",
              "docstring": "Update daily return for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "daily_return",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 588
            },
            {
              "name": "calculate_correlation_matrix",
              "module": "commodity_analytics",
              "signature": "def calculate_correlation_matrix(self, symbols: )",
              "docstring": "Calculate correlation matrix.\n\nArgs:\n    symbols: Symbols to include (default: all)\n\nReturns:\n    CorrelationMatrix or None if insufficient data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 596
            },
            {
              "name": "_pearson_correlation",
              "module": "commodity_analytics",
              "signature": "def _pearson_correlation(self, x: list[float], y: list[float]) -> float",
              "docstring": "Calculate Pearson correlation coefficient.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "x",
                  "type": "list[float]"
                },
                {
                  "name": "y",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 652
            },
            {
              "name": "get_sector_correlations",
              "module": "commodity_analytics",
              "signature": "def get_sector_correlations(self) -> dict[tuple[CommoditySector, CommoditySector], float]",
              "docstring": "Get average correlations between sectors.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[tuple[CommoditySector, CommoditySector], float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 672
            },
            {
              "name": "_get_sector",
              "module": "commodity_analytics",
              "signature": "def _get_sector(self, symbol: str)",
              "docstring": "Get sector for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 697
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 576
        },
        {
          "name": "FundamentalData",
          "module": "commodity_analytics",
          "docstring": "Fundamental data point for a commodity.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "date",
              "type": "datetime"
            },
            {
              "name": "data_type",
              "type": "str"
            },
            {
              "name": "value",
              "type": "float"
            },
            {
              "name": "unit",
              "type": "str"
            },
            {
              "name": "source",
              "type": "str"
            },
            {
              "name": "metadata",
              "type": "dict"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 710
        },
        {
          "name": "CommodityFundamentalDataManager",
          "module": "commodity_analytics",
          "docstring": "Manages commodity fundamental data feeds (#F21).\n\nFramework for integrating various fundamental data sources.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "commodity_analytics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 744
            },
            {
              "name": "register_data_source",
              "module": "commodity_analytics",
              "signature": "def register_data_source(self, data_type: str, fetch_function: Callable[, ]) -> None",
              "docstring": "Register a fundamental data source.\n\nArgs:\n    data_type: Type of data\n    fetch_function: Function to fetch data (symbol, date) -> data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data_type",
                  "type": "str"
                },
                {
                  "name": "fetch_function",
                  "type": "Callable[, ]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 748
            },
            {
              "name": "store_data",
              "module": "commodity_analytics",
              "signature": "def store_data(self, data: FundamentalData) -> None",
              "docstring": "Store fundamental data point.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "FundamentalData"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 763
            },
            {
              "name": "get_latest",
              "module": "commodity_analytics",
              "signature": "def get_latest(self, symbol: str, data_type: str)",
              "docstring": "Get latest fundamental data for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "data_type",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 772
            },
            {
              "name": "get_time_series",
              "module": "commodity_analytics",
              "signature": "def get_time_series(self, symbol: str, data_type: str, lookback_days: int) -> list[FundamentalData]",
              "docstring": "Get time series of fundamental data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "data_type",
                  "type": "str"
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                }
              ],
              "return_type": "list[FundamentalData]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 782
            },
            {
              "name": "get_supply_demand_balance",
              "module": "commodity_analytics",
              "signature": "def get_supply_demand_balance(self, symbol: str)",
              "docstring": "Calculate supply/demand balance for a commodity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 795
            },
            {
              "name": "get_available_data_types",
              "module": "commodity_analytics",
              "signature": "def get_available_data_types(self, symbol: str) -> list[str]",
              "docstring": "Get available data types for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 816
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 721
        }
      ],
      "functions": [],
      "constants": [
        {
          "name": "SIGNAL_STRENGTH_NORMALIZATION_FACTOR",
          "line": 36
        },
        {
          "name": "COMMODITY_SECTORS",
          "line": 59
        }
      ],
      "imports": [
        "__future__",
        "logging",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "math"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.compliance_control": {
      "name": "compliance_control",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\compliance_control.py",
      "docstring": "Compliance Control Module\n=========================\n\nControl room functionality, Chinese walls, and conflict of interest tracking.\n\nIssues Addressed:\n- #C35: Control room functionality missing\n- #C36: Chinese walls not enforced in system\n- #C37: Research distribution controls missing\n- #C38: Conflict of interest tracking incomplete",
      "classes": [
        {
          "name": "AlertSeverity",
          "module": "compliance_control",
          "docstring": "Alert severity levels.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 31
        },
        {
          "name": "AlertCategory",
          "module": "compliance_control",
          "docstring": "Alert categories for control room.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 39
        },
        {
          "name": "ControlRoomAlert",
          "module": "compliance_control",
          "docstring": "Alert for the control room (#C35).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "compliance_control",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 68
            }
          ],
          "class_attributes": [
            {
              "name": "alert_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "category",
              "type": "AlertCategory"
            },
            {
              "name": "severity",
              "type": "AlertSeverity"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "source",
              "type": "str"
            },
            {
              "name": "affected_entities",
              "type": "list[str]"
            },
            {
              "name": "requires_acknowledgment",
              "type": "bool"
            },
            {
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "name": "acknowledged_by",
              "type": ""
            },
            {
              "name": "acknowledged_at",
              "type": ""
            },
            {
              "name": "resolution_notes",
              "type": ""
            },
            {
              "name": "escalation_level",
              "type": "int"
            },
            {
              "name": "escalated_at",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 50
        },
        {
          "name": "ControlRoomState",
          "module": "compliance_control",
          "docstring": "Overall control room state (#C35).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "compliance_control",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 100
            }
          ],
          "class_attributes": [
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "active_alerts",
              "type": "int"
            },
            {
              "name": "critical_alerts",
              "type": "int"
            },
            {
              "name": "pending_acknowledgments",
              "type": "int"
            },
            {
              "name": "last_update",
              "type": "datetime"
            },
            {
              "name": "market_status",
              "type": "str"
            },
            {
              "name": "trading_enabled",
              "type": "bool"
            },
            {
              "name": "manual_override",
              "type": "bool"
            },
            {
              "name": "override_reason",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 88
        },
        {
          "name": "ControlRoom",
          "module": "compliance_control",
          "docstring": "Centralized control room for monitoring and alerts (#C35).\n\nFeatures:\n- Real-time alert management\n- Escalation workflows\n- Manual override controls\n- Trading halt/resume\n- Status dashboard",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "compliance_control",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 134
            },
            {
              "name": "register_alert_handler",
              "module": "compliance_control",
              "signature": "def register_alert_handler(self, handler: Callable[, None]) -> None",
              "docstring": "Register handler for new alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "handler",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 148
            },
            {
              "name": "register_escalation_handler",
              "module": "compliance_control",
              "signature": "def register_escalation_handler(self, handler: Callable[, None]) -> None",
              "docstring": "Register handler for escalations.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "handler",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 152
            },
            {
              "name": "raise_alert",
              "module": "compliance_control",
              "signature": "def raise_alert(self, category: AlertCategory, severity: AlertSeverity, title: str, message: str, source: str, affected_entities: , requires_acknowledgment: ) -> ControlRoomAlert",
              "docstring": "Raise a new alert (#C35).\n\nArgs:\n    category: Alert category\n    severity: Alert severity\n    title: Short title\n    message: Detailed message\n    source: Source system/component\n    affected_entities: List of affected symbols/systems\n    requires_acknowledgment: Override default acknowledgment requirement\n\nReturns:\n    Created alert",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "category",
                  "type": "AlertCategory"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                },
                {
                  "name": "title",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "source",
                  "type": "str"
                },
                {
                  "name": "affected_entities",
                  "type": ""
                },
                {
                  "name": "requires_acknowledgment",
                  "type": ""
                }
              ],
              "return_type": "ControlRoomAlert",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 156
            },
            {
              "name": "_handle_emergency",
              "module": "compliance_control",
              "signature": "def _handle_emergency(self, alert: ControlRoomAlert) -> None",
              "docstring": "Handle emergency alert - may halt trading.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "ControlRoomAlert"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 216
            },
            {
              "name": "acknowledge_alert",
              "module": "compliance_control",
              "signature": "def acknowledge_alert(self, alert_id: str, acknowledged_by: str, resolution_notes: ) -> bool",
              "docstring": "Acknowledge an alert (#C35).\n\nArgs:\n    alert_id: Alert to acknowledge\n    acknowledged_by: Person/system acknowledging\n    resolution_notes: Optional notes\n\nReturns:\n    True if acknowledged successfully",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_id",
                  "type": "str"
                },
                {
                  "name": "acknowledged_by",
                  "type": "str"
                },
                {
                  "name": "resolution_notes",
                  "type": ""
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 223
            },
            {
              "name": "escalate_alert",
              "module": "compliance_control",
              "signature": "def escalate_alert(self, alert_id: str) -> int",
              "docstring": "Escalate an alert to next level (#C35).\n\nReturns new escalation level.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_id",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 252
            },
            {
              "name": "check_escalations",
              "module": "compliance_control",
              "signature": "def check_escalations(self) -> list[ControlRoomAlert]",
              "docstring": "Check for alerts needing escalation.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[ControlRoomAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 275
            },
            {
              "name": "halt_trading",
              "module": "compliance_control",
              "signature": "def halt_trading(self, reason: str) -> None",
              "docstring": "Halt all trading (#C35).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 298
            },
            {
              "name": "resume_trading",
              "module": "compliance_control",
              "signature": "def resume_trading(self, authorized_by: str, notes: str) -> None",
              "docstring": "Resume trading (#C35).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "authorized_by",
                  "type": "str"
                },
                {
                  "name": "notes",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 314
            },
            {
              "name": "is_trading_enabled",
              "module": "compliance_control",
              "signature": "def is_trading_enabled(self) -> bool",
              "docstring": "Check if trading is enabled.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 330
            },
            {
              "name": "get_state",
              "module": "compliance_control",
              "signature": "def get_state(self) -> ControlRoomState",
              "docstring": "Get current control room state (#C35).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "ControlRoomState",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 334
            },
            {
              "name": "get_alerts",
              "module": "compliance_control",
              "signature": "def get_alerts(self, category: , severity: , unacknowledged_only: bool, limit: int) -> list[ControlRoomAlert]",
              "docstring": "Get filtered alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "category",
                  "type": ""
                },
                {
                  "name": "severity",
                  "type": ""
                },
                {
                  "name": "unacknowledged_only",
                  "type": "bool"
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[ControlRoomAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 365
            },
            {
              "name": "get_dashboard",
              "module": "compliance_control",
              "signature": "def get_dashboard(self) -> dict",
              "docstring": "Get control room dashboard data (#C35).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 386
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 114
        },
        {
          "name": "InformationZone",
          "module": "compliance_control",
          "docstring": "Information zones for Chinese wall separation (#C36).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 412
        },
        {
          "name": "WallCrossingRequest",
          "module": "compliance_control",
          "docstring": "Request to cross Chinese wall (#C36).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "compliance_control",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 437
            }
          ],
          "class_attributes": [
            {
              "name": "request_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "requester",
              "type": "str"
            },
            {
              "name": "requester_zone",
              "type": "InformationZone"
            },
            {
              "name": "target_zone",
              "type": "InformationZone"
            },
            {
              "name": "reason",
              "type": "str"
            },
            {
              "name": "symbols_involved",
              "type": "list[str]"
            },
            {
              "name": "approved",
              "type": ""
            },
            {
              "name": "approved_by",
              "type": ""
            },
            {
              "name": "approved_at",
              "type": ""
            },
            {
              "name": "expiry",
              "type": ""
            },
            {
              "name": "conditions",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 422
        },
        {
          "name": "AccessAttempt",
          "module": "compliance_control",
          "docstring": "Record of access attempt across zones (#C36).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "user",
              "type": "str"
            },
            {
              "name": "user_zone",
              "type": "InformationZone"
            },
            {
              "name": "target_zone",
              "type": "InformationZone"
            },
            {
              "name": "resource",
              "type": "str"
            },
            {
              "name": "allowed",
              "type": "bool"
            },
            {
              "name": "reason",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 455
        },
        {
          "name": "ChineseWallManager",
          "module": "compliance_control",
          "docstring": "Chinese wall enforcement (#C36).\n\nImplements information barriers between:\n- Public side (research, sales)\n- Private side (deal teams with MNPI)\n- Trading desk\n\nFeatures:\n- Zone-based access control\n- Wall crossing requests and approvals\n- Restricted list management\n- Access audit trail",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "compliance_control",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 494
            },
            {
              "name": "assign_zone",
              "module": "compliance_control",
              "signature": "def assign_zone(self, user: str, zone: InformationZone) -> None",
              "docstring": "Assign user to information zone (#C36).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "user",
                  "type": "str"
                },
                {
                  "name": "zone",
                  "type": "InformationZone"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 510
            },
            {
              "name": "get_user_zone",
              "module": "compliance_control",
              "signature": "def get_user_zone(self, user: str) -> InformationZone",
              "docstring": "Get user's assigned zone.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "user",
                  "type": "str"
                }
              ],
              "return_type": "InformationZone",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 515
            },
            {
              "name": "add_to_restricted_list",
              "module": "compliance_control",
              "signature": "def add_to_restricted_list(self, symbol: str, reason: str, added_by: str, expiry: ) -> None",
              "docstring": "Add symbol to restricted list (#C36).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "reason",
                  "type": "str"
                },
                {
                  "name": "added_by",
                  "type": "str"
                },
                {
                  "name": "expiry",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 519
            },
            {
              "name": "remove_from_restricted_list",
              "module": "compliance_control",
              "signature": "def remove_from_restricted_list(self, symbol: str, removed_by: str) -> None",
              "docstring": "Remove symbol from restricted list.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "removed_by",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 536
            },
            {
              "name": "is_restricted",
              "module": "compliance_control",
              "signature": "def is_restricted(self, symbol: str) -> bool",
              "docstring": "Check if symbol is on restricted list.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 542
            },
            {
              "name": "check_access",
              "module": "compliance_control",
              "signature": "def check_access(self, user: str, target_zone: InformationZone, resource: str) -> tuple[bool, str]",
              "docstring": "Check if user can access resource in target zone (#C36).\n\nArgs:\n    user: User requesting access\n    target_zone: Zone of the resource\n    resource: Resource being accessed\n\nReturns:\n    (allowed, reason)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "user",
                  "type": "str"
                },
                {
                  "name": "target_zone",
                  "type": "InformationZone"
                },
                {
                  "name": "resource",
                  "type": "str"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 555
            },
            {
              "name": "request_wall_crossing",
              "module": "compliance_control",
              "signature": "def request_wall_crossing(self, requester: str, target_zone: InformationZone, reason: str, symbols_involved: ) -> WallCrossingRequest",
              "docstring": "Request wall crossing approval (#C36).\n\nArgs:\n    requester: User requesting crossing\n    target_zone: Zone to access\n    reason: Business justification\n    symbols_involved: Symbols that may be discussed\n\nReturns:\n    Wall crossing request",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "requester",
                  "type": "str"
                },
                {
                  "name": "target_zone",
                  "type": "InformationZone"
                },
                {
                  "name": "reason",
                  "type": "str"
                },
                {
                  "name": "symbols_involved",
                  "type": ""
                }
              ],
              "return_type": "WallCrossingRequest",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 605
            },
            {
              "name": "approve_wall_crossing",
              "module": "compliance_control",
              "signature": "def approve_wall_crossing(self, request: WallCrossingRequest, approver: str, duration_hours: int, conditions: ) -> WallCrossingRequest",
              "docstring": "Approve wall crossing request (#C36).\n\nOnly compliance can approve.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "request",
                  "type": "WallCrossingRequest"
                },
                {
                  "name": "approver",
                  "type": "str"
                },
                {
                  "name": "duration_hours",
                  "type": "int"
                },
                {
                  "name": "conditions",
                  "type": ""
                }
              ],
              "return_type": "WallCrossingRequest",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 640
            },
            {
              "name": "deny_wall_crossing",
              "module": "compliance_control",
              "signature": "def deny_wall_crossing(self, request: WallCrossingRequest, approver: str, reason: str) -> WallCrossingRequest",
              "docstring": "Deny wall crossing request (#C36).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "request",
                  "type": "WallCrossingRequest"
                },
                {
                  "name": "approver",
                  "type": "str"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "WallCrossingRequest",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 669
            },
            {
              "name": "get_restricted_list",
              "module": "compliance_control",
              "signature": "def get_restricted_list(self) -> list[dict]",
              "docstring": "Get current restricted list.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 684
            },
            {
              "name": "get_access_audit",
              "module": "compliance_control",
              "signature": "def get_access_audit(self, user: , denied_only: bool, limit: int) -> list[dict]",
              "docstring": "Get access audit log.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "user",
                  "type": ""
                },
                {
                  "name": "denied_only",
                  "type": "bool"
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 695
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 466
        },
        {
          "name": "ResearchType",
          "module": "compliance_control",
          "docstring": "Types of research for distribution control (#C37).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 727
        },
        {
          "name": "DistributionRestriction",
          "module": "compliance_control",
          "docstring": "Distribution restriction levels (#C37).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 736
        },
        {
          "name": "ResearchDocument",
          "module": "compliance_control",
          "docstring": "Research document with distribution controls (#C37).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "compliance_control",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 760
            }
          ],
          "class_attributes": [
            {
              "name": "document_id",
              "type": "str"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "research_type",
              "type": "ResearchType"
            },
            {
              "name": "restriction",
              "type": "DistributionRestriction"
            },
            {
              "name": "author",
              "type": "str"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "symbols_covered",
              "type": "list[str]"
            },
            {
              "name": "rating_changes",
              "type": "list[dict]"
            },
            {
              "name": "price_targets",
              "type": "list[dict]"
            },
            {
              "name": "allowed_recipients",
              "type": ""
            },
            {
              "name": "embargo_until",
              "type": ""
            },
            {
              "name": "distribution_log",
              "type": "list[dict]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 745
        },
        {
          "name": "ResearchDistributionControl",
          "module": "compliance_control",
          "docstring": "Research distribution controls (#C37).\n\nFeatures:\n- Embargo management\n- Distribution restrictions\n- Fair disclosure compliance\n- Distribution audit trail",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "compliance_control",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 787
            },
            {
              "name": "register_document",
              "module": "compliance_control",
              "signature": "def register_document(self, title: str, research_type: ResearchType, restriction: DistributionRestriction, author: str, symbols_covered: list[str], rating_changes: , price_targets: , allowed_recipients: , embargo_hours: int) -> ResearchDocument",
              "docstring": "Register new research document (#C37).\n\nReturns document with distribution controls set.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "title",
                  "type": "str"
                },
                {
                  "name": "research_type",
                  "type": "ResearchType"
                },
                {
                  "name": "restriction",
                  "type": "DistributionRestriction"
                },
                {
                  "name": "author",
                  "type": "str"
                },
                {
                  "name": "symbols_covered",
                  "type": "list[str]"
                },
                {
                  "name": "rating_changes",
                  "type": ""
                },
                {
                  "name": "price_targets",
                  "type": ""
                },
                {
                  "name": "allowed_recipients",
                  "type": ""
                },
                {
                  "name": "embargo_hours",
                  "type": "int"
                }
              ],
              "return_type": "ResearchDocument",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 794
            },
            {
              "name": "can_distribute",
              "module": "compliance_control",
              "signature": "def can_distribute(self, document_id: str, recipient: str, is_client: bool, is_internal: bool) -> tuple[bool, str]",
              "docstring": "Check if document can be distributed to recipient (#C37).\n\nArgs:\n    document_id: Document to distribute\n    recipient: Intended recipient\n    is_client: Whether recipient is a client\n    is_internal: Whether recipient is internal\n\nReturns:\n    (can_distribute, reason)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "document_id",
                  "type": "str"
                },
                {
                  "name": "recipient",
                  "type": "str"
                },
                {
                  "name": "is_client",
                  "type": "bool"
                },
                {
                  "name": "is_internal",
                  "type": "bool"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 837
            },
            {
              "name": "record_distribution",
              "module": "compliance_control",
              "signature": "def record_distribution(self, document_id: str, recipient: str, channel: str) -> bool",
              "docstring": "Record document distribution (#C37).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "document_id",
                  "type": "str"
                },
                {
                  "name": "recipient",
                  "type": "str"
                },
                {
                  "name": "channel",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 877
            },
            {
              "name": "record_pre_release_access",
              "module": "compliance_control",
              "signature": "def record_pre_release_access(self, document_id: str, user: str, reason: str) -> None",
              "docstring": "Record pre-release access for fair disclosure tracking (#C37).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "document_id",
                  "type": "str"
                },
                {
                  "name": "user",
                  "type": "str"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 897
            },
            {
              "name": "get_distribution_report",
              "module": "compliance_control",
              "signature": "def get_distribution_report(self, document_id: str) -> dict",
              "docstring": "Get distribution report for document (#C37).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "document_id",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 915
            },
            {
              "name": "get_documents_by_symbol",
              "module": "compliance_control",
              "signature": "def get_documents_by_symbol(self, symbol: str) -> list[ResearchDocument]",
              "docstring": "Get all research documents covering a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "list[ResearchDocument]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 928
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 776
        },
        {
          "name": "ConflictType",
          "module": "compliance_control",
          "docstring": "Types of conflicts of interest (#C38).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 940
        },
        {
          "name": "ConflictStatus",
          "module": "compliance_control",
          "docstring": "Conflict status (#C38).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 952
        },
        {
          "name": "ConflictOfInterest",
          "module": "compliance_control",
          "docstring": "Conflict of interest record (#C38).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "compliance_control",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 977
            }
          ],
          "class_attributes": [
            {
              "name": "conflict_id",
              "type": "str"
            },
            {
              "name": "conflict_type",
              "type": "ConflictType"
            },
            {
              "name": "status",
              "type": "ConflictStatus"
            },
            {
              "name": "person",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "symbols_affected",
              "type": "list[str]"
            },
            {
              "name": "reported_at",
              "type": "datetime"
            },
            {
              "name": "reported_by",
              "type": "str"
            },
            {
              "name": "reviewed_by",
              "type": ""
            },
            {
              "name": "reviewed_at",
              "type": ""
            },
            {
              "name": "mitigation_measures",
              "type": "list[str]"
            },
            {
              "name": "expiry",
              "type": ""
            },
            {
              "name": "notes",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 961
        },
        {
          "name": "ConflictOfInterestTracker",
          "module": "compliance_control",
          "docstring": "Conflict of interest tracking system (#C38).\n\nFeatures:\n- Conflict registration and tracking\n- Mitigation measure management\n- Trading restriction enforcement\n- Periodic attestation tracking\n- Reporting and audit",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "compliance_control",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1007
            },
            {
              "name": "register_conflict",
              "module": "compliance_control",
              "signature": "def register_conflict(self, conflict_type: ConflictType, person: str, description: str, symbols_affected: list[str], reported_by: str, expiry: ) -> ConflictOfInterest",
              "docstring": "Register new conflict of interest (#C38).\n\nArgs:\n    conflict_type: Type of conflict\n    person: Person with conflict\n    description: Conflict description\n    symbols_affected: Affected symbols\n    reported_by: Person reporting\n    expiry: When conflict expires\n\nReturns:\n    Registered conflict",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "conflict_type",
                  "type": "ConflictType"
                },
                {
                  "name": "person",
                  "type": "str"
                },
                {
                  "name": "description",
                  "type": "str"
                },
                {
                  "name": "symbols_affected",
                  "type": "list[str]"
                },
                {
                  "name": "reported_by",
                  "type": "str"
                },
                {
                  "name": "expiry",
                  "type": ""
                }
              ],
              "return_type": "ConflictOfInterest",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1017
            },
            {
              "name": "review_conflict",
              "module": "compliance_control",
              "signature": "def review_conflict(self, conflict_id: str, reviewer: str, mitigation_measures: list[str], new_status: ConflictStatus, notes: str)",
              "docstring": "Review and manage conflict (#C38).\n\nArgs:\n    conflict_id: Conflict to review\n    reviewer: Compliance reviewer\n    mitigation_measures: Measures to manage conflict\n    new_status: Updated status\n    notes: Review notes\n\nReturns:\n    Updated conflict or None",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "conflict_id",
                  "type": "str"
                },
                {
                  "name": "reviewer",
                  "type": "str"
                },
                {
                  "name": "mitigation_measures",
                  "type": "list[str]"
                },
                {
                  "name": "new_status",
                  "type": "ConflictStatus"
                },
                {
                  "name": "notes",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1060
            },
            {
              "name": "register_personal_holding",
              "module": "compliance_control",
              "signature": "def register_personal_holding(self, person: str, symbol: str, shares: int, acquisition_date: datetime, acquisition_method: str) -> None",
              "docstring": "Register personal holding for conflict tracking (#C38).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "person",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "shares",
                  "type": "int"
                },
                {
                  "name": "acquisition_date",
                  "type": "datetime"
                },
                {
                  "name": "acquisition_method",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1094
            },
            {
              "name": "check_can_trade",
              "module": "compliance_control",
              "signature": "def check_can_trade(self, person: str, symbol: str) -> tuple[bool, str, list[str]]",
              "docstring": "Check if person can trade a symbol (#C38).\n\nArgs:\n    person: Person wanting to trade\n    symbol: Symbol to trade\n\nReturns:\n    (can_trade, reason, required_disclosures)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "person",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "tuple[bool, str, list[str]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1123
            },
            {
              "name": "get_conflicts_for_person",
              "module": "compliance_control",
              "signature": "def get_conflicts_for_person(self, person: str) -> list[ConflictOfInterest]",
              "docstring": "Get all conflicts for a person.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "person",
                  "type": "str"
                }
              ],
              "return_type": "list[ConflictOfInterest]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1154
            },
            {
              "name": "get_conflicts_for_symbol",
              "module": "compliance_control",
              "signature": "def get_conflicts_for_symbol(self, symbol: str) -> list[ConflictOfInterest]",
              "docstring": "Get all conflicts affecting a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "list[ConflictOfInterest]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1158
            },
            {
              "name": "record_attestation",
              "module": "compliance_control",
              "signature": "def record_attestation(self, person: str, attestation_type: str, content: str) -> dict",
              "docstring": "Record compliance attestation (#C38).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "person",
                  "type": "str"
                },
                {
                  "name": "attestation_type",
                  "type": "str"
                },
                {
                  "name": "content",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1162
            },
            {
              "name": "get_conflicts_report",
              "module": "compliance_control",
              "signature": "def get_conflicts_report(self) -> dict",
              "docstring": "Generate conflicts report (#C38).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1184
            },
            {
              "name": "check_expired_conflicts",
              "module": "compliance_control",
              "signature": "def check_expired_conflicts(self) -> list[ConflictOfInterest]",
              "docstring": "Check and update expired conflicts.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[ConflictOfInterest]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1209
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 995
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "hashlib",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__",
        "hashlib"
      ]
    },
    "core.config_validator": {
      "name": "config_validator",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\config_validator.py",
      "docstring": "Configuration Validation Module\n===============================\n\nComprehensive configuration validation at startup (Issue #S8).\n\nFeatures:\n- Schema-based validation\n- Type checking\n- Range validation\n- Cross-field validation\n- Environment-specific validation\n- Clear error messages",
      "classes": [
        {
          "name": "ValidationSeverity",
          "module": "config_validator",
          "docstring": "Validation issue severity.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 30
        },
        {
          "name": "ValidationIssue",
          "module": "config_validator",
          "docstring": "Single validation issue.",
          "bases": [],
          "methods": [
            {
              "name": "__str__",
              "module": "config_validator",
              "signature": "def __str__(self) -> str",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 45
            }
          ],
          "class_attributes": [
            {
              "name": "severity",
              "type": "ValidationSeverity"
            },
            {
              "name": "path",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "suggestion",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 38
        },
        {
          "name": "ValidationResult",
          "module": "config_validator",
          "docstring": "Complete validation result.",
          "bases": [],
          "methods": [
            {
              "name": "add_error",
              "module": "config_validator",
              "signature": "def add_error(self, path: str, message: str, suggestion: ) -> None",
              "docstring": "Add error issue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "path",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "suggestion",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 60
            },
            {
              "name": "add_warning",
              "module": "config_validator",
              "signature": "def add_warning(self, path: str, message: str, suggestion: ) -> None",
              "docstring": "Add warning issue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "path",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "suggestion",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 70
            },
            {
              "name": "add_info",
              "module": "config_validator",
              "signature": "def add_info(self, path: str, message: str) -> None",
              "docstring": "Add info issue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "path",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 79
            },
            {
              "name": "get_errors",
              "module": "config_validator",
              "signature": "def get_errors(self) -> list[ValidationIssue]",
              "docstring": "Get only error-level issues.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[ValidationIssue]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "get_warnings",
              "module": "config_validator",
              "signature": "def get_warnings(self) -> list[ValidationIssue]",
              "docstring": "Get only warning-level issues.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[ValidationIssue]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 91
            },
            {
              "name": "summary",
              "module": "config_validator",
              "signature": "def summary(self) -> str",
              "docstring": "Get validation summary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 95
            },
            {
              "name": "format_errors_for_display",
              "module": "config_validator",
              "signature": "def format_errors_for_display(self, include_warnings: bool) -> str",
              "docstring": "Format validation issues for user-friendly display.\n\nReturns a numbered list of issues with clear formatting and suggestions.\n\nArgs:\n    include_warnings: Include warning-level issues (default True)\n\nReturns:\n    Formatted string ready for console/log output",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "include_warnings",
                  "type": "bool"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 102
            }
          ],
          "class_attributes": [
            {
              "name": "valid",
              "type": "bool"
            },
            {
              "name": "issues",
              "type": "list[ValidationIssue]"
            },
            {
              "name": "checked_at",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 54
        },
        {
          "name": "FieldSchema",
          "module": "config_validator",
          "docstring": "Schema for a single config field.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "path",
              "type": "str"
            },
            {
              "name": "field_type",
              "type": ""
            },
            {
              "name": "required",
              "type": "bool"
            },
            {
              "name": "default",
              "type": "Any"
            },
            {
              "name": "min_value",
              "type": ""
            },
            {
              "name": "max_value",
              "type": ""
            },
            {
              "name": "allowed_values",
              "type": ""
            },
            {
              "name": "pattern",
              "type": ""
            },
            {
              "name": "validator",
              "type": ""
            },
            {
              "name": "description",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 179
        },
        {
          "name": "ConfigValidator",
          "module": "config_validator",
          "docstring": "Configuration validator with schema support.\n\nValidates config at startup to catch issues early.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "config_validator",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            },
            {
              "name": "_register_default_schemas",
              "module": "config_validator",
              "signature": "def _register_default_schemas(self) -> None",
              "docstring": "Register default configuration schemas.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 207
            },
            {
              "name": "add_schema",
              "module": "config_validator",
              "signature": "def add_schema(self, schema: FieldSchema) -> None",
              "docstring": "Add field schema.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "schema",
                  "type": "FieldSchema"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 343
            },
            {
              "name": "add_cross_validator",
              "module": "config_validator",
              "signature": "def add_cross_validator(self, validator: Callable[, None]) -> None",
              "docstring": "Add cross-field validator.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "validator",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 347
            },
            {
              "name": "validate",
              "module": "config_validator",
              "signature": "def validate(self, config: dict) -> ValidationResult",
              "docstring": "Validate configuration against schemas.\n\nArgs:\n    config: Configuration dictionary\n\nReturns:\n    ValidationResult with all issues found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict"
                }
              ],
              "return_type": "ValidationResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 354
            },
            {
              "name": "_validate_field",
              "module": "config_validator",
              "signature": "def _validate_field(self, config: dict, schema: FieldSchema, result: ValidationResult) -> None",
              "docstring": "Validate single field against schema.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict"
                },
                {
                  "name": "schema",
                  "type": "FieldSchema"
                },
                {
                  "name": "result",
                  "type": "ValidationResult"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 386
            },
            {
              "name": "_get_nested_value",
              "module": "config_validator",
              "signature": "def _get_nested_value(self, config: dict, path: str) -> Any",
              "docstring": "Get value from nested dict using dot notation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict"
                },
                {
                  "name": "path",
                  "type": "str"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 458
            },
            {
              "name": "_validate_lei",
              "module": "config_validator",
              "signature": "def _validate_lei(self, lei: str) -> bool",
              "docstring": "Validate LEI format and checksum.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lei",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 472
            },
            {
              "name": "_validate_risk_consistency",
              "module": "config_validator",
              "signature": "def _validate_risk_consistency(self, config: dict, result: ValidationResult) -> None",
              "docstring": "Cross-validate risk settings.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict"
                },
                {
                  "name": "result",
                  "type": "ValidationResult"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 487
            },
            {
              "name": "_validate_environment_settings",
              "module": "config_validator",
              "signature": "def _validate_environment_settings(self, config: dict, result: ValidationResult) -> None",
              "docstring": "Validate environment-specific settings.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict"
                },
                {
                  "name": "result",
                  "type": "ValidationResult"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 513
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 193
        },
        {
          "name": "ConfigMigrator",
          "module": "config_validator",
          "docstring": "Handles configuration migrations between versions.\n\nHelps upgrade old configs to new format.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "config_validator",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 555
            },
            {
              "name": "add_migration",
              "module": "config_validator",
              "signature": "def add_migration(self, from_version: str, to_version: str, migrator: Callable[, dict]) -> None",
              "docstring": "Add migration function.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "from_version",
                  "type": "str"
                },
                {
                  "name": "to_version",
                  "type": "str"
                },
                {
                  "name": "migrator",
                  "type": "Callable[, dict]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 558
            },
            {
              "name": "migrate",
              "module": "config_validator",
              "signature": "def migrate(self, config: dict, target_version: str) -> dict",
              "docstring": "Migrate config to target version.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict"
                },
                {
                  "name": "target_version",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 567
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 548
        }
      ],
      "functions": [
        {
          "name": "validate_config_at_startup",
          "module": "config_validator",
          "signature": "def validate_config_at_startup(config: dict) -> bool",
          "docstring": "Convenience function to validate config at startup.\n\nReturns True if valid, raises on critical errors.",
          "parameters": [
            {
              "name": "config",
              "type": "dict"
            }
          ],
          "return_type": "bool",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 590
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "os",
        "re",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.contract_specs": {
      "name": "contract_specs",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\contract_specs.py",
      "docstring": "Contract Specifications\n=======================\n\nFutures contract specifications for proper position sizing, margin calculation,\nand P&L computation. This module provides institutional-grade contract data.\n\nBased on CME/CBOT/NYMEX/COMEX specifications.",
      "classes": [
        {
          "name": "AssetClass",
          "module": "contract_specs",
          "docstring": "Asset class categorization for futures.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 24
        },
        {
          "name": "Exchange",
          "module": "contract_specs",
          "docstring": "Exchange identifiers.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 35
        },
        {
          "name": "ContractSpec",
          "module": "contract_specs",
          "docstring": "Futures contract specification.\n\nAll values are per standard contract unless otherwise noted.",
          "bases": [],
          "methods": [
            {
              "name": "point_value",
              "module": "contract_specs",
              "signature": "def point_value(self) -> float",
              "docstring": "Dollar value of one point move.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 83
            },
            {
              "name": "calculate_tick_value",
              "module": "contract_specs",
              "signature": "def calculate_tick_value(self) -> float",
              "docstring": "Calculate tick value from multiplier and tick size.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "notional_value",
              "module": "contract_specs",
              "signature": "def notional_value(self, price: float, contracts: int) -> float",
              "docstring": "Calculate notional value of position.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "contracts",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 91
            },
            {
              "name": "margin_required",
              "module": "contract_specs",
              "signature": "def margin_required(self, contracts: int, is_initial: bool) -> float",
              "docstring": "Calculate margin required for position.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contracts",
                  "type": "int"
                },
                {
                  "name": "is_initial",
                  "type": "bool"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 95
            },
            {
              "name": "pnl_per_tick",
              "module": "contract_specs",
              "signature": "def pnl_per_tick(self, contracts: int) -> float",
              "docstring": "Calculate P&L per tick for given number of contracts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contracts",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 100
            },
            {
              "name": "price_to_ticks",
              "module": "contract_specs",
              "signature": "def price_to_ticks(self, price_change: float) -> int",
              "docstring": "Convert price change to number of ticks.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "price_change",
                  "type": "float"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 104
            },
            {
              "name": "ticks_to_price",
              "module": "contract_specs",
              "signature": "def ticks_to_price(self, ticks: int) -> float",
              "docstring": "Convert number of ticks to price change.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "ticks",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 108
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "asset_class",
              "type": "AssetClass"
            },
            {
              "name": "exchange",
              "type": "Exchange"
            },
            {
              "name": "currency",
              "type": "str"
            },
            {
              "name": "multiplier",
              "type": "float"
            },
            {
              "name": "tick_size",
              "type": "float"
            },
            {
              "name": "tick_value",
              "type": "float"
            },
            {
              "name": "initial_margin",
              "type": "float"
            },
            {
              "name": "maintenance_margin",
              "type": "float"
            },
            {
              "name": "trading_hours",
              "type": "str"
            },
            {
              "name": "contract_months",
              "type": "tuple[str, Ellipsis]"
            },
            {
              "name": "last_trading_day",
              "type": "str"
            },
            {
              "name": "settlement_type",
              "type": "str"
            },
            {
              "name": "position_limit",
              "type": ""
            },
            {
              "name": "avg_daily_volume",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 46
        },
        {
          "name": "CurrencyConverter",
          "module": "contract_specs",
          "docstring": "Currency conversion for P&L calculation.\n\nHandles conversion of P&L from non-USD quote currencies to USD\nfor proper portfolio aggregation.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "contract_specs",
              "signature": "def __init__(self)",
              "docstring": "Initialize with default exchange rates (should be updated with live rates).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 968
            },
            {
              "name": "update_rate",
              "module": "contract_specs",
              "signature": "def update_rate(self, currency: str, rate_to_usd: float) -> None",
              "docstring": "Update exchange rate for a currency.\n\nArgs:\n    currency: Currency code (e.g., \"EUR\", \"JPY\")\n    rate_to_usd: How many USD per 1 unit of currency",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "currency",
                  "type": "str"
                },
                {
                  "name": "rate_to_usd",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 984
            },
            {
              "name": "update_rates_from_market_data",
              "module": "contract_specs",
              "signature": "def update_rates_from_market_data(self, fx_prices: dict[str, float]) -> None",
              "docstring": "Update rates from FX market data.\n\nArgs:\n    fx_prices: Dictionary of pair -> price (e.g., {\"EURUSD\": 1.08, \"USDJPY\": 150.0})",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fx_prices",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 995
            },
            {
              "name": "get_rate",
              "module": "contract_specs",
              "signature": "def get_rate(self, currency: str) -> float",
              "docstring": "Get exchange rate (USD per 1 unit of currency).\n\nArgs:\n    currency: Currency code\n\nReturns:\n    Exchange rate to USD, or 1.0 if unknown",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "currency",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1017
            },
            {
              "name": "convert_to_usd",
              "module": "contract_specs",
              "signature": "def convert_to_usd(self, amount: float, from_currency: str) -> float",
              "docstring": "Convert amount from foreign currency to USD.\n\nArgs:\n    amount: Amount in foreign currency\n    from_currency: Source currency code\n\nReturns:\n    Equivalent amount in USD",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "amount",
                  "type": "float"
                },
                {
                  "name": "from_currency",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1029
            },
            {
              "name": "convert_pnl_to_usd",
              "module": "contract_specs",
              "signature": "def convert_pnl_to_usd(self, pnl: float, quote_currency: str, symbol: ) -> float",
              "docstring": "Convert P&L from quote currency to USD.\n\nSpecial handling for JPY pairs where tick values are in JPY.\n\nArgs:\n    pnl: P&L in quote currency\n    quote_currency: Quote currency of the pair\n    symbol: Optional symbol for logging\n\nReturns:\n    P&L in USD",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pnl",
                  "type": "float"
                },
                {
                  "name": "quote_currency",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1043
            },
            {
              "name": "calculate_fx_position_value_usd",
              "module": "contract_specs",
              "signature": "def calculate_fx_position_value_usd(self, base_currency: str, quote_currency: str, base_amount: float, price: float) -> float",
              "docstring": "Calculate USD value of an FX position.\n\nArgs:\n    base_currency: Base currency (e.g., \"EUR\" in EUR/USD)\n    quote_currency: Quote currency (e.g., \"USD\" in EUR/USD)\n    base_amount: Amount of base currency\n    price: Current price (quote per base)\n\nReturns:\n    Position value in USD",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "base_currency",
                  "type": "str"
                },
                {
                  "name": "quote_currency",
                  "type": "str"
                },
                {
                  "name": "base_amount",
                  "type": "float"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1075
            },
            {
              "name": "get_tick_value_usd",
              "module": "contract_specs",
              "signature": "def get_tick_value_usd(self, spec: ContractSpec) -> float",
              "docstring": "Get tick value in USD for a contract.\n\nArgs:\n    spec: Contract specification\n\nReturns:\n    Tick value in USD",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spec",
                  "type": "ContractSpec"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1103
            },
            {
              "name": "get_fx_pip_value_usd",
              "module": "contract_specs",
              "signature": "def get_fx_pip_value_usd(self, pair: str, lot_size: int, current_price: ) -> float",
              "docstring": "Calculate FX pip value in USD (#X2).\n\nProperly handles JPY pairs where pip = 0.01 (vs 0.0001 for other pairs)\nand converts native pip value to USD.\n\nArgs:\n    pair: FX pair (e.g., \"USDJPY\", \"EURUSD\")\n    lot_size: Position size in base currency units (default: 100,000 = 1 standard lot)\n    current_price: Current price (required for XXX/USD pairs, optional for USD/XXX)\n\nReturns:\n    Value of 1 pip move in USD\n\nExamples:\n    USDJPY @ 150.00:\n        - 1 pip = 0.01 (JPY pairs)\n        - Pip value = 100,000 * 0.01 = 1,000 JPY\n        - In USD = 1,000 / 150 = $6.67\n\n    EURUSD @ 1.0800:\n        - 1 pip = 0.0001 (standard pairs)\n        - Pip value = 100,000 * 0.0001 = 10 USD\n        - In USD = $10.00 (already in USD)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "lot_size",
                  "type": "int"
                },
                {
                  "name": "current_price",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1118
            },
            {
              "name": "get_fx_tick_value_usd",
              "module": "contract_specs",
              "signature": "def get_fx_tick_value_usd(self, pair: str, lot_size: int, current_price: ) -> float",
              "docstring": "Calculate FX tick value in USD (half pip for JPY pairs).\n\nMost FX brokers quote JPY pairs in 0.5 pip increments (0.005),\nso tick value = pip value / 2 for JPY pairs.\n\nArgs:\n    pair: FX pair\n    lot_size: Position size\n    current_price: Current price for accurate conversion\n\nReturns:\n    Tick value in USD",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "lot_size",
                  "type": "int"
                },
                {
                  "name": "current_price",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1194
            },
            {
              "name": "get_status",
              "module": "contract_specs",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get converter status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1226
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 960
        },
        {
          "name": "FXSwapRate",
          "module": "contract_specs",
          "docstring": "FX swap/rollover rate for overnight positions.",
          "bases": [],
          "methods": [
            {
              "name": "get_rollover_cost",
              "module": "contract_specs",
              "signature": "def get_rollover_cost(self, position_size: float, is_long: bool) -> float",
              "docstring": "Calculate rollover cost/credit for a position.\n\nArgs:\n    position_size: Position size in lots\n    is_long: True if long position, False if short\n\nReturns:\n    Rollover amount (positive = credit, negative = cost)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position_size",
                  "type": "float"
                },
                {
                  "name": "is_long",
                  "type": "bool"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1260
            }
          ],
          "class_attributes": [
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "long_rate",
              "type": "float"
            },
            {
              "name": "short_rate",
              "type": "float"
            },
            {
              "name": "last_update",
              "type": ""
            },
            {
              "name": "source",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1252
        },
        {
          "name": "FXRolloverManager",
          "module": "contract_specs",
          "docstring": "Manages FX rollover/swap rates for overnight positions.\n\nFX positions held overnight are subject to rollover (swap) rates based on\nthe interest rate differential between the two currencies. This manager\ntracks swap rates and calculates rollover costs/credits.\n\nNote: Wednesday rollovers typically include 3 days (Wed-Thu-Fri-Sat-Sun)\nto account for T+2 settlement.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "contract_specs",
              "signature": "def __init__(self)",
              "docstring": "Initialize with default swap rates.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1287
            },
            {
              "name": "update_swap_rate",
              "module": "contract_specs",
              "signature": "def update_swap_rate(self, pair: str, long_rate: float, short_rate: float, source: str) -> None",
              "docstring": "Update swap rate for a currency pair.\n\nArgs:\n    pair: Currency pair (e.g., \"EURUSD\")\n    long_rate: Rate for long positions\n    short_rate: Rate for short positions\n    source: Source of the rate data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "long_rate",
                  "type": "float"
                },
                {
                  "name": "short_rate",
                  "type": "float"
                },
                {
                  "name": "source",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1311
            },
            {
              "name": "get_swap_rate",
              "module": "contract_specs",
              "signature": "def get_swap_rate(self, pair: str)",
              "docstring": "Get swap rate for a pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1337
            },
            {
              "name": "calculate_rollover",
              "module": "contract_specs",
              "signature": "def calculate_rollover(self, pair: str, position_size: float, is_long: bool, nights: int) -> float",
              "docstring": "Calculate rollover cost/credit for a position.\n\nArgs:\n    pair: Currency pair\n    position_size: Position size in lots\n    is_long: True if long, False if short\n    nights: Number of nights (usually 1, except Wednesday = 3)\n\nReturns:\n    Rollover amount in pips/points",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "position_size",
                  "type": "float"
                },
                {
                  "name": "is_long",
                  "type": "bool"
                },
                {
                  "name": "nights",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1342
            },
            {
              "name": "calculate_rollover_usd",
              "module": "contract_specs",
              "signature": "def calculate_rollover_usd(self, pair: str, position_size_lots: float, is_long: bool, nights: int) -> float",
              "docstring": "Calculate rollover cost/credit in USD.\n\nArgs:\n    pair: Currency pair\n    position_size_lots: Position size in lots\n    is_long: True if long, False if short\n    nights: Number of nights\n\nReturns:\n    Rollover amount in USD",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "position_size_lots",
                  "type": "float"
                },
                {
                  "name": "is_long",
                  "type": "bool"
                },
                {
                  "name": "nights",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1368
            },
            {
              "name": "is_triple_swap_day",
              "module": "contract_specs",
              "signature": "def is_triple_swap_day(self) -> bool",
              "docstring": "Check if today is a triple swap day (Wednesday for T+2 settlement).\n\nReturns:\n    True if today's rollover includes 3 days",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1410
            },
            {
              "name": "get_rollover_nights",
              "module": "contract_specs",
              "signature": "def get_rollover_nights(self) -> int",
              "docstring": "Get number of nights for today's rollover.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1419
            },
            {
              "name": "record_rollover",
              "module": "contract_specs",
              "signature": "def record_rollover(self, pair: str, position_size: float, is_long: bool, rollover_amount: float, nights: int) -> None",
              "docstring": "Record a rollover event for tracking.\n\nArgs:\n    pair: Currency pair\n    position_size: Position size\n    is_long: Position direction\n    rollover_amount: Amount credited/charged\n    nights: Number of nights",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "position_size",
                  "type": "float"
                },
                {
                  "name": "is_long",
                  "type": "bool"
                },
                {
                  "name": "rollover_amount",
                  "type": "float"
                },
                {
                  "name": "nights",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1425
            },
            {
              "name": "get_total_rollovers",
              "module": "contract_specs",
              "signature": "def get_total_rollovers(self, start_date: ) -> float",
              "docstring": "Get total rollovers since start date.\n\nArgs:\n    start_date: Optional start date filter\n\nReturns:\n    Total rollover amount",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1452
            },
            {
              "name": "get_status",
              "module": "contract_specs",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get manager status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1474
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1275
        },
        {
          "name": "ContractSpecsManager",
          "module": "contract_specs",
          "docstring": "Centralized manager for contract specifications.\n\nProvides:\n- Contract spec lookup with caching\n- Validation of contract symbols\n- Margin and position value calculations\n- Asset class grouping",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "contract_specs",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize contract specs manager.\n\nArgs:\n    config: Optional configuration with margin buffer settings",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1511
            },
            {
              "name": "get_spec",
              "module": "contract_specs",
              "signature": "def get_spec(self, symbol: str)",
              "docstring": "Get contract specification by symbol.\n\nArgs:\n    symbol: Contract symbol (e.g., \"ES\", \"CL\", \"GC\")\n\nReturns:\n    ContractSpec if found, None otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "lru_cache"
              ],
              "is_async": false,
              "line_number": 1530
            },
            {
              "name": "_extract_base_symbol",
              "module": "contract_specs",
              "signature": "def _extract_base_symbol(self, symbol: str) -> str",
              "docstring": "Extract base symbol from contract notation.\n\nExamples:\n    \"ESZ4\" -> \"ES\"\n    \"CLF25\" -> \"CL\"\n    \"ES\" -> \"ES\"",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1548
            },
            {
              "name": "is_valid_symbol",
              "module": "contract_specs",
              "signature": "def is_valid_symbol(self, symbol: str) -> bool",
              "docstring": "Check if symbol is a valid futures contract.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1566
            },
            {
              "name": "get_all_symbols",
              "module": "contract_specs",
              "signature": "def get_all_symbols(self) -> list[str]",
              "docstring": "Get list of all available contract symbols.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1570
            },
            {
              "name": "get_symbols_by_asset_class",
              "module": "contract_specs",
              "signature": "def get_symbols_by_asset_class(self, asset_class: AssetClass) -> list[str]",
              "docstring": "Get all symbols for a given asset class.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "asset_class",
                  "type": "AssetClass"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1574
            },
            {
              "name": "get_symbols_by_exchange",
              "module": "contract_specs",
              "signature": "def get_symbols_by_exchange(self, exchange: Exchange) -> list[str]",
              "docstring": "Get all symbols traded on a given exchange.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exchange",
                  "type": "Exchange"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1581
            },
            {
              "name": "calculate_position_value",
              "module": "contract_specs",
              "signature": "def calculate_position_value(self, symbol: str, price: float, contracts: int)",
              "docstring": "Calculate notional value of a position.\n\nArgs:\n    symbol: Contract symbol\n    price: Current price\n    contracts: Number of contracts (positive=long, negative=short)\n\nReturns:\n    Notional value in USD, or None if symbol not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "contracts",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1588
            },
            {
              "name": "calculate_margin_requirement",
              "module": "contract_specs",
              "signature": "def calculate_margin_requirement(self, symbol: str, contracts: int, is_initial: bool)",
              "docstring": "Calculate margin requirement for a position.\n\nIncludes configured margin buffer and cross-currency conversion (#X4).\n\nArgs:\n    symbol: Contract symbol\n    contracts: Number of contracts\n    is_initial: True for initial margin, False for maintenance\n\nReturns:\n    Margin required in USD, or None if symbol not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "contracts",
                  "type": "int"
                },
                {
                  "name": "is_initial",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1612
            },
            {
              "name": "calculate_portfolio_margin",
              "module": "contract_specs",
              "signature": "def calculate_portfolio_margin(self, positions: dict[str, int], is_initial: bool, use_netting: bool) -> tuple[float, dict[str, float]]",
              "docstring": "Calculate total portfolio margin with cross-currency conversion (#X4).\n\nArgs:\n    positions: Dictionary of symbol -> quantity\n    is_initial: True for initial margin\n    use_netting: Apply cross-margin benefits for correlated positions\n\nReturns:\n    Tuple of (total_margin_usd, margin_by_symbol)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, int]"
                },
                {
                  "name": "is_initial",
                  "type": "bool"
                },
                {
                  "name": "use_netting",
                  "type": "bool"
                }
              ],
              "return_type": "tuple[float, dict[str, float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1651
            },
            {
              "name": "calculate_pnl",
              "module": "contract_specs",
              "signature": "def calculate_pnl(self, symbol: str, entry_price: float, exit_price: float, contracts: int, convert_to_usd: bool)",
              "docstring": "Calculate P&L for a trade.\n\nArgs:\n    symbol: Contract symbol\n    entry_price: Entry price\n    exit_price: Exit price\n    contracts: Number of contracts (positive=long, negative=short)\n    convert_to_usd: Whether to convert non-USD P&L to USD\n\nReturns:\n    P&L in USD (if convert_to_usd=True) or native currency, or None if symbol not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "entry_price",
                  "type": "float"
                },
                {
                  "name": "exit_price",
                  "type": "float"
                },
                {
                  "name": "contracts",
                  "type": "int"
                },
                {
                  "name": "convert_to_usd",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1690
            },
            {
              "name": "calculate_pnl_in_ticks",
              "module": "contract_specs",
              "signature": "def calculate_pnl_in_ticks(self, symbol: str, entry_price: float, exit_price: float, contracts: int, convert_to_usd: bool)",
              "docstring": "Calculate P&L for a trade with tick breakdown.\n\nArgs:\n    symbol: Contract symbol\n    entry_price: Entry price\n    exit_price: Exit price\n    contracts: Number of contracts\n    convert_to_usd: Whether to convert to USD\n\nReturns:\n    Tuple of (P&L in currency, number of ticks), or None if symbol not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "entry_price",
                  "type": "float"
                },
                {
                  "name": "exit_price",
                  "type": "float"
                },
                {
                  "name": "contracts",
                  "type": "int"
                },
                {
                  "name": "convert_to_usd",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1725
            },
            {
              "name": "get_tick_value_usd",
              "module": "contract_specs",
              "signature": "def get_tick_value_usd(self, symbol: str)",
              "docstring": "Get tick value in USD for a symbol.\n\nHandles currency conversion for non-USD quoted contracts.\n\nArgs:\n    symbol: Contract symbol\n\nReturns:\n    Tick value in USD, or None if symbol not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1761
            },
            {
              "name": "round_to_tick",
              "module": "contract_specs",
              "signature": "def round_to_tick(self, symbol: str, price: float)",
              "docstring": "Round price to nearest valid tick.\n\nArgs:\n    symbol: Contract symbol\n    price: Price to round\n\nReturns:\n    Rounded price, or None if symbol not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1783
            },
            {
              "name": "get_liquidity_tier",
              "module": "contract_specs",
              "signature": "def get_liquidity_tier(self, symbol: str) -> str",
              "docstring": "Get liquidity tier for a contract.\n\nReturns: \"high\", \"medium\", or \"low\"",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1801
            },
            {
              "name": "get_summary",
              "module": "contract_specs",
              "signature": "def get_summary(self) -> dict[str, Any]",
              "docstring": "Get summary of all contract specifications.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1820
            },
            {
              "name": "to_dataframe",
              "module": "contract_specs",
              "signature": "def to_dataframe(self)",
              "docstring": "Export all contract specs to a pandas DataFrame.\n\nReturns:\n    DataFrame with contract specifications",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1835
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1500
        },
        {
          "name": "FXProductType",
          "module": "contract_specs",
          "docstring": "Type of FX product (#X5).",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1871
        },
        {
          "name": "FXForwardRate",
          "module": "contract_specs",
          "docstring": "FX forward rate with forward points (#X5).",
          "bases": [],
          "methods": [
            {
              "name": "forward_rate",
              "module": "contract_specs",
              "signature": "def forward_rate(self) -> float",
              "docstring": "Calculate outright forward rate.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 1891
            },
            {
              "name": "annualized_forward_premium",
              "module": "contract_specs",
              "signature": "def annualized_forward_premium(self) -> float",
              "docstring": "Calculate annualized forward premium/discount.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 1897
            }
          ],
          "class_attributes": [
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "spot_rate",
              "type": "float"
            },
            {
              "name": "forward_points",
              "type": "float"
            },
            {
              "name": "settlement_date",
              "type": "datetime"
            },
            {
              "name": "tenor",
              "type": "str"
            },
            {
              "name": "bid_rate",
              "type": ""
            },
            {
              "name": "ask_rate",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1880
        },
        {
          "name": "FXProductManager",
          "module": "contract_specs",
          "docstring": "Manages FX spot vs forward distinction (#X5).\n\nHandles:\n- Spot trade identification (T+2)\n- Forward contract pricing\n- Forward points calculation\n- Tenor mapping",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "contract_specs",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1932
            },
            {
              "name": "is_spot_trade",
              "module": "contract_specs",
              "signature": "def is_spot_trade(self, settlement_days: int) -> bool",
              "docstring": "Check if trade settles as spot (#X5).\n\nArgs:\n    settlement_days: Days to settlement\n\nReturns:\n    True if spot (T+2 or less)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "settlement_days",
                  "type": "int"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1936
            },
            {
              "name": "get_product_type",
              "module": "contract_specs",
              "signature": "def get_product_type(self, settlement_days: int) -> FXProductType",
              "docstring": "Determine FX product type based on settlement (#X5).\n\nArgs:\n    settlement_days: Days to settlement\n\nReturns:\n    FX product type",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "settlement_days",
                  "type": "int"
                }
              ],
              "return_type": "FXProductType",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1948
            },
            {
              "name": "update_spot_rate",
              "module": "contract_specs",
              "signature": "def update_spot_rate(self, pair: str, rate: float) -> None",
              "docstring": "Update spot rate for a currency pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "rate",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1963
            },
            {
              "name": "calculate_forward_rate",
              "module": "contract_specs",
              "signature": "def calculate_forward_rate(self, pair: str, spot_rate: float, base_rate: float, quote_rate: float, days: int) -> FXForwardRate",
              "docstring": "Calculate forward rate from interest rate differential (#X5).\n\nForward rate = Spot * (1 + r_quote * t) / (1 + r_base * t)\n\nArgs:\n    pair: Currency pair (e.g., \"EURUSD\")\n    spot_rate: Current spot rate\n    base_rate: Base currency interest rate (annualized)\n    quote_rate: Quote currency interest rate (annualized)\n    days: Days to settlement\n\nReturns:\n    Forward rate calculation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "spot_rate",
                  "type": "float"
                },
                {
                  "name": "base_rate",
                  "type": "float"
                },
                {
                  "name": "quote_rate",
                  "type": "float"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "FXForwardRate",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1967
            },
            {
              "name": "_days_to_tenor",
              "module": "contract_specs",
              "signature": "def _days_to_tenor(self, days: int) -> str",
              "docstring": "Convert days to standard tenor string.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2012
            },
            {
              "name": "get_forward_curve",
              "module": "contract_specs",
              "signature": "def get_forward_curve(self, pair: str) -> list[dict]",
              "docstring": "Get forward curve for a currency pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2021
            },
            {
              "name": "store_forward_curve",
              "module": "contract_specs",
              "signature": "def store_forward_curve(self, pair: str, rates: list[FXForwardRate]) -> None",
              "docstring": "Store forward curve for a currency pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "rates",
                  "type": "list[FXForwardRate]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2036
            }
          ],
          "class_attributes": [
            {
              "name": "TENORS",
              "type": "dict[str, int]"
            }
          ],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1906
        },
        {
          "name": "PipValueCalculator",
          "module": "contract_specs",
          "docstring": "Calculates pip values with proper currency conversion (#X6).\n\nHandles:\n- Standard and JPY pairs\n- Cross-rate pip values\n- Account currency conversion",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "contract_specs",
              "signature": "def __init__(self, account_currency: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_currency",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2060
            },
            {
              "name": "update_rate",
              "module": "contract_specs",
              "signature": "def update_rate(self, pair: str, rate: float) -> None",
              "docstring": "Update exchange rate.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "rate",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2064
            },
            {
              "name": "get_pip_size",
              "module": "contract_specs",
              "signature": "def get_pip_size(self, pair: str) -> float",
              "docstring": "Get pip size for a currency pair (#X6).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2068
            },
            {
              "name": "calculate_pip_value",
              "module": "contract_specs",
              "signature": "def calculate_pip_value(self, pair: str, lot_size: int, account_currency: str) -> dict",
              "docstring": "Calculate pip value in account currency (#X6).\n\nFor a standard lot:\n- If quote currency = account currency: pip_value = pip_size * lot_size\n- If quote currency != account currency: need conversion\n\nArgs:\n    pair: Currency pair (e.g., \"EURUSD\", \"USDJPY\")\n    lot_size: Position size (default: standard lot)\n    account_currency: Account currency (default: instance currency)\n\nReturns:\n    Pip value calculation details",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "lot_size",
                  "type": "int"
                },
                {
                  "name": "account_currency",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2074
            },
            {
              "name": "calculate_position_pnl",
              "module": "contract_specs",
              "signature": "def calculate_position_pnl(self, pair: str, entry_rate: float, current_rate: float, lot_size: int, is_long: bool) -> dict",
              "docstring": "Calculate P&L for a position in account currency (#X6).\n\nArgs:\n    pair: Currency pair\n    entry_rate: Entry exchange rate\n    current_rate: Current exchange rate\n    lot_size: Position size\n    is_long: True for long, False for short\n\nReturns:\n    P&L calculation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "entry_rate",
                  "type": "float"
                },
                {
                  "name": "current_rate",
                  "type": "float"
                },
                {
                  "name": "lot_size",
                  "type": "int"
                },
                {
                  "name": "is_long",
                  "type": "bool"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2151
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 2045
        },
        {
          "name": "TriangularArbitrageOpportunity",
          "module": "contract_specs",
          "docstring": "Detected triangular arbitrage opportunity (#X7).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "leg1",
              "type": "tuple[str, str, float]"
            },
            {
              "name": "leg2",
              "type": "tuple[str, str, float]"
            },
            {
              "name": "leg3",
              "type": "tuple[str, str, float]"
            },
            {
              "name": "profit_pct",
              "type": "float"
            },
            {
              "name": "synthetic_rate",
              "type": "float"
            },
            {
              "name": "market_rate",
              "type": "float"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 2201
        },
        {
          "name": "TriangularArbitrageDetector",
          "module": "contract_specs",
          "docstring": "Detects triangular arbitrage opportunities (#X7).\n\nFor currencies A, B, C:\nIf (A/B) * (B/C) != (A/C), arbitrage exists.\n\nCommon triangles:\n- EUR/USD, USD/JPY, EUR/JPY\n- GBP/USD, USD/CHF, GBP/CHF",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "contract_specs",
              "signature": "def __init__(self, threshold_bps: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "threshold_bps",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2224
            },
            {
              "name": "update_rate",
              "module": "contract_specs",
              "signature": "def update_rate(self, pair: str, bid: float, ask: float) -> None",
              "docstring": "Update bid/ask for a currency pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "bid",
                  "type": "float"
                },
                {
                  "name": "ask",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2229
            },
            {
              "name": "get_rate",
              "module": "contract_specs",
              "signature": "def get_rate(self, pair: str, side: str)",
              "docstring": "Get rate for pair (bid, ask, or mid).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2233
            },
            {
              "name": "check_triangle",
              "module": "contract_specs",
              "signature": "def check_triangle(self, currency_a: str, currency_b: str, currency_c: str)",
              "docstring": "Check for arbitrage in a currency triangle (#X7).\n\nPath 1: A -> B -> C -> A\nPath 2: A -> C -> B -> A\n\nArgs:\n    currency_a: First currency (e.g., \"EUR\")\n    currency_b: Second currency (e.g., \"USD\")\n    currency_c: Third currency (e.g., \"JPY\")\n\nReturns:\n    Arbitrage opportunity if found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "currency_a",
                  "type": "str"
                },
                {
                  "name": "currency_b",
                  "type": "str"
                },
                {
                  "name": "currency_c",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2245
            },
            {
              "name": "_get_effective_rate",
              "module": "contract_specs",
              "signature": "def _get_effective_rate(self, base: str, quote: str)",
              "docstring": "Get rate, handling inverse pairs.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "base",
                  "type": "str"
                },
                {
                  "name": "quote",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2311
            },
            {
              "name": "scan_all_triangles",
              "module": "contract_specs",
              "signature": "def scan_all_triangles(self, currencies: ) -> list[TriangularArbitrageOpportunity]",
              "docstring": "Scan all possible currency triangles (#X7).\n\nArgs:\n    currencies: List of currencies to check (default: major)\n\nReturns:\n    List of arbitrage opportunities",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "currencies",
                  "type": ""
                }
              ],
              "return_type": "list[TriangularArbitrageOpportunity]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2326
            },
            {
              "name": "get_recent_opportunities",
              "module": "contract_specs",
              "signature": "def get_recent_opportunities(self, lookback_seconds: int) -> list[dict]",
              "docstring": "Get recent arbitrage opportunities.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lookback_seconds",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2353
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 2212
        },
        {
          "name": "WeekendGapRiskManager",
          "module": "contract_specs",
          "docstring": "Manages weekend gap risk for FX positions (#X8).\n\nWeekend gaps occur because FX markets close Friday 5 PM ET\nand reopen Sunday 5 PM ET, but news can move prices.\n\nHandles:\n- Gap risk estimation\n- Position reduction recommendations\n- Historical gap analysis",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "contract_specs",
              "signature": "def __init__(self, risk_tolerance: str)",
              "docstring": "Initialize weekend gap risk manager.\n\nArgs:\n    risk_tolerance: \"conservative\", \"moderate\", or \"aggressive\"",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "risk_tolerance",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2414
            },
            {
              "name": "is_weekend_approaching",
              "module": "contract_specs",
              "signature": "def is_weekend_approaching(self, hours_to_close: float) -> bool",
              "docstring": "Check if FX weekend close is approaching (#X8).\n\nFX closes Friday 5 PM ET.\n\nArgs:\n    hours_to_close: Hours before close to flag\n\nReturns:\n    True if within hours_to_close of weekend",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hours_to_close",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2429
            },
            {
              "name": "estimate_gap_risk",
              "module": "contract_specs",
              "signature": "def estimate_gap_risk(self, pair: str, position_size: float, pip_value: float, use_historical_max: bool) -> dict",
              "docstring": "Estimate potential weekend gap risk (#X8).\n\nArgs:\n    pair: Currency pair\n    position_size: Position size in lots\n    pip_value: Pip value in account currency\n    use_historical_max: Use max gap instead of average\n\nReturns:\n    Gap risk analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "position_size",
                  "type": "float"
                },
                {
                  "name": "pip_value",
                  "type": "float"
                },
                {
                  "name": "use_historical_max",
                  "type": "bool"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2453
            },
            {
              "name": "recommend_position_reduction",
              "module": "contract_specs",
              "signature": "def recommend_position_reduction(self, pair: str, current_position: float, max_weekend_risk: float, pip_value: float) -> dict",
              "docstring": "Recommend position reduction for weekend (#X8).\n\nArgs:\n    pair: Currency pair\n    current_position: Current position size (lots)\n    max_weekend_risk: Maximum acceptable weekend risk (in account currency)\n    pip_value: Pip value in account currency\n\nReturns:\n    Reduction recommendation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "current_position",
                  "type": "float"
                },
                {
                  "name": "max_weekend_risk",
                  "type": "float"
                },
                {
                  "name": "pip_value",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2503
            },
            {
              "name": "record_actual_gap",
              "module": "contract_specs",
              "signature": "def record_actual_gap(self, pair: str, friday_close: float, sunday_open: float, gap_date: datetime) -> dict",
              "docstring": "Record actual weekend gap for analysis (#X8).\n\nArgs:\n    pair: Currency pair\n    friday_close: Friday closing price\n    sunday_open: Sunday opening price\n    gap_date: Date of the gap (Sunday)\n\nReturns:\n    Gap analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "friday_close",
                  "type": "float"
                },
                {
                  "name": "sunday_open",
                  "type": "float"
                },
                {
                  "name": "gap_date",
                  "type": "datetime"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2551
            },
            {
              "name": "get_gap_statistics",
              "module": "contract_specs",
              "signature": "def get_gap_statistics(self, pair: ) -> dict",
              "docstring": "Get statistics on recorded gaps.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2589
            },
            {
              "name": "get_pre_weekend_checklist",
              "module": "contract_specs",
              "signature": "def get_pre_weekend_checklist(self, positions: dict[str, float], pip_values: dict[str, float]) -> list[dict]",
              "docstring": "Generate pre-weekend risk checklist (#X8).\n\nArgs:\n    positions: {pair: position_size} for all positions\n    pip_values: {pair: pip_value} for all pairs\n\nReturns:\n    List of risk items to review",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "pip_values",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2610
            }
          ],
          "class_attributes": [
            {
              "name": "HISTORICAL_AVG_GAPS",
              "type": "dict[str, float]"
            },
            {
              "name": "HISTORICAL_MAX_GAPS",
              "type": "dict[str, float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 2373
        }
      ],
      "functions": [
        {
          "name": "get_currency_converter",
          "module": "contract_specs",
          "signature": "def get_currency_converter() -> CurrencyConverter",
          "docstring": "Get or create the global currency converter instance.",
          "parameters": [],
          "return_type": "CurrencyConverter",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1239
        },
        {
          "name": "get_fx_rollover_manager",
          "module": "contract_specs",
          "signature": "def get_fx_rollover_manager() -> FXRolloverManager",
          "docstring": "Get or create the global FX rollover manager.",
          "parameters": [],
          "return_type": "FXRolloverManager",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1488
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "functools",
        "typing",
        "itertools",
        "pandas"
      ],
      "dependencies": [
        "__future__",
        "pandas"
      ]
    },
    "core.correlation_manager": {
      "name": "correlation_manager",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\correlation_manager.py",
      "docstring": "Correlation Manager\n===================\n\nManages correlation analysis for portfolio risk management.\nProvides rolling correlation matrices, concentration metrics,\nand regime change detection.",
      "classes": [
        {
          "name": "CorrelationRegime",
          "module": "correlation_manager",
          "docstring": "Market correlation regime classification.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 25
        },
        {
          "name": "StressIndicator",
          "module": "correlation_manager",
          "docstring": "Market stress indicator type (#R7).",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 33
        },
        {
          "name": "CorrelationAlert",
          "module": "correlation_manager",
          "docstring": "Alert for correlation regime change or threshold breach.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "correlation_manager",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary for logging.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 52
            }
          ],
          "class_attributes": [
            {
              "name": "alert_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "alert_type",
              "type": "str"
            },
            {
              "name": "severity",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "details",
              "type": "dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 43
        },
        {
          "name": "CorrelationSnapshot",
          "module": "correlation_manager",
          "docstring": "Point-in-time correlation analysis.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "correlation_manager",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary for serialization.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 77
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "correlation_matrix",
              "type": "pd.DataFrame"
            },
            {
              "name": "average_correlation",
              "type": "float"
            },
            {
              "name": "max_pairwise_correlation",
              "type": "float"
            },
            {
              "name": "min_pairwise_correlation",
              "type": "float"
            },
            {
              "name": "herfindahl_index",
              "type": "float"
            },
            {
              "name": "effective_n",
              "type": "float"
            },
            {
              "name": "regime",
              "type": "CorrelationRegime"
            },
            {
              "name": "eigenvalues",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 65
        },
        {
          "name": "CorrelationManager",
          "module": "correlation_manager",
          "docstring": "Manages correlation analysis for the trading system.\n\nFeatures:\n- Rolling correlation matrix calculation\n- Herfindahl index (concentration) computation\n- Effective diversification count (effective N)\n- Correlation regime detection\n- Alert generation on regime changes",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "correlation_manager",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize correlation manager.\n\nArgs:\n    config: Configuration dictionary with:\n        - lookback_days: Rolling window size (default: 60)\n        - max_pairwise_correlation: Alert threshold (default: 0.85)\n        - min_history_days: Minimum data for calculation (default: 20)\n        - regime_change_threshold: Sensitivity for regime detection (default: 0.15)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 102
            },
            {
              "name": "add_returns",
              "module": "correlation_manager",
              "signature": "def add_returns(self, symbol: str, timestamp: datetime, returns: float) -> None",
              "docstring": "Add returns observation for a symbol.\n\nArgs:\n    symbol: Instrument symbol\n    timestamp: Observation timestamp\n    returns: Period returns (e.g., daily returns)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "timestamp",
                  "type": "datetime"
                },
                {
                  "name": "returns",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 143
            },
            {
              "name": "add_returns_batch",
              "module": "correlation_manager",
              "signature": "def add_returns_batch(self, returns_df: pd.DataFrame, timestamp: ) -> None",
              "docstring": "Add batch of returns from a DataFrame.\n\nArgs:\n    returns_df: DataFrame with symbols as columns and returns as values\n    timestamp: Optional timestamp (uses current time if not provided)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "returns_df",
                  "type": "pd.DataFrame"
                },
                {
                  "name": "timestamp",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 162
            },
            {
              "name": "calculate_correlation_matrix",
              "module": "correlation_manager",
              "signature": "def calculate_correlation_matrix(self, symbols: , lookback_days: )",
              "docstring": "Calculate rolling correlation matrix.\n\nArgs:\n    symbols: List of symbols to include (default: all available)\n    lookback_days: Rolling window (default: configured lookback)\n\nReturns:\n    Correlation matrix as DataFrame, or None if insufficient data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": ""
                },
                {
                  "name": "lookback_days",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 185
            },
            {
              "name": "calculate_snapshot",
              "module": "correlation_manager",
              "signature": "def calculate_snapshot(self, symbols: , weights: )",
              "docstring": "Calculate complete correlation snapshot.\n\nArgs:\n    symbols: Symbols to analyze (default: all)\n    weights: Portfolio weights by symbol (for weighted calculations)\n\nReturns:\n    CorrelationSnapshot with all metrics, or None if insufficient data",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": ""
                },
                {
                  "name": "weights",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 241
            },
            {
              "name": "_calculate_herfindahl",
              "module": "correlation_manager",
              "signature": "def _calculate_herfindahl(self, weights: , symbols: list[str]) -> float",
              "docstring": "Calculate Herfindahl-Hirschman Index for concentration.\n\nHHI = sum(w_i^2) where w_i are portfolio weights\nRange: 1/n (perfectly diversified) to 1 (fully concentrated)\n\nArgs:\n    weights: Portfolio weights by symbol\n    symbols: List of symbols\n\nReturns:\n    HHI value",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "weights",
                  "type": ""
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 314
            },
            {
              "name": "_calculate_effective_n",
              "module": "correlation_manager",
              "signature": "def _calculate_effective_n(self, corr_matrix: pd.DataFrame, weights: ) -> float",
              "docstring": "Calculate effective number of independent bets.\n\nUses eigenvalue decomposition of the correlation matrix.\nEffective N = (sum of eigenvalues)^2 / sum(eigenvalues^2)\n\nFor weighted portfolio, uses portfolio variance contribution.\n\nArgs:\n    corr_matrix: Correlation matrix\n    weights: Portfolio weights\n\nReturns:\n    Effective N (1 = fully correlated, N = fully diversified)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "corr_matrix",
                  "type": "pd.DataFrame"
                },
                {
                  "name": "weights",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 349
            },
            {
              "name": "_classify_regime",
              "module": "correlation_manager",
              "signature": "def _classify_regime(self, avg_correlation: float) -> CorrelationRegime",
              "docstring": "Classify market correlation regime.\n\nArgs:\n    avg_correlation: Average pairwise correlation\n\nReturns:\n    CorrelationRegime enum value",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "avg_correlation",
                  "type": "float"
                }
              ],
              "return_type": "CorrelationRegime",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 389
            },
            {
              "name": "_check_alerts",
              "module": "correlation_manager",
              "signature": "def _check_alerts(self, snapshot: CorrelationSnapshot) -> None",
              "docstring": "Check for alert conditions and generate alerts.\n\nArgs:\n    snapshot: Current correlation snapshot",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "snapshot",
                  "type": "CorrelationSnapshot"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 408
            },
            {
              "name": "_generate_alert",
              "module": "correlation_manager",
              "signature": "def _generate_alert(self, alert_type: str, severity: str, message: str, details: dict[str, Any]) -> CorrelationAlert",
              "docstring": "Generate and store a correlation alert.\n\nArgs:\n    alert_type: Type of alert\n    severity: Severity level\n    message: Human-readable message\n    details: Additional details\n\nReturns:\n    Generated CorrelationAlert",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_type",
                  "type": "str"
                },
                {
                  "name": "severity",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "details",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "CorrelationAlert",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 483
            },
            {
              "name": "get_pair_correlation",
              "module": "correlation_manager",
              "signature": "def get_pair_correlation(self, symbol1: str, symbol2: str)",
              "docstring": "Get correlation between two specific symbols.\n\nArgs:\n    symbol1: First symbol\n    symbol2: Second symbol\n\nReturns:\n    Correlation coefficient, or None if not available",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol1",
                  "type": "str"
                },
                {
                  "name": "symbol2",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 523
            },
            {
              "name": "get_highly_correlated_pairs",
              "module": "correlation_manager",
              "signature": "def get_highly_correlated_pairs(self, threshold: ) -> list[tuple[str, str, float]]",
              "docstring": "Get list of highly correlated pairs.\n\nArgs:\n    threshold: Correlation threshold (default: configured max)\n\nReturns:\n    List of (symbol1, symbol2, correlation) tuples",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "threshold",
                  "type": ""
                }
              ],
              "return_type": "list[tuple[str, str, float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 544
            },
            {
              "name": "get_diversification_benefit",
              "module": "correlation_manager",
              "signature": "def get_diversification_benefit(self, weights: dict[str, float], volatilities: dict[str, float])",
              "docstring": "Calculate diversification benefit.\n\nDiversification benefit = 1 - (portfolio_vol / weighted_avg_vol)\n\nArgs:\n    weights: Portfolio weights\n    volatilities: Symbol volatilities\n\nReturns:\n    Diversification benefit (0 = no benefit, 1 = maximum benefit)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "weights",
                  "type": "dict[str, float]"
                },
                {
                  "name": "volatilities",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 578
            },
            {
              "name": "get_recent_alerts",
              "module": "correlation_manager",
              "signature": "def get_recent_alerts(self, hours: int) -> list[CorrelationAlert]",
              "docstring": "Get recent correlation alerts.\n\nArgs:\n    hours: Lookback period in hours\n\nReturns:\n    List of recent alerts",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hours",
                  "type": "int"
                }
              ],
              "return_type": "list[CorrelationAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 633
            },
            {
              "name": "get_current_regime",
              "module": "correlation_manager",
              "signature": "def get_current_regime(self)",
              "docstring": "Get current correlation regime.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 650
            },
            {
              "name": "get_status",
              "module": "correlation_manager",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get manager status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 656
            },
            {
              "name": "update_vix",
              "module": "correlation_manager",
              "signature": "def update_vix(self, vix_value: float) -> None",
              "docstring": "Update VIX value for stress detection (#R7).\n\nArgs:\n    vix_value: Current VIX level",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "vix_value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 676
            },
            {
              "name": "update_baseline_volatility",
              "module": "correlation_manager",
              "signature": "def update_baseline_volatility(self, symbol: str, baseline_vol: float) -> None",
              "docstring": "Update baseline volatility for stress detection (#R7).\n\nArgs:\n    symbol: Instrument symbol\n    baseline_vol: Long-term average volatility",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "baseline_vol",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 693
            },
            {
              "name": "check_volatility_stress",
              "module": "correlation_manager",
              "signature": "def check_volatility_stress(self, symbol: str, current_vol: float) -> bool",
              "docstring": "Check if current volatility indicates stress (#R7).\n\nArgs:\n    symbol: Instrument symbol\n    current_vol: Current volatility\n\nReturns:\n    True if volatility indicates stress",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "current_vol",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 703
            },
            {
              "name": "signal_external_stress",
              "module": "correlation_manager",
              "signature": "def signal_external_stress(self, stress_on: bool, reason: str) -> None",
              "docstring": "Signal external stress condition (#R7).\n\nCalled by risk agent or external monitoring systems.\n\nArgs:\n    stress_on: Whether stress mode should be active\n    reason: Reason for stress signal",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "stress_on",
                  "type": "bool"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 728
            },
            {
              "name": "_enter_stress_mode",
              "module": "correlation_manager",
              "signature": "def _enter_stress_mode(self, trigger: StressIndicator) -> None",
              "docstring": "Enter stress mode (#R7).\n\nIn stress mode:\n- Use shorter lookback period\n- Use faster decay factor (more weight on recent data)\n- Trigger immediate correlation recalculation\n\nArgs:\n    trigger: The indicator that triggered stress mode",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trigger",
                  "type": "StressIndicator"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 748
            },
            {
              "name": "_check_exit_stress_mode",
              "module": "correlation_manager",
              "signature": "def _check_exit_stress_mode(self) -> None",
              "docstring": "Check if stress mode should be exited (#R7).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 787
            },
            {
              "name": "_exit_stress_mode",
              "module": "correlation_manager",
              "signature": "def _exit_stress_mode(self) -> None",
              "docstring": "Exit stress mode (#R7).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 808
            },
            {
              "name": "_recalculate_stress_correlations",
              "module": "correlation_manager",
              "signature": "def _recalculate_stress_correlations(self) -> None",
              "docstring": "Recalculate correlations using stress parameters (#R7).\n\nUses:\n- Shorter lookback period\n- EWMA with faster decay for more weight on recent data",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 833
            },
            {
              "name": "_calculate_ewma_correlation_matrix",
              "module": "correlation_manager",
              "signature": "def _calculate_ewma_correlation_matrix(self, symbols: list[str], lookback_days: int, decay_factor: float)",
              "docstring": "Calculate EWMA-weighted correlation matrix (#R7).\n\nUses exponential decay to give more weight to recent observations.\n\nArgs:\n    symbols: List of symbols\n    lookback_days: Number of days to include\n    decay_factor: EWMA decay factor (lower = more weight on recent)\n\nReturns:\n    Correlation matrix as DataFrame",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                },
                {
                  "name": "decay_factor",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 859
            },
            {
              "name": "get_stress_adjusted_correlation_matrix",
              "module": "correlation_manager",
              "signature": "def get_stress_adjusted_correlation_matrix(self, symbols: )",
              "docstring": "Get correlation matrix adjusted for current stress conditions (#R7).\n\nIf in stress mode, returns stress-adjusted correlations with faster decay.\nOtherwise, returns the normal correlation matrix.\n\nArgs:\n    symbols: List of symbols to include\n\nReturns:\n    Correlation matrix appropriate for current market conditions",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 934
            },
            {
              "name": "get_stressed_correlation_matrix",
              "module": "correlation_manager",
              "signature": "def get_stressed_correlation_matrix(self, stress_multiplier: float, correlation_floor: float)",
              "docstring": "Generate stressed correlation matrix for scenario analysis (#R7).\n\nSimulates crisis conditions where correlations increase.\n\nArgs:\n    stress_multiplier: Factor to increase correlations\n    correlation_floor: Minimum correlation in stress scenario\n\nReturns:\n    Stressed correlation matrix",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "stress_multiplier",
                  "type": "float"
                },
                {
                  "name": "correlation_floor",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 962
            },
            {
              "name": "is_in_stress_mode",
              "module": "correlation_manager",
              "signature": "def is_in_stress_mode(self) -> bool",
              "docstring": "Check if currently in stress mode (#R7).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1005
            },
            {
              "name": "get_stress_duration_hours",
              "module": "correlation_manager",
              "signature": "def get_stress_duration_hours(self)",
              "docstring": "Get duration of current stress period in hours (#R7).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1009
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 90
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy",
        "pandas"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "pandas"
      ]
    },
    "core.custom_reports": {
      "name": "custom_reports",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\custom_reports.py",
      "docstring": "Custom Reporting Module\n=======================\n\nFlexible custom reporting framework for portfolio management.\n\nIssues Addressed:\n- #P19: Missing custom reporting\n- #E30: No execution venue selection logic (integrated here)",
      "classes": [
        {
          "name": "ReportFormat",
          "module": "custom_reports",
          "docstring": "Output format for reports.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 31
        },
        {
          "name": "ReportFrequency",
          "module": "custom_reports",
          "docstring": "Report generation frequency.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 39
        },
        {
          "name": "ReportCategory",
          "module": "custom_reports",
          "docstring": "Report category.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 49
        },
        {
          "name": "ReportDefinition",
          "module": "custom_reports",
          "docstring": "Definition of a custom report (#P19).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "custom_reports",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 81
            }
          ],
          "class_attributes": [
            {
              "name": "report_id",
              "type": "str"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "category",
              "type": "ReportCategory"
            },
            {
              "name": "frequency",
              "type": "ReportFrequency"
            },
            {
              "name": "formats",
              "type": "list[ReportFormat]"
            },
            {
              "name": "data_sources",
              "type": "list[str]"
            },
            {
              "name": "filters",
              "type": "dict[str, Any]"
            },
            {
              "name": "columns",
              "type": "list[dict]"
            },
            {
              "name": "grouping",
              "type": ""
            },
            {
              "name": "sorting",
              "type": ""
            },
            {
              "name": "aggregations",
              "type": ""
            },
            {
              "name": "created_by",
              "type": "str"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "last_modified",
              "type": "datetime"
            },
            {
              "name": "is_active",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 62
        },
        {
          "name": "ReportExecution",
          "module": "custom_reports",
          "docstring": "Record of report execution (#P19).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "custom_reports",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 115
            }
          ],
          "class_attributes": [
            {
              "name": "execution_id",
              "type": "str"
            },
            {
              "name": "report_id",
              "type": "str"
            },
            {
              "name": "started_at",
              "type": "datetime"
            },
            {
              "name": "completed_at",
              "type": ""
            },
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "row_count",
              "type": "int"
            },
            {
              "name": "output_format",
              "type": "ReportFormat"
            },
            {
              "name": "output_path",
              "type": ""
            },
            {
              "name": "error_message",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 103
        },
        {
          "name": "CustomReportBuilder",
          "module": "custom_reports",
          "docstring": "Builder for custom reports (#P19).\n\nAllows defining custom reports with:\n- Multiple data sources\n- Custom filters and transformations\n- Flexible column definitions\n- Grouping and aggregation\n- Multiple output formats",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "custom_reports",
              "signature": "def __init__(self, report_name: str, category: ReportCategory)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_name",
                  "type": "str"
                },
                {
                  "name": "category",
                  "type": "ReportCategory"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 141
            },
            {
              "name": "with_description",
              "module": "custom_reports",
              "signature": "def with_description(self, description: str) -> CustomReportBuilder",
              "docstring": "Set report description.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "description",
                  "type": "str"
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 154
            },
            {
              "name": "with_frequency",
              "module": "custom_reports",
              "signature": "def with_frequency(self, frequency: ReportFrequency) -> CustomReportBuilder",
              "docstring": "Set report frequency.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "frequency",
                  "type": "ReportFrequency"
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 159
            },
            {
              "name": "with_formats",
              "module": "custom_reports",
              "signature": "def with_formats(self, formats: list[ReportFormat]) -> CustomReportBuilder",
              "docstring": "Set output formats.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "formats",
                  "type": "list[ReportFormat]"
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 164
            },
            {
              "name": "add_data_source",
              "module": "custom_reports",
              "signature": "def add_data_source(self, source: str) -> CustomReportBuilder",
              "docstring": "Add data source.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "source",
                  "type": "str"
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 169
            },
            {
              "name": "add_filter",
              "module": "custom_reports",
              "signature": "def add_filter(self, field: str, operator: str, value: Any) -> CustomReportBuilder",
              "docstring": "Add filter condition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "field",
                  "type": "str"
                },
                {
                  "name": "operator",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "Any"
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 174
            },
            {
              "name": "add_column",
              "module": "custom_reports",
              "signature": "def add_column(self, name: str, source: str, transform: , format_spec: ) -> CustomReportBuilder",
              "docstring": "Add column definition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "source",
                  "type": "str"
                },
                {
                  "name": "transform",
                  "type": ""
                },
                {
                  "name": "format_spec",
                  "type": ""
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 179
            },
            {
              "name": "with_grouping",
              "module": "custom_reports",
              "signature": "def with_grouping(self, fields: list[str]) -> CustomReportBuilder",
              "docstring": "Set grouping fields.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fields",
                  "type": "list[str]"
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 195
            },
            {
              "name": "with_sorting",
              "module": "custom_reports",
              "signature": "def with_sorting(self, column: str, direction: str) -> CustomReportBuilder",
              "docstring": "Add sorting.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "column",
                  "type": "str"
                },
                {
                  "name": "direction",
                  "type": "str"
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            },
            {
              "name": "with_aggregation",
              "module": "custom_reports",
              "signature": "def with_aggregation(self, column: str, function: str) -> CustomReportBuilder",
              "docstring": "Add aggregation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "column",
                  "type": "str"
                },
                {
                  "name": "function",
                  "type": "str"
                }
              ],
              "return_type": "CustomReportBuilder",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 207
            },
            {
              "name": "build",
              "module": "custom_reports",
              "signature": "def build(self, created_by: str) -> ReportDefinition",
              "docstring": "Build report definition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "created_by",
                  "type": "str"
                }
              ],
              "return_type": "ReportDefinition",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 214
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 129
        },
        {
          "name": "CustomReportEngine",
          "module": "custom_reports",
          "docstring": "Custom report execution engine (#P19).\n\nFeatures:\n- Report definition management\n- Data source integration\n- Report execution and scheduling\n- Multiple output formats\n- Execution history",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "custom_reports",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 249
            },
            {
              "name": "register_data_handler",
              "module": "custom_reports",
              "signature": "def register_data_handler(self, source_name: str, handler: Callable[, list[dict]]) -> None",
              "docstring": "Register data source handler.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "source_name",
                  "type": "str"
                },
                {
                  "name": "handler",
                  "type": "Callable[, list[dict]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 287
            },
            {
              "name": "register_transform",
              "module": "custom_reports",
              "signature": "def register_transform(self, name: str, func: Callable) -> None",
              "docstring": "Register custom transform function.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "func",
                  "type": "Callable"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 295
            },
            {
              "name": "save_report",
              "module": "custom_reports",
              "signature": "def save_report(self, report: ReportDefinition) -> None",
              "docstring": "Save report definition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report",
                  "type": "ReportDefinition"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 299
            },
            {
              "name": "get_report",
              "module": "custom_reports",
              "signature": "def get_report(self, report_id: str)",
              "docstring": "Get report definition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 304
            },
            {
              "name": "list_reports",
              "module": "custom_reports",
              "signature": "def list_reports(self, category: ) -> list[ReportDefinition]",
              "docstring": "List available reports.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "category",
                  "type": ""
                }
              ],
              "return_type": "list[ReportDefinition]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 308
            },
            {
              "name": "_fetch_data",
              "module": "custom_reports",
              "signature": "def _fetch_data(self, data_sources: list[str]) -> list[dict]",
              "docstring": "Fetch data from sources.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data_sources",
                  "type": "list[str]"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 318
            },
            {
              "name": "_apply_filters",
              "module": "custom_reports",
              "signature": "def _apply_filters(self, data: list[dict], filters: dict[str, Any]) -> list[dict]",
              "docstring": "Apply filters to data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "list[dict]"
                },
                {
                  "name": "filters",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 331
            },
            {
              "name": "_apply_columns",
              "module": "custom_reports",
              "signature": "def _apply_columns(self, data: list[dict], columns: list[dict]) -> list[dict]",
              "docstring": "Apply column definitions to data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "list[dict]"
                },
                {
                  "name": "columns",
                  "type": "list[dict]"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 370
            },
            {
              "name": "_apply_grouping_and_aggregation",
              "module": "custom_reports",
              "signature": "def _apply_grouping_and_aggregation(self, data: list[dict], grouping: , aggregations: ) -> list[dict]",
              "docstring": "Apply grouping and aggregation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "list[dict]"
                },
                {
                  "name": "grouping",
                  "type": ""
                },
                {
                  "name": "aggregations",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 401
            },
            {
              "name": "_apply_sorting",
              "module": "custom_reports",
              "signature": "def _apply_sorting(self, data: list[dict], sorting: ) -> list[dict]",
              "docstring": "Apply sorting to data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "list[dict]"
                },
                {
                  "name": "sorting",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 441
            },
            {
              "name": "_format_output",
              "module": "custom_reports",
              "signature": "def _format_output(self, data: list[dict], format: ReportFormat) -> str",
              "docstring": "Format data for output.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "list[dict]"
                },
                {
                  "name": "format",
                  "type": "ReportFormat"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 457
            },
            {
              "name": "execute_report",
              "module": "custom_reports",
              "signature": "def execute_report(self, report_id: str, output_format: , override_filters: ) -> tuple[str, ReportExecution]",
              "docstring": "Execute a report (#P19).\n\nArgs:\n    report_id: Report to execute\n    output_format: Override default format\n    override_filters: Additional filters\n\nReturns:\n    (output_data, execution_record)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_id",
                  "type": "str"
                },
                {
                  "name": "output_format",
                  "type": ""
                },
                {
                  "name": "override_filters",
                  "type": ""
                }
              ],
              "return_type": "tuple[str, ReportExecution]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 525
            },
            {
              "name": "get_execution_history",
              "module": "custom_reports",
              "signature": "def get_execution_history(self, report_id: , limit: int) -> list[ReportExecution]",
              "docstring": "Get report execution history.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_id",
                  "type": ""
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[ReportExecution]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 606
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 237
        },
        {
          "name": "VenueType",
          "module": "custom_reports",
          "docstring": "Execution venue types (#E30).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 622
        },
        {
          "name": "OrderCharacteristic",
          "module": "custom_reports",
          "docstring": "Order characteristics for venue selection (#E30).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 631
        },
        {
          "name": "VenueCharacteristics",
          "module": "custom_reports",
          "docstring": "Characteristics of an execution venue (#E30).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "custom_reports",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 675
            }
          ],
          "class_attributes": [
            {
              "name": "venue_id",
              "type": "str"
            },
            {
              "name": "venue_type",
              "type": "VenueType"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "maker_fee_bps",
              "type": "float"
            },
            {
              "name": "taker_fee_bps",
              "type": "float"
            },
            {
              "name": "typical_spread_bps",
              "type": "float"
            },
            {
              "name": "fill_rate_pct",
              "type": "float"
            },
            {
              "name": "avg_fill_time_ms",
              "type": "float"
            },
            {
              "name": "price_improvement_bps",
              "type": "float"
            },
            {
              "name": "avg_daily_volume",
              "type": "float"
            },
            {
              "name": "max_order_size",
              "type": "float"
            },
            {
              "name": "min_order_size",
              "type": "float"
            },
            {
              "name": "supports_midpoint",
              "type": "bool"
            },
            {
              "name": "supports_hidden",
              "type": "bool"
            },
            {
              "name": "supports_ioc",
              "type": "bool"
            },
            {
              "name": "supports_block",
              "type": "bool"
            },
            {
              "name": "restricted_symbols",
              "type": "list[str]"
            },
            {
              "name": "min_notional",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 644
        },
        {
          "name": "VenueSelectionResult",
          "module": "custom_reports",
          "docstring": "Result of venue selection (#E30).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "custom_reports",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 704
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "order_size",
              "type": "int"
            },
            {
              "name": "order_characteristic",
              "type": "OrderCharacteristic"
            },
            {
              "name": "recommended_venues",
              "type": "list[dict]"
            },
            {
              "name": "estimated_cost_bps",
              "type": "float"
            },
            {
              "name": "estimated_fill_time_ms",
              "type": "float"
            },
            {
              "name": "routing_strategy",
              "type": "str"
            },
            {
              "name": "considerations",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 693
        },
        {
          "name": "ExecutionVenueSelector",
          "module": "custom_reports",
          "docstring": "Execution venue selection logic (#E30).\n\nFeatures:\n- Venue characteristic analysis\n- Order-based venue matching\n- Cost optimization\n- Fill rate optimization\n- Information leakage mitigation",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "custom_reports",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 729
            },
            {
              "name": "register_venue",
              "module": "custom_reports",
              "signature": "def register_venue(self, venue: VenueCharacteristics) -> None",
              "docstring": "Register execution venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue",
                  "type": "VenueCharacteristics"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 736
            },
            {
              "name": "update_symbol_adv",
              "module": "custom_reports",
              "signature": "def update_symbol_adv(self, symbol: str, adv: float) -> None",
              "docstring": "Update average daily volume for symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "adv",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 741
            },
            {
              "name": "classify_order",
              "module": "custom_reports",
              "signature": "def classify_order(self, symbol: str, quantity: int, price: float, is_urgent: bool, is_info_sensitive: bool) -> OrderCharacteristic",
              "docstring": "Classify order by characteristics (#E30).\n\nArgs:\n    symbol: Symbol\n    quantity: Order quantity\n    price: Current price\n    is_urgent: Urgency flag\n    is_info_sensitive: Information sensitivity\n\nReturns:\n    Order characteristic",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "is_urgent",
                  "type": "bool"
                },
                {
                  "name": "is_info_sensitive",
                  "type": "bool"
                }
              ],
              "return_type": "OrderCharacteristic",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 745
            },
            {
              "name": "_score_venue",
              "module": "custom_reports",
              "signature": "def _score_venue(self, venue: VenueCharacteristics, order_char: OrderCharacteristic, quantity: int, is_passive: bool) -> tuple[float, list[str]]",
              "docstring": "Score venue for order (#E30).\n\nReturns: (score, reasons)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue",
                  "type": "VenueCharacteristics"
                },
                {
                  "name": "order_char",
                  "type": "OrderCharacteristic"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "is_passive",
                  "type": "bool"
                }
              ],
              "return_type": "tuple[float, list[str]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 786
            },
            {
              "name": "select_venues",
              "module": "custom_reports",
              "signature": "def select_venues(self, symbol: str, quantity: int, price: float, is_passive: bool, is_urgent: bool, is_info_sensitive: bool, max_venues: int) -> VenueSelectionResult",
              "docstring": "Select optimal execution venues (#E30).\n\nArgs:\n    symbol: Symbol to trade\n    quantity: Order quantity\n    price: Current price\n    is_passive: Passive (make) vs aggressive (take)\n    is_urgent: Urgency flag\n    is_info_sensitive: Information sensitivity\n    max_venues: Maximum venues to use\n\nReturns:\n    VenueSelectionResult with recommendations",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "is_passive",
                  "type": "bool"
                },
                {
                  "name": "is_urgent",
                  "type": "bool"
                },
                {
                  "name": "is_info_sensitive",
                  "type": "bool"
                },
                {
                  "name": "max_venues",
                  "type": "int"
                }
              ],
              "return_type": "VenueSelectionResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 855
            },
            {
              "name": "record_execution",
              "module": "custom_reports",
              "signature": "def record_execution(self, venue_id: str, symbol: str, quantity: int, fill_pct: float, fill_time_ms: float, price_improvement_bps: float) -> None",
              "docstring": "Record execution for venue performance tracking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "fill_pct",
                  "type": "float"
                },
                {
                  "name": "fill_time_ms",
                  "type": "float"
                },
                {
                  "name": "price_improvement_bps",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 965
            },
            {
              "name": "get_venue_statistics",
              "module": "custom_reports",
              "signature": "def get_venue_statistics(self, venue_id: str) -> dict",
              "docstring": "Get venue performance statistics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 987
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 717
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "json",
        "csv",
        "io",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__",
        "csv",
        "io"
      ]
    },
    "core.dashboard_metrics": {
      "name": "dashboard_metrics",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\dashboard_metrics.py",
      "docstring": "Dashboard Metrics Module\n========================\n\nAddresses issues:\n- #R26: Risk dashboard metrics incomplete\n- #C41: Compliance dashboard metrics incomplete\n- #E31: Execution statistics dashboard incomplete\n- #O17: Option analytics dashboard incomplete\n\nFeatures:\n- Comprehensive real-time metrics for dashboards\n- Risk metrics with alerts and thresholds\n- Compliance status tracking\n- Execution quality metrics\n- Options analytics summary",
      "classes": [
        {
          "name": "AlertLevel",
          "module": "dashboard_metrics",
          "docstring": "Alert severity levels.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 32
        },
        {
          "name": "MetricStatus",
          "module": "dashboard_metrics",
          "docstring": "Metric status indicators.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 40
        },
        {
          "name": "DashboardAlert",
          "module": "dashboard_metrics",
          "docstring": "Alert for dashboard display.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "dashboard_metrics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 59
            }
          ],
          "class_attributes": [
            {
              "name": "level",
              "type": "AlertLevel"
            },
            {
              "name": "category",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "metric_name",
              "type": ""
            },
            {
              "name": "current_value",
              "type": ""
            },
            {
              "name": "threshold",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 49
        },
        {
          "name": "RiskDashboardMetrics",
          "module": "dashboard_metrics",
          "docstring": "Comprehensive risk metrics for dashboard display (#R26).\n\nProvides real-time risk monitoring with thresholds and alerts.",
          "bases": [],
          "methods": [
            {
              "name": "get_alerts",
              "module": "dashboard_metrics",
              "signature": "def get_alerts(self) -> list[DashboardAlert]",
              "docstring": "Generate alerts based on current metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[DashboardAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 139
            },
            {
              "name": "get_status",
              "module": "dashboard_metrics",
              "signature": "def get_status(self, metric_name: str) -> MetricStatus",
              "docstring": "Get status indicator for a specific metric.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metric_name",
                  "type": "str"
                }
              ],
              "return_type": "MetricStatus",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 236
            },
            {
              "name": "to_dict",
              "module": "dashboard_metrics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary for API/JSON.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 262
            }
          ],
          "class_attributes": [
            {
              "name": "portfolio_var_95",
              "type": "float"
            },
            {
              "name": "portfolio_var_99",
              "type": "float"
            },
            {
              "name": "portfolio_cvar_95",
              "type": "float"
            },
            {
              "name": "portfolio_volatility",
              "type": "float"
            },
            {
              "name": "gross_exposure",
              "type": "float"
            },
            {
              "name": "net_exposure",
              "type": "float"
            },
            {
              "name": "long_exposure",
              "type": "float"
            },
            {
              "name": "short_exposure",
              "type": "float"
            },
            {
              "name": "leverage_ratio",
              "type": "float"
            },
            {
              "name": "current_drawdown",
              "type": "float"
            },
            {
              "name": "max_drawdown",
              "type": "float"
            },
            {
              "name": "drawdown_duration_days",
              "type": "int"
            },
            {
              "name": "daily_pnl",
              "type": "float"
            },
            {
              "name": "daily_pnl_pct",
              "type": "float"
            },
            {
              "name": "mtd_pnl",
              "type": "float"
            },
            {
              "name": "ytd_pnl",
              "type": "float"
            },
            {
              "name": "portfolio_delta",
              "type": "float"
            },
            {
              "name": "portfolio_gamma",
              "type": "float"
            },
            {
              "name": "portfolio_vega",
              "type": "float"
            },
            {
              "name": "portfolio_theta",
              "type": "float"
            },
            {
              "name": "top_position_weight",
              "type": "float"
            },
            {
              "name": "top_5_weight",
              "type": "float"
            },
            {
              "name": "hhi_concentration",
              "type": "float"
            },
            {
              "name": "sector_concentration",
              "type": "dict[str, float]"
            },
            {
              "name": "limit_utilization",
              "type": "dict[str, float]"
            },
            {
              "name": "worst_case_loss",
              "type": "float"
            },
            {
              "name": "worst_case_scenario",
              "type": "str"
            },
            {
              "name": "last_updated",
              "type": "datetime"
            },
            {
              "name": "data_staleness_seconds",
              "type": "float"
            },
            {
              "name": "var_warning_threshold",
              "type": "float"
            },
            {
              "name": "var_critical_threshold",
              "type": "float"
            },
            {
              "name": "leverage_warning",
              "type": "float"
            },
            {
              "name": "leverage_critical",
              "type": "float"
            },
            {
              "name": "drawdown_warning",
              "type": "float"
            },
            {
              "name": "drawdown_critical",
              "type": "float"
            },
            {
              "name": "concentration_warning",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 77
        },
        {
          "name": "ComplianceDashboardMetrics",
          "module": "dashboard_metrics",
          "docstring": "Compliance metrics for dashboard display (#C41).\n\nTracks regulatory compliance status and upcoming deadlines.",
          "bases": [],
          "methods": [
            {
              "name": "get_alerts",
              "module": "dashboard_metrics",
              "signature": "def get_alerts(self) -> list[DashboardAlert]",
              "docstring": "Generate compliance alerts.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[DashboardAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 375
            },
            {
              "name": "calculate_compliance_score",
              "module": "dashboard_metrics",
              "signature": "def calculate_compliance_score(self) -> float",
              "docstring": "Calculate overall compliance score (0-100).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 448
            },
            {
              "name": "to_dict",
              "module": "dashboard_metrics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 467
            }
          ],
          "class_attributes": [
            {
              "name": "compliance_score",
              "type": "float"
            },
            {
              "name": "compliance_status",
              "type": "str"
            },
            {
              "name": "reports_due_today",
              "type": "int"
            },
            {
              "name": "reports_overdue",
              "type": "int"
            },
            {
              "name": "reports_submitted_today",
              "type": "int"
            },
            {
              "name": "emir_pending_reports",
              "type": "int"
            },
            {
              "name": "emir_failed_reports",
              "type": "int"
            },
            {
              "name": "mifid_pending_records",
              "type": "int"
            },
            {
              "name": "position_limit_breaches",
              "type": "int"
            },
            {
              "name": "position_limit_warnings",
              "type": "int"
            },
            {
              "name": "concentration_warnings",
              "type": "int"
            },
            {
              "name": "surveillance_alerts_today",
              "type": "int"
            },
            {
              "name": "surveillance_alerts_pending",
              "type": "int"
            },
            {
              "name": "stor_reports_submitted",
              "type": "int"
            },
            {
              "name": "best_execution_compliance_pct",
              "type": "float"
            },
            {
              "name": "execution_quality_score",
              "type": "float"
            },
            {
              "name": "training_overdue",
              "type": "int"
            },
            {
              "name": "certifications_expiring",
              "type": "int"
            },
            {
              "name": "last_audit_date",
              "type": ""
            },
            {
              "name": "audit_findings_open",
              "type": "int"
            },
            {
              "name": "days_since_last_audit",
              "type": "int"
            },
            {
              "name": "kill_switch_status",
              "type": "str"
            },
            {
              "name": "kill_switch_tests_due",
              "type": "int"
            },
            {
              "name": "upcoming_deadlines",
              "type": "list[dict]"
            },
            {
              "name": "last_updated",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 322
        },
        {
          "name": "ExecutionDashboardMetrics",
          "module": "dashboard_metrics",
          "docstring": "Execution statistics for dashboard display (#E31).\n\nTracks execution quality and order flow metrics.",
          "bases": [],
          "methods": [
            {
              "name": "get_alerts",
              "module": "dashboard_metrics",
              "signature": "def get_alerts(self) -> list[DashboardAlert]",
              "docstring": "Generate execution alerts.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[DashboardAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 581
            },
            {
              "name": "calculate_execution_quality_score",
              "module": "dashboard_metrics",
              "signature": "def calculate_execution_quality_score(self) -> float",
              "docstring": "Calculate overall execution quality score (0-100).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 637
            },
            {
              "name": "to_dict",
              "module": "dashboard_metrics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 658
            }
          ],
          "class_attributes": [
            {
              "name": "orders_today",
              "type": "int"
            },
            {
              "name": "orders_filled",
              "type": "int"
            },
            {
              "name": "orders_pending",
              "type": "int"
            },
            {
              "name": "orders_cancelled",
              "type": "int"
            },
            {
              "name": "orders_rejected",
              "type": "int"
            },
            {
              "name": "fill_rate_pct",
              "type": "float"
            },
            {
              "name": "partial_fill_rate_pct",
              "type": "float"
            },
            {
              "name": "avg_slippage_bps",
              "type": "float"
            },
            {
              "name": "max_slippage_bps",
              "type": "float"
            },
            {
              "name": "price_improvement_rate",
              "type": "float"
            },
            {
              "name": "avg_price_improvement_bps",
              "type": "float"
            },
            {
              "name": "total_implementation_shortfall",
              "type": "float"
            },
            {
              "name": "avg_shortfall_bps",
              "type": "float"
            },
            {
              "name": "avg_fill_time_ms",
              "type": "float"
            },
            {
              "name": "avg_order_latency_ms",
              "type": "float"
            },
            {
              "name": "p95_fill_time_ms",
              "type": "float"
            },
            {
              "name": "total_volume_traded",
              "type": "float"
            },
            {
              "name": "total_notional",
              "type": "float"
            },
            {
              "name": "venue_fill_rates",
              "type": "dict[str, float]"
            },
            {
              "name": "venue_latencies",
              "type": "dict[str, float]"
            },
            {
              "name": "twap_orders",
              "type": "int"
            },
            {
              "name": "vwap_orders",
              "type": "int"
            },
            {
              "name": "market_orders",
              "type": "int"
            },
            {
              "name": "limit_orders",
              "type": "int"
            },
            {
              "name": "total_commission",
              "type": "float"
            },
            {
              "name": "total_slippage_cost",
              "type": "float"
            },
            {
              "name": "total_market_impact",
              "type": "float"
            },
            {
              "name": "vs_vwap_bps",
              "type": "float"
            },
            {
              "name": "vs_twap_bps",
              "type": "float"
            },
            {
              "name": "vs_arrival_bps",
              "type": "float"
            },
            {
              "name": "last_updated",
              "type": "datetime"
            },
            {
              "name": "measurement_period_start",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 521
        },
        {
          "name": "OptionsDashboardMetrics",
          "module": "dashboard_metrics",
          "docstring": "Options analytics for dashboard display (#O17).\n\nComprehensive options portfolio metrics and risk indicators.",
          "bases": [],
          "methods": [
            {
              "name": "get_alerts",
              "module": "dashboard_metrics",
              "signature": "def get_alerts(self) -> list[DashboardAlert]",
              "docstring": "Generate options-specific alerts.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[DashboardAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 787
            },
            {
              "name": "to_dict",
              "module": "dashboard_metrics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 849
            }
          ],
          "class_attributes": [
            {
              "name": "portfolio_delta",
              "type": "float"
            },
            {
              "name": "portfolio_gamma",
              "type": "float"
            },
            {
              "name": "portfolio_vega",
              "type": "float"
            },
            {
              "name": "portfolio_theta",
              "type": "float"
            },
            {
              "name": "portfolio_rho",
              "type": "float"
            },
            {
              "name": "delta_dollars",
              "type": "float"
            },
            {
              "name": "gamma_dollars",
              "type": "float"
            },
            {
              "name": "vega_dollars",
              "type": "float"
            },
            {
              "name": "theta_dollars",
              "type": "float"
            },
            {
              "name": "total_contracts",
              "type": "int"
            },
            {
              "name": "long_calls",
              "type": "int"
            },
            {
              "name": "short_calls",
              "type": "int"
            },
            {
              "name": "long_puts",
              "type": "int"
            },
            {
              "name": "short_puts",
              "type": "int"
            },
            {
              "name": "contracts_expiring_today",
              "type": "int"
            },
            {
              "name": "contracts_expiring_this_week",
              "type": "int"
            },
            {
              "name": "contracts_expiring_this_month",
              "type": "int"
            },
            {
              "name": "weighted_avg_dte",
              "type": "float"
            },
            {
              "name": "portfolio_weighted_iv",
              "type": "float"
            },
            {
              "name": "iv_vs_hv_ratio",
              "type": "float"
            },
            {
              "name": "avg_iv_rank",
              "type": "float"
            },
            {
              "name": "avg_iv_percentile",
              "type": "float"
            },
            {
              "name": "delta_pnl",
              "type": "float"
            },
            {
              "name": "gamma_pnl",
              "type": "float"
            },
            {
              "name": "theta_pnl",
              "type": "float"
            },
            {
              "name": "vega_pnl",
              "type": "float"
            },
            {
              "name": "total_pnl",
              "type": "float"
            },
            {
              "name": "max_loss",
              "type": "float"
            },
            {
              "name": "max_profit",
              "type": "float"
            },
            {
              "name": "breakeven_prices",
              "type": "list[float]"
            },
            {
              "name": "positions_with_pin_risk",
              "type": "int"
            },
            {
              "name": "total_pin_risk_exposure",
              "type": "float"
            },
            {
              "name": "positions_with_assignment_risk",
              "type": "int"
            },
            {
              "name": "total_assignment_risk_exposure",
              "type": "float"
            },
            {
              "name": "strategies",
              "type": "dict[str, int]"
            },
            {
              "name": "last_updated",
              "type": "datetime"
            },
            {
              "name": "underlying_price",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 722
        },
        {
          "name": "DashboardMetricsCollector",
          "module": "dashboard_metrics",
          "docstring": "Collects and aggregates metrics for all dashboards.\n\nProvides unified interface for dashboard data.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "dashboard_metrics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 914
            },
            {
              "name": "get_all_alerts",
              "module": "dashboard_metrics",
              "signature": "def get_all_alerts(self) -> list[DashboardAlert]",
              "docstring": "Get all alerts from all dashboards.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[DashboardAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 920
            },
            {
              "name": "get_summary",
              "module": "dashboard_metrics",
              "signature": "def get_summary(self) -> dict",
              "docstring": "Get summary for all dashboards.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 937
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 907
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "statistics"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.data_retention": {
      "name": "data_retention",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\data_retention.py",
      "docstring": "Data Retention Manager\n======================\n\nImplements 7-year data retention requirements per MiFID II RTS 25 and EMIR.\n\nRegulatory Requirements:\n- MiFID II Article 16(7): 5-year retention for order records\n- MiFID II RTS 25: 5-year retention for order records\n- EMIR Article 9: 5-year retention post-contract termination\n- MAR Article 16: Preserve records of suspicious activities\n- National extensions (France AMF): May require 7 years\n\nThis module enforces:\n- Minimum retention periods by data type\n- Prevention of premature deletion\n- Archival policy management\n- Compliance status reporting",
      "classes": [
        {
          "name": "DataType",
          "module": "data_retention",
          "docstring": "Types of data subject to retention requirements.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 39
        },
        {
          "name": "RetentionStatus",
          "module": "data_retention",
          "docstring": "Status of a data record for retention purposes.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 66
        },
        {
          "name": "RetentionPolicy",
          "module": "data_retention",
          "docstring": "Retention policy for a data type.",
          "bases": [],
          "methods": [
            {
              "name": "get_retention_end",
              "module": "data_retention",
              "signature": "def get_retention_end(self, record_date: datetime) -> datetime",
              "docstring": "Calculate when retention period ends for a record.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record_date",
                  "type": "datetime"
                }
              ],
              "return_type": "datetime",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 83
            },
            {
              "name": "get_archive_date",
              "module": "data_retention",
              "signature": "def get_archive_date(self, record_date: datetime) -> datetime",
              "docstring": "Calculate when record should be archived.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record_date",
                  "type": "datetime"
                }
              ],
              "return_type": "datetime",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "is_within_retention",
              "module": "data_retention",
              "signature": "def is_within_retention(self, record_date: datetime) -> bool",
              "docstring": "Check if a record is still within its retention period.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record_date",
                  "type": "datetime"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 91
            }
          ],
          "class_attributes": [
            {
              "name": "data_type",
              "type": "DataType"
            },
            {
              "name": "retention_years",
              "type": "int"
            },
            {
              "name": "archive_after_days",
              "type": "int"
            },
            {
              "name": "legal_reference",
              "type": "str"
            },
            {
              "name": "deletion_requires_approval",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 75
        },
        {
          "name": "RetentionRecord",
          "module": "data_retention",
          "docstring": "Record tracking metadata for retention purposes.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "record_id",
              "type": "str"
            },
            {
              "name": "data_type",
              "type": "DataType"
            },
            {
              "name": "created_timestamp",
              "type": "datetime"
            },
            {
              "name": "status",
              "type": "RetentionStatus"
            },
            {
              "name": "archived_timestamp",
              "type": ""
            },
            {
              "name": "legal_hold_reason",
              "type": ""
            },
            {
              "name": "legal_hold_timestamp",
              "type": ""
            },
            {
              "name": "storage_location",
              "type": "str"
            },
            {
              "name": "checksum",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 186
        },
        {
          "name": "LegalHold",
          "module": "data_retention",
          "docstring": "Legal hold preventing data deletion.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "hold_id",
              "type": "str"
            },
            {
              "name": "reason",
              "type": "str"
            },
            {
              "name": "requester",
              "type": "str"
            },
            {
              "name": "created_timestamp",
              "type": "datetime"
            },
            {
              "name": "data_types",
              "type": "list[DataType]"
            },
            {
              "name": "record_ids",
              "type": "list[str]"
            },
            {
              "name": "start_date",
              "type": ""
            },
            {
              "name": "end_date",
              "type": ""
            },
            {
              "name": "released_timestamp",
              "type": ""
            },
            {
              "name": "released_by",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 200
        },
        {
          "name": "DataRetentionManager",
          "module": "data_retention",
          "docstring": "Manages data retention compliance per MiFID II, EMIR, and MAR.\n\nKey responsibilities:\n- Track retention status of all records\n- Prevent premature deletion\n- Manage legal holds\n- Generate compliance reports\n- Handle archival\n\n#C3, #I1 - 7-year record retention enforcement",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "data_retention",
              "signature": "def __init__(self, db_path: str, archive_path: str, policies: )",
              "docstring": "Initialize the data retention manager.\n\nArgs:\n    db_path: Path to retention tracking database\n    archive_path: Path for archived data\n    policies: Custom retention policies (uses defaults if None)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "db_path",
                  "type": "str"
                },
                {
                  "name": "archive_path",
                  "type": "str"
                },
                {
                  "name": "policies",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 228
            },
            {
              "name": "_init_database",
              "module": "data_retention",
              "signature": "def _init_database(self) -> None",
              "docstring": "Initialize the retention tracking database.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 265
            },
            {
              "name": "register_record",
              "module": "data_retention",
              "signature": "def register_record(self, record_id: str, data_type: DataType, created_timestamp: , checksum: , metadata: ) -> bool",
              "docstring": "Register a new record for retention tracking.\n\nArgs:\n    record_id: Unique identifier for the record\n    data_type: Type of data (order, trade, etc.)\n    created_timestamp: When record was created (defaults to now)\n    checksum: Optional checksum for integrity verification\n    metadata: Additional metadata to store\n\nReturns:\n    True if registered successfully",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record_id",
                  "type": "str"
                },
                {
                  "name": "data_type",
                  "type": "DataType"
                },
                {
                  "name": "created_timestamp",
                  "type": ""
                },
                {
                  "name": "checksum",
                  "type": ""
                },
                {
                  "name": "metadata",
                  "type": ""
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 330
            },
            {
              "name": "can_delete",
              "module": "data_retention",
              "signature": "def can_delete(self, record_id: str, requester: str) -> tuple[bool, str]",
              "docstring": "Check if a record can be deleted.\n\nReturns:\n    Tuple of (can_delete, reason)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record_id",
                  "type": "str"
                },
                {
                  "name": "requester",
                  "type": "str"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 380
            },
            {
              "name": "_log_deletion_attempt",
              "module": "data_retention",
              "signature": "def _log_deletion_attempt(self, record_id: str, blocked: bool, reason: str, requester: str) -> None",
              "docstring": "Log a deletion attempt for audit purposes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record_id",
                  "type": "str"
                },
                {
                  "name": "blocked",
                  "type": "bool"
                },
                {
                  "name": "reason",
                  "type": "str"
                },
                {
                  "name": "requester",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 449
            },
            {
              "name": "create_legal_hold",
              "module": "data_retention",
              "signature": "def create_legal_hold(self, reason: str, requester: str, data_types: , record_ids: , start_date: , end_date: ) -> str",
              "docstring": "Create a legal hold preventing deletion of matching records.\n\nArgs:\n    reason: Reason for the hold\n    requester: Person/system creating the hold\n    data_types: Types of data to hold (all if None)\n    record_ids: Specific record IDs to hold\n    start_date: Hold records from this date\n    end_date: Hold records until this date\n\nReturns:\n    Hold ID",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "reason",
                  "type": "str"
                },
                {
                  "name": "requester",
                  "type": "str"
                },
                {
                  "name": "data_types",
                  "type": ""
                },
                {
                  "name": "record_ids",
                  "type": ""
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 475
            },
            {
              "name": "release_legal_hold",
              "module": "data_retention",
              "signature": "def release_legal_hold(self, hold_id: str, released_by: str) -> bool",
              "docstring": "Release a legal hold.\n\nArgs:\n    hold_id: ID of the hold to release\n    released_by: Person/system releasing the hold\n\nReturns:\n    True if released successfully",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hold_id",
                  "type": "str"
                },
                {
                  "name": "released_by",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 559
            },
            {
              "name": "archive_eligible_records",
              "module": "data_retention",
              "signature": "def archive_eligible_records(self) -> int",
              "docstring": "Move eligible records to archive storage.\n\nReturns:\n    Number of records archived",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 608
            },
            {
              "name": "get_retention_status",
              "module": "data_retention",
              "signature": "def get_retention_status(self, record_id: str)",
              "docstring": "Get detailed retention status for a record.\n\nReturns:\n    Dictionary with retention details or None if not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 654
            },
            {
              "name": "get_compliance_report",
              "module": "data_retention",
              "signature": "def get_compliance_report(self) -> dict[str, Any]",
              "docstring": "Generate a compliance report for retention status.\n\nReturns:\n    Comprehensive compliance report",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 701
            },
            {
              "name": "get_records_by_date_range",
              "module": "data_retention",
              "signature": "def get_records_by_date_range(self, data_type: , start_date: , end_date: ) -> list[dict[str, Any]]",
              "docstring": "Query records by date range for audit purposes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data_type",
                  "type": ""
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "list[dict[str, Any]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 832
            },
            {
              "name": "get_summary",
              "module": "data_retention",
              "signature": "def get_summary(self) -> dict[str, Any]",
              "docstring": "Get summary statistics for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 871
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 214
        }
      ],
      "functions": [
        {
          "name": "create_retention_aware_logger",
          "module": "data_retention",
          "signature": "def create_retention_aware_logger(audit_logger, retention_manager: DataRetentionManager) -> None",
          "docstring": "Patch an AuditLogger to automatically register records with RetentionManager.\n\nThis ensures all logged events are tracked for retention compliance.",
          "parameters": [
            {
              "name": "audit_logger"
            },
            {
              "name": "retention_manager",
              "type": "DataRetentionManager"
            }
          ],
          "return_type": "None",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 904
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "json",
        "logging",
        "os",
        "shutil",
        "sqlite3",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing"
      ],
      "dependencies": [
        "__future__",
        "shutil",
        "sqlite3"
      ]
    },
    "core.dependency_injection": {
      "name": "dependency_injection",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\dependency_injection.py",
      "docstring": "Dependency Injection Container\n==============================\n\nSimple DI container for centralizing dependency creation and management.\n\nThis module provides:\n- Centralized dependency registration and resolution\n- Singleton and factory patterns\n- Lifecycle management (startup/shutdown)\n- Type-safe dependency injection\n\nBenefits:\n- Improved testability (easy mocking)\n- Reduced coupling between components\n- Centralized configuration\n- Explicit dependency graph\n\nUsage:\n    container = DIContainer()\n    container.register_singleton(\"event_bus\", EventBus)\n    container.register_factory(\"agent\", lambda: create_agent())\n\n    # Resolve dependencies\n    event_bus = container.resolve(\"event_bus\")\n\n    # In tests\n    container.register_singleton(\"event_bus\", MockEventBus)",
      "classes": [
        {
          "name": "DependencyLifecycle",
          "module": "dependency_injection",
          "docstring": "Lifecycle of a dependency.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 48
        },
        {
          "name": "DependencyRegistration",
          "module": "dependency_injection",
          "docstring": "Registration info for a dependency.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "lifecycle",
              "type": "DependencyLifecycle"
            },
            {
              "name": "factory",
              "type": "Callable[Ellipsis, Any]"
            },
            {
              "name": "dependencies",
              "type": "list[str]"
            },
            {
              "name": "instance",
              "type": "Any"
            },
            {
              "name": "is_async",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 56
        },
        {
          "name": "DependencyResolutionError",
          "module": "dependency_injection",
          "docstring": "Raised when a dependency cannot be resolved.",
          "bases": [
            "Exception"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 66
        },
        {
          "name": "CircularDependencyError",
          "module": "dependency_injection",
          "docstring": "Raised when circular dependencies are detected.",
          "bases": [
            "Exception"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 71
        },
        {
          "name": "DIContainer",
          "module": "dependency_injection",
          "docstring": "Simple Dependency Injection Container.\n\nFeatures:\n- Singleton and factory registration\n- Dependency chain resolution\n- Async initialization support\n- Lifecycle management\n\nThread Safety:\n- Not thread-safe by design (async single-threaded model)\n- Use asyncio.Lock if concurrent access needed",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "dependency_injection",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 91
            },
            {
              "name": "register_singleton",
              "module": "dependency_injection",
              "signature": "def register_singleton(self, name: str, factory: Callable[Ellipsis, T], dependencies: , is_async: bool) -> DIContainer",
              "docstring": "Register a singleton dependency.\n\nThe factory is called once, and the same instance is returned\non subsequent resolves.\n\nArgs:\n    name: Unique name for the dependency\n    factory: Factory function to create the instance\n    dependencies: Names of dependencies to inject\n    is_async: If True, factory is async and returns awaitable\n\nReturns:\n    Self for chaining",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "factory",
                  "type": "Callable[Ellipsis, T]"
                },
                {
                  "name": "dependencies",
                  "type": ""
                },
                {
                  "name": "is_async",
                  "type": "bool"
                }
              ],
              "return_type": "DIContainer",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 97
            },
            {
              "name": "register_factory",
              "module": "dependency_injection",
              "signature": "def register_factory(self, name: str, factory: Callable[Ellipsis, T], dependencies: , is_async: bool) -> DIContainer",
              "docstring": "Register a factory dependency.\n\nThe factory is called each time the dependency is resolved,\ncreating a new instance.\n\nArgs:\n    name: Unique name for the dependency\n    factory: Factory function to create instances\n    dependencies: Names of dependencies to inject\n    is_async: If True, factory is async\n\nReturns:\n    Self for chaining",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "factory",
                  "type": "Callable[Ellipsis, T]"
                },
                {
                  "name": "dependencies",
                  "type": ""
                },
                {
                  "name": "is_async",
                  "type": "bool"
                }
              ],
              "return_type": "DIContainer",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 129
            },
            {
              "name": "register_instance",
              "module": "dependency_injection",
              "signature": "def register_instance(self, name: str, instance: Any) -> DIContainer",
              "docstring": "Register an existing instance as a singleton.\n\nArgs:\n    name: Unique name for the dependency\n    instance: The instance to register\n\nReturns:\n    Self for chaining",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "instance",
                  "type": "Any"
                }
              ],
              "return_type": "DIContainer",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 161
            },
            {
              "name": "resolve",
              "module": "dependency_injection",
              "signature": "def resolve(self, name: str) -> Any",
              "docstring": "Resolve a dependency by name (sync).\n\nArgs:\n    name: Name of the dependency to resolve\n\nReturns:\n    The resolved dependency instance\n\nRaises:\n    DependencyResolutionError: If dependency not found\n    CircularDependencyError: If circular dependency detected",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 181
            },
            {
              "name": "resolve_async",
              "module": "dependency_injection",
              "signature": "async def resolve_async(self, name: str) -> Any",
              "docstring": "Resolve a dependency by name (async).\n\nArgs:\n    name: Name of the dependency to resolve\n\nReturns:\n    The resolved dependency instance\n\nRaises:\n    DependencyResolutionError: If dependency not found\n    CircularDependencyError: If circular dependency detected",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 237
            },
            {
              "name": "is_registered",
              "module": "dependency_injection",
              "signature": "def is_registered(self, name: str) -> bool",
              "docstring": "Check if a dependency is registered.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 290
            },
            {
              "name": "get_registration",
              "module": "dependency_injection",
              "signature": "def get_registration(self, name: str)",
              "docstring": "Get registration info for a dependency.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 294
            },
            {
              "name": "unregister",
              "module": "dependency_injection",
              "signature": "def unregister(self, name: str) -> bool",
              "docstring": "Unregister a dependency.\n\nArgs:\n    name: Name of the dependency to remove\n\nReturns:\n    True if removed, False if not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 298
            },
            {
              "name": "clear",
              "module": "dependency_injection",
              "signature": "def clear(self) -> None",
              "docstring": "Clear all registrations.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 314
            },
            {
              "name": "add_shutdown_handler",
              "module": "dependency_injection",
              "signature": "def add_shutdown_handler(self, handler: Callable[, Any]) -> None",
              "docstring": "Add a handler to call during shutdown.\n\nArgs:\n    handler: Function to call (can be async)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "handler",
                  "type": "Callable[, Any]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 320
            },
            {
              "name": "initialize_all",
              "module": "dependency_injection",
              "signature": "async def initialize_all(self) -> dict[str, Any]",
              "docstring": "Initialize all singleton dependencies.\n\nReturns:\n    Dict of name -> instance for all singletons",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 329
            },
            {
              "name": "shutdown",
              "module": "dependency_injection",
              "signature": "async def shutdown(self) -> None",
              "docstring": "Shutdown container and call all shutdown handlers.\n\nCalls handlers in reverse order of registration.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 344
            },
            {
              "name": "get_dependency_graph",
              "module": "dependency_injection",
              "signature": "def get_dependency_graph(self) -> dict[str, list[str]]",
              "docstring": "Get the dependency graph.\n\nReturns:\n    Dict mapping each dependency to its dependencies",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, list[str]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 363
            },
            {
              "name": "get_status",
              "module": "dependency_injection",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get container status for debugging.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 375
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 76
        },
        {
          "name": "ServiceProvider",
          "module": "dependency_injection",
          "docstring": "Service provider pattern for accessing the container.\n\nThis class provides a static interface to the DI container,\nuseful for legacy code that cannot use constructor injection.\n\nUsage:\n    ServiceProvider.set_container(container)\n    event_bus = ServiceProvider.get(\"event_bus\")",
          "bases": [],
          "methods": [
            {
              "name": "set_container",
              "module": "dependency_injection",
              "signature": "def set_container(cls, container: DIContainer) -> None",
              "docstring": "Set the global container.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "container",
                  "type": "DIContainer"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 433
            },
            {
              "name": "get",
              "module": "dependency_injection",
              "signature": "def get(cls, name: str) -> Any",
              "docstring": "Get a dependency from the container.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 438
            },
            {
              "name": "get_async",
              "module": "dependency_injection",
              "signature": "async def get_async(cls, name: str) -> Any",
              "docstring": "Get a dependency from the container (async).",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": true,
              "line_number": 445
            },
            {
              "name": "is_registered",
              "module": "dependency_injection",
              "signature": "def is_registered(cls, name: str) -> bool",
              "docstring": "Check if a dependency is registered.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 452
            },
            {
              "name": "get_container",
              "module": "dependency_injection",
              "signature": "def get_container(cls)",
              "docstring": "Get the current container.",
              "parameters": [
                {
                  "name": "cls"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 459
            }
          ],
          "class_attributes": [
            {
              "name": "_container",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 418
        }
      ],
      "functions": [
        {
          "name": "create_trading_container",
          "module": "dependency_injection",
          "signature": "def create_trading_container() -> DIContainer",
          "docstring": "Create a pre-configured DI container for the trading system.\n\nThis sets up standard dependencies without instantiating them.\nCall initialize_all() to create instances.\n\nReturns:\n    Configured DIContainer",
          "parameters": [],
          "return_type": "DIContainer",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 399
        }
      ],
      "constants": [
        {
          "name": "T",
          "line": 45
        }
      ],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.documentation_generator": {
      "name": "documentation_generator",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\documentation_generator.py",
      "docstring": "Auto-Generated Documentation System.\n\nThis module provides automated documentation generation from code,\nincluding API documentation, module summaries, and architecture diagrams.\n\nAddresses:\n- #I24 - Documentation not auto-generated",
      "classes": [
        {
          "name": "DocFormat",
          "module": "documentation_generator",
          "docstring": "Documentation output formats.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 26
        },
        {
          "name": "FunctionDoc",
          "module": "documentation_generator",
          "docstring": "Documentation for a function.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "documentation_generator",
              "signature": "def to_dict(self) -> Dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 49
            }
          ],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "module",
              "type": "str"
            },
            {
              "name": "signature",
              "type": "str"
            },
            {
              "name": "docstring",
              "type": "str"
            },
            {
              "name": "parameters",
              "type": "List[Dict[str, str]]"
            },
            {
              "name": "return_type",
              "type": "str"
            },
            {
              "name": "raises",
              "type": "List[str]"
            },
            {
              "name": "examples",
              "type": "List[str]"
            },
            {
              "name": "decorators",
              "type": "List[str]"
            },
            {
              "name": "is_async",
              "type": "bool"
            },
            {
              "name": "line_number",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 35
        },
        {
          "name": "ClassDoc",
          "module": "documentation_generator",
          "docstring": "Documentation for a class.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "documentation_generator",
              "signature": "def to_dict(self) -> Dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 79
            }
          ],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "module",
              "type": "str"
            },
            {
              "name": "docstring",
              "type": "str"
            },
            {
              "name": "bases",
              "type": "List[str]"
            },
            {
              "name": "methods",
              "type": "List[FunctionDoc]"
            },
            {
              "name": "class_attributes",
              "type": "List[Dict[str, str]]"
            },
            {
              "name": "instance_attributes",
              "type": "List[Dict[str, str]]"
            },
            {
              "name": "decorators",
              "type": "List[str]"
            },
            {
              "name": "line_number",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 67
        },
        {
          "name": "ModuleDoc",
          "module": "documentation_generator",
          "docstring": "Documentation for a module.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "documentation_generator",
              "signature": "def to_dict(self) -> Dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 106
            }
          ],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "path",
              "type": "str"
            },
            {
              "name": "docstring",
              "type": "str"
            },
            {
              "name": "classes",
              "type": "List[ClassDoc]"
            },
            {
              "name": "functions",
              "type": "List[FunctionDoc]"
            },
            {
              "name": "constants",
              "type": "List[Dict[str, Any]]"
            },
            {
              "name": "imports",
              "type": "List[str]"
            },
            {
              "name": "dependencies",
              "type": "List[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 95
        },
        {
          "name": "DocstringParser",
          "module": "documentation_generator",
          "docstring": "Parser for Python docstrings (Google style).",
          "bases": [],
          "methods": [
            {
              "name": "parse",
              "module": "documentation_generator",
              "signature": "def parse(docstring: Optional[str]) -> Dict[str, Any]",
              "docstring": "Parse a Google-style docstring.\n\nArgs:\n    docstring: The docstring to parse\n\nReturns:\n    Dictionary with parsed sections",
              "parameters": [
                {
                  "name": "docstring",
                  "type": "Optional[str]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 124
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 120
        },
        {
          "name": "CodeAnalyzer",
          "module": "documentation_generator",
          "docstring": "Analyzes Python source code for documentation extraction.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "documentation_generator",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 224
            },
            {
              "name": "analyze_file",
              "module": "documentation_generator",
              "signature": "def analyze_file(self, file_path: str) -> Optional[ModuleDoc]",
              "docstring": "Analyze a Python file and extract documentation.\n\nArgs:\n    file_path: Path to the Python file\n\nReturns:\n    ModuleDoc object with extracted documentation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "file_path",
                  "type": "str"
                }
              ],
              "return_type": "Optional[ModuleDoc]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 227
            },
            {
              "name": "_analyze_class",
              "module": "documentation_generator",
              "signature": "def _analyze_class(self, node: ast.ClassDef, module_name: str) -> ClassDoc",
              "docstring": "Analyze a class definition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "node",
                  "type": "ast.ClassDef"
                },
                {
                  "name": "module_name",
                  "type": "str"
                }
              ],
              "return_type": "ClassDoc",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 284
            },
            {
              "name": "_analyze_function",
              "module": "documentation_generator",
              "signature": "def _analyze_function(self, node, module_name: str) -> FunctionDoc",
              "docstring": "Analyze a function definition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "node"
                },
                {
                  "name": "module_name",
                  "type": "str"
                }
              ],
              "return_type": "FunctionDoc",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 307
            },
            {
              "name": "_get_name",
              "module": "documentation_generator",
              "signature": "def _get_name(self, node) -> str",
              "docstring": "Get name from AST node.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "node"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 351
            },
            {
              "name": "_get_annotation",
              "module": "documentation_generator",
              "signature": "def _get_annotation(self, node) -> str",
              "docstring": "Get annotation as string.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "node"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 361
            },
            {
              "name": "_get_decorator_name",
              "module": "documentation_generator",
              "signature": "def _get_decorator_name(self, node) -> str",
              "docstring": "Get decorator name.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "node"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 380
            },
            {
              "name": "_identify_dependencies",
              "module": "documentation_generator",
              "signature": "def _identify_dependencies(self, imports: List[str]) -> List[str]",
              "docstring": "Identify external dependencies.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "imports",
                  "type": "List[str]"
                }
              ],
              "return_type": "List[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 390
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 221
        },
        {
          "name": "DocumentationGenerator",
          "module": "documentation_generator",
          "docstring": "Generates documentation from analyzed code.\n\nSupports multiple output formats including Markdown, HTML, and JSON.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "documentation_generator",
              "signature": "def __init__(self, project_root: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "project_root",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 407
            },
            {
              "name": "scan_directory",
              "module": "documentation_generator",
              "signature": "def scan_directory(self, directory: str, exclude_patterns: Optional[List[str]])",
              "docstring": "Scan a directory for Python files and analyze them.\n\nArgs:\n    directory: Directory path to scan\n    exclude_patterns: List of patterns to exclude",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "directory",
                  "type": "str"
                },
                {
                  "name": "exclude_patterns",
                  "type": "Optional[List[str]]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 412
            },
            {
              "name": "generate_markdown",
              "module": "documentation_generator",
              "signature": "def generate_markdown(self, output_dir: str)",
              "docstring": "Generate Markdown documentation.\n\nArgs:\n    output_dir: Output directory for generated docs",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "output_dir",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 434
            },
            {
              "name": "_generate_index_md",
              "module": "documentation_generator",
              "signature": "def _generate_index_md(self) -> str",
              "docstring": "Generate index Markdown.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 456
            },
            {
              "name": "_generate_module_md",
              "module": "documentation_generator",
              "signature": "def _generate_module_md(self, module_doc: ModuleDoc) -> str",
              "docstring": "Generate Markdown for a single module.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "module_doc",
                  "type": "ModuleDoc"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 488
            },
            {
              "name": "generate_json",
              "module": "documentation_generator",
              "signature": "def generate_json(self, output_file: str)",
              "docstring": "Generate JSON documentation.\n\nArgs:\n    output_file: Output file path",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "output_file",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 565
            },
            {
              "name": "generate_summary",
              "module": "documentation_generator",
              "signature": "def generate_summary(self) -> Dict[str, Any]",
              "docstring": "Generate documentation summary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 582
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 400
        }
      ],
      "functions": [
        {
          "name": "generate_project_documentation",
          "module": "documentation_generator",
          "signature": "def generate_project_documentation(project_root: str, directories: List[str], output_dir: str)",
          "docstring": "Generate full project documentation.\n\nArgs:\n    project_root: Root directory of the project\n    directories: List of directories to document\n    output_dir: Output directory for documentation",
          "parameters": [
            {
              "name": "project_root",
              "type": "str"
            },
            {
              "name": "directories",
              "type": "List[str]"
            },
            {
              "name": "output_dir",
              "type": "str"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 612
        }
      ],
      "constants": [],
      "imports": [
        "ast",
        "inspect",
        "json",
        "logging",
        "os",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing"
      ],
      "dependencies": [
        "ast",
        "inspect"
      ]
    },
    "core.events": {
      "name": "events",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\events.py",
      "docstring": "Event Definitions\n=================\n\nAll events in the system are immutable and traceable.\nEach event carries metadata for audit compliance (EU/AMF).",
      "classes": [
        {
          "name": "EventType",
          "module": "events",
          "docstring": "Enumeration of all event types in the system.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 18
        },
        {
          "name": "SignalDirection",
          "module": "events",
          "docstring": "Trading signal direction.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 42
        },
        {
          "name": "OrderSide",
          "module": "events",
          "docstring": "Order side.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 49
        },
        {
          "name": "OrderType",
          "module": "events",
          "docstring": "Order type.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 55
        },
        {
          "name": "TimeInForce",
          "module": "events",
          "docstring": "Time in force instruction for orders (#E7).\n\nSpecifies how long an order remains active.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 63
        },
        {
          "name": "RiskAlertSeverity",
          "module": "events",
          "docstring": "Risk alert severity levels.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 78
        },
        {
          "name": "Event",
          "module": "events",
          "docstring": "Base event class.\n\nAll events are immutable (frozen) to ensure audit trail integrity.",
          "bases": [],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert event to dictionary for audit logging.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 98
            }
          ],
          "class_attributes": [
            {
              "name": "event_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "source_agent",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 87
        },
        {
          "name": "MarketDataEvent",
          "module": "events",
          "docstring": "Market data tick event from Interactive Brokers.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "mid",
              "module": "events",
              "signature": "def mid(self) -> float",
              "docstring": "Calculate mid price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 128
            },
            {
              "name": "spread",
              "module": "events",
              "signature": "def spread(self) -> float",
              "docstring": "Calculate bid-ask spread.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 135
            },
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 141
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "exchange",
              "type": "str"
            },
            {
              "name": "bid",
              "type": "float"
            },
            {
              "name": "ask",
              "type": "float"
            },
            {
              "name": "last",
              "type": "float"
            },
            {
              "name": "volume",
              "type": "int"
            },
            {
              "name": "bid_size",
              "type": "int"
            },
            {
              "name": "ask_size",
              "type": "int"
            },
            {
              "name": "high",
              "type": "float"
            },
            {
              "name": "low",
              "type": "float"
            },
            {
              "name": "open_price",
              "type": "float"
            },
            {
              "name": "close",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 109
        },
        {
          "name": "SignalEvent",
          "module": "events",
          "docstring": "Trading signal generated by a strategy agent.\n\nSignals are advisory only - they do NOT trigger orders directly.\nOnly the CIO agent can make trading decisions.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary with full traceability.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 178
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "strategy_name",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "direction",
              "type": "SignalDirection"
            },
            {
              "name": "strength",
              "type": "float"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "target_price",
              "type": ""
            },
            {
              "name": "stop_loss",
              "type": ""
            },
            {
              "name": "rationale",
              "type": "str"
            },
            {
              "name": "data_sources",
              "type": "tuple[str, Ellipsis]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 160
        },
        {
          "name": "DecisionEvent",
          "module": "events",
          "docstring": "Trading decision made by the CIO agent.\n\nThis is the ONLY event that can lead to order creation.\nMust include full rationale and data sources for compliance.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary with full compliance data.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 215
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "action",
              "type": ""
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "order_type",
              "type": "OrderType"
            },
            {
              "name": "limit_price",
              "type": ""
            },
            {
              "name": "stop_price",
              "type": ""
            },
            {
              "name": "rationale",
              "type": "str"
            },
            {
              "name": "contributing_signals",
              "type": "tuple[str, Ellipsis]"
            },
            {
              "name": "data_sources",
              "type": "tuple[str, Ellipsis]"
            },
            {
              "name": "conviction_score",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 196
        },
        {
          "name": "ValidatedDecisionEvent",
          "module": "events",
          "docstring": "Decision validated by Risk & Compliance agent.\n\nOnly validated decisions can be executed.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 248
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "original_decision_id",
              "type": "str"
            },
            {
              "name": "approved",
              "type": "bool"
            },
            {
              "name": "adjusted_quantity",
              "type": ""
            },
            {
              "name": "rejection_reason",
              "type": ""
            },
            {
              "name": "risk_metrics",
              "type": "dict[str, float]"
            },
            {
              "name": "compliance_checks",
              "type": "tuple[str, Ellipsis]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 234
        },
        {
          "name": "OrderEvent",
          "module": "events",
          "docstring": "Order event sent to broker.\n\nOnly the Execution Agent can create these.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 282
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "decision_id",
              "type": "str"
            },
            {
              "name": "validation_id",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "OrderSide"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "order_type",
              "type": "OrderType"
            },
            {
              "name": "limit_price",
              "type": ""
            },
            {
              "name": "stop_price",
              "type": ""
            },
            {
              "name": "broker_order_id",
              "type": ""
            },
            {
              "name": "algo",
              "type": "str"
            },
            {
              "name": "time_in_force",
              "type": "TimeInForce"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 263
        },
        {
          "name": "FillEvent",
          "module": "events",
          "docstring": "Order fill event from broker.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 316
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "broker_order_id",
              "type": "int"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "OrderSide"
            },
            {
              "name": "filled_quantity",
              "type": "int"
            },
            {
              "name": "fill_price",
              "type": "float"
            },
            {
              "name": "commission",
              "type": "float"
            },
            {
              "name": "exchange",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 302
        },
        {
          "name": "RiskAlertEvent",
          "module": "events",
          "docstring": "Risk alert event.\n\nCRITICAL and EMERGENCY alerts will halt trading.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 348
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "severity",
              "type": "RiskAlertSeverity"
            },
            {
              "name": "alert_type",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "current_value",
              "type": "float"
            },
            {
              "name": "threshold_value",
              "type": "float"
            },
            {
              "name": "affected_symbols",
              "type": "tuple[str, Ellipsis]"
            },
            {
              "name": "halt_trading",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 333
        },
        {
          "name": "RollSignalEvent",
          "module": "events",
          "docstring": "Futures roll signal event.\n\nGenerated when a futures contract approaches expiry and needs to be rolled.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 383
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "from_contract",
              "type": "str"
            },
            {
              "name": "to_contract",
              "type": "str"
            },
            {
              "name": "days_to_expiry",
              "type": "int"
            },
            {
              "name": "roll_date",
              "type": "str"
            },
            {
              "name": "urgency",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 369
        },
        {
          "name": "RollCompleteEvent",
          "module": "events",
          "docstring": "Futures roll completion event.\n\nGenerated when a roll has been successfully completed.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 411
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "from_contract",
              "type": "str"
            },
            {
              "name": "to_contract",
              "type": "str"
            },
            {
              "name": "price_adjustment",
              "type": "float"
            },
            {
              "name": "rolled_quantity",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 398
        },
        {
          "name": "SurveillanceAlertEvent",
          "module": "events",
          "docstring": "Market surveillance alert event.\n\nGenerated when potential market abuse is detected.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 439
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "alert_type",
              "type": "str"
            },
            {
              "name": "severity",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "evidence",
              "type": "tuple[str, Ellipsis]"
            },
            {
              "name": "requires_review",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 425
        },
        {
          "name": "TransactionReportEvent",
          "module": "events",
          "docstring": "Transaction reporting event.\n\nGenerated when a transaction report is submitted to regulators.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 469
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "report_id",
              "type": "str"
            },
            {
              "name": "transaction_reference",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "float"
            },
            {
              "name": "price",
              "type": "float"
            },
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "regulator",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 454
        },
        {
          "name": "StressTestResultEvent",
          "module": "events",
          "docstring": "Stress test result event.\n\nGenerated when a stress test scenario is run.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 499
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "scenario_id",
              "type": "str"
            },
            {
              "name": "scenario_name",
              "type": "str"
            },
            {
              "name": "pnl_impact",
              "type": "float"
            },
            {
              "name": "pnl_impact_pct",
              "type": "float"
            },
            {
              "name": "passes_limit",
              "type": "bool"
            },
            {
              "name": "limit_breaches",
              "type": "tuple[str, Ellipsis]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 485
        },
        {
          "name": "CorrelationAlertEvent",
          "module": "events",
          "docstring": "Correlation regime alert event.\n\nGenerated when correlation patterns change significantly.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 528
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "alert_type",
              "type": "str"
            },
            {
              "name": "previous_regime",
              "type": "str"
            },
            {
              "name": "new_regime",
              "type": "str"
            },
            {
              "name": "average_correlation",
              "type": "float"
            },
            {
              "name": "max_pairwise_correlation",
              "type": "float"
            },
            {
              "name": "affected_pairs",
              "type": "tuple[str, Ellipsis]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 514
        },
        {
          "name": "GreeksUpdateEvent",
          "module": "events",
          "docstring": "Portfolio Greeks update event.\n\nGenerated when portfolio Greeks are recalculated.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 559
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "portfolio_delta",
              "type": "float"
            },
            {
              "name": "portfolio_gamma",
              "type": "float"
            },
            {
              "name": "portfolio_vega",
              "type": "float"
            },
            {
              "name": "portfolio_theta",
              "type": "float"
            },
            {
              "name": "delta_limit_pct",
              "type": "float"
            },
            {
              "name": "gamma_limit_pct",
              "type": "float"
            },
            {
              "name": "vega_limit_pct",
              "type": "float"
            },
            {
              "name": "any_breach",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 543
        },
        {
          "name": "KillSwitchEvent",
          "module": "events",
          "docstring": "Kill switch event for MiFID II RTS 6 compliance.\n\nTriggers immediate halt of all trading activity when activated.\nAll pending orders should be cancelled and no new orders accepted.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 591
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "activated",
              "type": "bool"
            },
            {
              "name": "reason",
              "type": "str"
            },
            {
              "name": "trigger_type",
              "type": "str"
            },
            {
              "name": "affected_symbols",
              "type": "tuple[str, Ellipsis]"
            },
            {
              "name": "cancel_pending_orders",
              "type": "bool"
            },
            {
              "name": "close_positions",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 576
        },
        {
          "name": "OrderState",
          "module": "events",
          "docstring": "Order state machine states per MiFID II requirements.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 605
        },
        {
          "name": "OrderStateChangeEvent",
          "module": "events",
          "docstring": "Order state change event for tracking order lifecycle.\n\nProvides full audit trail of order state transitions.",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "to_audit_dict",
              "module": "events",
              "signature": "def to_audit_dict(self) -> dict[str, Any]",
              "docstring": "Convert to audit dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 652
            }
          ],
          "class_attributes": [
            {
              "name": "event_type",
              "type": "EventType"
            },
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "broker_order_id",
              "type": ""
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "previous_state",
              "type": "OrderState"
            },
            {
              "name": "new_state",
              "type": "OrderState"
            },
            {
              "name": "reason",
              "type": "str"
            },
            {
              "name": "filled_quantity",
              "type": "int"
            },
            {
              "name": "remaining_quantity",
              "type": "int"
            },
            {
              "name": "avg_fill_price",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 635
        }
      ],
      "functions": [
        {
          "name": "is_valid_state_transition",
          "module": "events",
          "signature": "def is_valid_state_transition(from_state: OrderState, to_state: OrderState) -> bool",
          "docstring": "Check if a state transition is valid.",
          "parameters": [
            {
              "name": "from_state",
              "type": "OrderState"
            },
            {
              "name": "to_state",
              "type": "OrderState"
            }
          ],
          "return_type": "bool",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 669
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "uuid",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__",
        "uuid"
      ]
    },
    "core.event_bus": {
      "name": "event_bus",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\event_bus.py",
      "docstring": "Event Bus\n=========\n\nCentral event bus for inter-agent communication.\nImplements fan-out for signal agents and fan-in synchronization for CIO.\n\nFeatures:\n- Bounded queues with configurable backpressure\n- Warning/critical thresholds for queue depth\n- Metrics tracking for monitoring\n- Priority support for critical events\n- Event persistence for crash recovery (#S4)\n- Health check with automatic recovery (#SOLID refactoring)",
      "classes": [
        {
          "name": "EventBusHealthStatus",
          "module": "event_bus",
          "docstring": "Health status levels for EventBus.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 40
        },
        {
          "name": "HealthCheckConfig",
          "module": "event_bus",
          "docstring": "Configuration for EventBus health checks.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "enabled",
              "type": "bool"
            },
            {
              "name": "check_interval_seconds",
              "type": "float"
            },
            {
              "name": "max_processing_latency_ms",
              "type": "float"
            },
            {
              "name": "max_queue_stall_seconds",
              "type": "float"
            },
            {
              "name": "max_consecutive_errors",
              "type": "int"
            },
            {
              "name": "recovery_attempts",
              "type": "int"
            },
            {
              "name": "recovery_delay_seconds",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 49
        },
        {
          "name": "HealthCheckResult",
          "module": "event_bus",
          "docstring": "Result of a health check.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "event_bus",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 71
            }
          ],
          "class_attributes": [
            {
              "name": "status",
              "type": "EventBusHealthStatus"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "latency_ms",
              "type": "float"
            },
            {
              "name": "queue_size",
              "type": "int"
            },
            {
              "name": "last_event_processed",
              "type": ""
            },
            {
              "name": "consecutive_errors",
              "type": "int"
            },
            {
              "name": "message",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 61
        },
        {
          "name": "BackpressureLevel",
          "module": "event_bus",
          "docstring": "Backpressure severity levels.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 84
        },
        {
          "name": "BackpressureConfig",
          "module": "event_bus",
          "docstring": "Configuration for backpressure handling.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "max_queue_size",
              "type": "int"
            },
            {
              "name": "warning_threshold_pct",
              "type": "float"
            },
            {
              "name": "high_threshold_pct",
              "type": "float"
            },
            {
              "name": "critical_threshold_pct",
              "type": "float"
            },
            {
              "name": "drop_low_priority_at_critical",
              "type": "bool"
            },
            {
              "name": "enable_rate_limiting",
              "type": "bool"
            },
            {
              "name": "rate_limit_events_per_second",
              "type": "int"
            },
            {
              "name": "cooldown_seconds",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 93
        },
        {
          "name": "BackpressureMetrics",
          "module": "event_bus",
          "docstring": "Metrics for backpressure monitoring.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "event_bus",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary for logging/monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 119
            }
          ],
          "class_attributes": [
            {
              "name": "total_events_published",
              "type": "int"
            },
            {
              "name": "total_events_processed",
              "type": "int"
            },
            {
              "name": "total_events_dropped",
              "type": "int"
            },
            {
              "name": "current_queue_size",
              "type": "int"
            },
            {
              "name": "max_queue_size_reached",
              "type": "int"
            },
            {
              "name": "backpressure_level",
              "type": "BackpressureLevel"
            },
            {
              "name": "last_warning_time",
              "type": ""
            },
            {
              "name": "events_per_second",
              "type": "float"
            },
            {
              "name": "processing_latency_ms",
              "type": "float"
            },
            {
              "name": "rate_limited_count",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 106
        },
        {
          "name": "SignalBarrier",
          "module": "event_bus",
          "docstring": "Synchronization barrier for signal aggregation.\n\nCollects signals from all strategy agents before CIO decision.\nImplements fan-in pattern with timeout.\n\nThread-safety: Uses internal lock to prevent race conditions during\nrapid signal arrival (fixes #S2).",
          "bases": [],
          "methods": [
            {
              "name": "add_signal",
              "module": "event_bus",
              "signature": "async def add_signal(self, agent_name: str, signal: SignalEvent) -> bool",
              "docstring": "Add a signal from an agent (thread-safe).\n\nReturns True if all expected signals received.\nReturns False if barrier is closed (late signal).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                },
                {
                  "name": "signal",
                  "type": "SignalEvent"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 163
            },
            {
              "name": "_is_complete_unsafe",
              "module": "event_bus",
              "signature": "def _is_complete_unsafe(self) -> bool",
              "docstring": "Check if all expected agents have reported (no lock, internal use).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 186
            },
            {
              "name": "is_complete",
              "module": "event_bus",
              "signature": "async def is_complete(self) -> bool",
              "docstring": "Check if all expected agents have reported (thread-safe).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 190
            },
            {
              "name": "wait",
              "module": "event_bus",
              "signature": "async def wait(self) -> dict[str, SignalEvent]",
              "docstring": "Wait for all signals or timeout (thread-safe).\n\nReturns collected signals (may be partial on timeout).\nMarks barrier as closed to reject late signals.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, SignalEvent]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 195
            },
            {
              "name": "get_signals_copy",
              "module": "event_bus",
              "signature": "async def get_signals_copy(self) -> dict[str, SignalEvent]",
              "docstring": "Get a copy of current signals (thread-safe).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, SignalEvent]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 221
            },
            {
              "name": "get_received_count",
              "module": "event_bus",
              "signature": "async def get_received_count(self) -> int",
              "docstring": "Get count of received signals (thread-safe).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 226
            },
            {
              "name": "is_closed",
              "module": "event_bus",
              "signature": "def is_closed(self) -> bool",
              "docstring": "Check if barrier is closed.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 231
            }
          ],
          "class_attributes": [
            {
              "name": "expected_agents",
              "type": "set[str]"
            },
            {
              "name": "timeout_seconds",
              "type": "float"
            },
            {
              "name": "barrier_id",
              "type": "int"
            },
            {
              "name": "signals",
              "type": "dict[str, SignalEvent]"
            },
            {
              "name": "_event",
              "type": "asyncio.Event"
            },
            {
              "name": "_created_at",
              "type": "datetime"
            },
            {
              "name": "_lock",
              "type": "asyncio.Lock"
            },
            {
              "name": "_is_closed",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 144
        },
        {
          "name": "EventBus",
          "module": "event_bus",
          "docstring": "Central event bus for the trading system.\n\nResponsibilities:\n- Route events to subscribed handlers\n- Implement signal synchronization barrier\n- Provide audit trail for all events\n- Handle backpressure with bounded queues and rate limiting\n\nBackpressure Features:\n- Tiered warning/critical thresholds\n- Rate limiting when queue fills\n- Priority support for critical events\n- Metrics for monitoring",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "event_bus",
              "signature": "def __init__(self, max_queue_size: int, signal_timeout: float, barrier_timeout: float, backpressure_config: , enable_persistence: bool, persistence_config: PersistenceConfig | None, health_check_config: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "max_queue_size",
                  "type": "int"
                },
                {
                  "name": "signal_timeout",
                  "type": "float"
                },
                {
                  "name": "barrier_timeout",
                  "type": "float"
                },
                {
                  "name": "backpressure_config",
                  "type": ""
                },
                {
                  "name": "enable_persistence",
                  "type": "bool"
                },
                {
                  "name": "persistence_config",
                  "type": "PersistenceConfig | None"
                },
                {
                  "name": "health_check_config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 253
            },
            {
              "name": "register_signal_agent",
              "module": "event_bus",
              "signature": "def register_signal_agent(self, agent_name: str) -> None",
              "docstring": "Register an agent as a signal producer.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 328
            },
            {
              "name": "_is_duplicate",
              "module": "event_bus",
              "signature": "def _is_duplicate(self, event_id: str) -> bool",
              "docstring": "Check if an event is a duplicate (#S7).\n\nReturns True if event ID has been seen within the dedup window.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 333
            },
            {
              "name": "_mark_processed",
              "module": "event_bus",
              "signature": "def _mark_processed(self, event_id: str) -> None",
              "docstring": "Mark an event as processed for deduplication (#S7).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 350
            },
            {
              "name": "_cleanup_dedup_ids",
              "module": "event_bus",
              "signature": "def _cleanup_dedup_ids(self, force_cleanup_pct: int) -> None",
              "docstring": "Clean up old event IDs from deduplication tracking (#S7).\n\nArgs:\n    force_cleanup_pct: If > 0, force removal of this percentage of oldest IDs",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "force_cleanup_pct",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 363
            },
            {
              "name": "subscribe",
              "module": "event_bus",
              "signature": "def subscribe(self, event_type: EventType, handler: Callable[, Coroutine[Any, Any, None]]) -> None",
              "docstring": "Subscribe a handler to an event type.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_type",
                  "type": "EventType"
                },
                {
                  "name": "handler",
                  "type": "Callable[, Coroutine[Any, Any, None]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 396
            },
            {
              "name": "unsubscribe",
              "module": "event_bus",
              "signature": "def unsubscribe(self, event_type: EventType, handler: Callable[, Coroutine[Any, Any, None]]) -> None",
              "docstring": "Unsubscribe a handler from an event type.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_type",
                  "type": "EventType"
                },
                {
                  "name": "handler",
                  "type": "Callable[, Coroutine[Any, Any, None]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 405
            },
            {
              "name": "cleanup_dead_handlers",
              "module": "event_bus",
              "signature": "def cleanup_dead_handlers(self, max_idle_seconds: float) -> int",
              "docstring": "Remove handlers that haven't been called in a long time (P0-5 memory leak fix).\n\nThis prevents memory leaks from handlers that were subscribed but whose\nowning objects were garbage collected, leaving orphaned handler references.\n\nArgs:\n    max_idle_seconds: Remove handlers idle longer than this (default 10 min)\n\nReturns:\n    Number of handlers removed",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "max_idle_seconds",
                  "type": "float"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 418
            },
            {
              "name": "get_handler_stats",
              "module": "event_bus",
              "signature": "def get_handler_stats(self) -> dict",
              "docstring": "Get statistics about registered handlers (for monitoring).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 459
            },
            {
              "name": "publish",
              "module": "event_bus",
              "signature": "async def publish(self, event: Event, priority: bool) -> bool",
              "docstring": "Publish an event to the bus with backpressure handling.\n\nArgs:\n    event: Event to publish\n    priority: If True, attempt to publish even at critical levels\n\nReturns:\n    True if event was published, False if dropped\n\nBackpressure behavior:\n- NORMAL: Events queued immediately\n- WARNING: Events queued with logging\n- HIGH: Rate limiting applied, delays may occur\n- CRITICAL: Low-priority events dropped, high-priority queued with delay",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                },
                {
                  "name": "priority",
                  "type": "bool"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 472
            },
            {
              "name": "_calculate_backpressure_level",
              "module": "event_bus",
              "signature": "def _calculate_backpressure_level(self) -> BackpressureLevel",
              "docstring": "Calculate current backpressure level based on queue depth.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "BackpressureLevel",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 590
            },
            {
              "name": "_apply_rate_limiting",
              "module": "event_bus",
              "signature": "async def _apply_rate_limiting(self) -> None",
              "docstring": "Apply rate limiting when queue is filling up.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 606
            },
            {
              "name": "_notify_backpressure_change",
              "module": "event_bus",
              "signature": "async def _notify_backpressure_change(self, new_level: BackpressureLevel) -> None",
              "docstring": "Notify registered callbacks of backpressure level change.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "new_level",
                  "type": "BackpressureLevel"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 625
            },
            {
              "name": "on_backpressure_change",
              "module": "event_bus",
              "signature": "def on_backpressure_change(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for backpressure level changes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 645
            },
            {
              "name": "publish_signal",
              "module": "event_bus",
              "signature": "async def publish_signal(self, signal: SignalEvent) -> None",
              "docstring": "Publish a signal event with barrier synchronization (race-condition safe).\n\nSignals are collected until barrier is complete or timeout.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signal",
                  "type": "SignalEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 652
            },
            {
              "name": "wait_for_signals",
              "module": "event_bus",
              "signature": "async def wait_for_signals(self) -> dict[str, SignalEvent]",
              "docstring": "Wait for signal barrier to complete (fan-in, race-condition safe).\n\nCalled by CIO agent before making decisions.\nThe barrier is atomically consumed and reset to prevent race conditions\nwhere late signals go to the wrong barrier.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, SignalEvent]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 677
            },
            {
              "name": "get_barrier_status",
              "module": "event_bus",
              "signature": "async def get_barrier_status(self) -> dict[str, Any]",
              "docstring": "Get current barrier status for debugging/monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 709
            },
            {
              "name": "recover_persisted_events",
              "module": "event_bus",
              "signature": "async def recover_persisted_events(self) -> int",
              "docstring": "Recover and replay persisted events from the last session (#S4).\n\nShould be called before start() to ensure unprocessed events are handled.\n\nReturns:\n    Number of events recovered and re-queued",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 732
            },
            {
              "name": "start",
              "module": "event_bus",
              "signature": "async def start(self) -> None",
              "docstring": "Start the event bus processing loop.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 786
            },
            {
              "name": "stop",
              "module": "event_bus",
              "signature": "async def stop(self) -> None",
              "docstring": "Stop the event bus gracefully.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 828
            },
            {
              "name": "_dispatch",
              "module": "event_bus",
              "signature": "async def _dispatch(self, event: Event) -> None",
              "docstring": "Dispatch event to all subscribed handlers with latency tracking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 857
            },
            {
              "name": "get_event_history",
              "module": "event_bus",
              "signature": "def get_event_history(self, event_type: , limit: int) -> list[Event]",
              "docstring": "Get recent event history for audit.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_type",
                  "type": ""
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[Event]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 917
            },
            {
              "name": "queue_size",
              "module": "event_bus",
              "signature": "def queue_size(self) -> int",
              "docstring": "Current queue size.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 931
            },
            {
              "name": "is_running",
              "module": "event_bus",
              "signature": "def is_running(self) -> bool",
              "docstring": "Check if event bus is running.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 936
            },
            {
              "name": "backpressure_level",
              "module": "event_bus",
              "signature": "def backpressure_level(self) -> BackpressureLevel",
              "docstring": "Current backpressure level.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "BackpressureLevel",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 941
            },
            {
              "name": "metrics",
              "module": "event_bus",
              "signature": "def metrics(self) -> BackpressureMetrics",
              "docstring": "Get current backpressure metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "BackpressureMetrics",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 946
            },
            {
              "name": "get_status",
              "module": "event_bus",
              "signature": "def get_status(self) -> dict",
              "docstring": "Get comprehensive event bus status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 951
            },
            {
              "name": "persistence",
              "module": "event_bus",
              "signature": "def persistence(self) -> EventPersistence | None",
              "docstring": "Get the persistence layer (if enabled).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "EventPersistence | None",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 996
            },
            {
              "name": "reset_metrics",
              "module": "event_bus",
              "signature": "def reset_metrics(self) -> None",
              "docstring": "Reset backpressure metrics (useful for testing or periodic reset).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1000
            },
            {
              "name": "_run_health_check_loop",
              "module": "event_bus",
              "signature": "async def _run_health_check_loop(self) -> None",
              "docstring": "Run periodic health checks in background.\n\nThis loop monitors the EventBus health and triggers recovery\nif the bus becomes unresponsive or unhealthy.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1010
            },
            {
              "name": "check_health",
              "module": "event_bus",
              "signature": "async def check_health(self) -> HealthCheckResult",
              "docstring": "Perform a health check on the EventBus.\n\nChecks:\n1. Processing latency is within acceptable bounds\n2. Queue is not stalled (events are being processed)\n3. Consecutive error count is below threshold\n\nReturns:\n    HealthCheckResult with status and diagnostics",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "HealthCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1046
            },
            {
              "name": "_attempt_recovery",
              "module": "event_bus",
              "signature": "async def _attempt_recovery(self) -> bool",
              "docstring": "Attempt to recover an unhealthy EventBus.\n\nRecovery steps:\n1. Clear any stuck events from the queue (preserving high-priority)\n2. Reset error counters\n3. Optionally restart processing\n\nReturns:\n    True if recovery succeeded, False otherwise",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 1105
            },
            {
              "name": "on_health_change",
              "module": "event_bus",
              "signature": "def on_health_change(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for health status changes.\n\nArgs:\n    callback: Function to call with HealthCheckResult on each check",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1185
            },
            {
              "name": "health_status",
              "module": "event_bus",
              "signature": "def health_status(self) -> EventBusHealthStatus",
              "docstring": "Get current health status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "EventBusHealthStatus",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 1195
            },
            {
              "name": "is_healthy",
              "module": "event_bus",
              "signature": "def is_healthy(self) -> bool",
              "docstring": "Check if EventBus is in healthy state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 1200
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 236
        }
      ],
      "functions": [],
      "constants": [
        {
          "name": "HIGH_PRIORITY_EVENT_TYPES",
          "line": 135
        }
      ],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "collections",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.events",
        "core.event_persistence",
        "core.event_persistence"
      ],
      "dependencies": [
        "__future__",
        "core.events",
        "core.event_persistence",
        "core.event_persistence"
      ]
    },
    "core.event_persistence": {
      "name": "event_persistence",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\event_persistence.py",
      "docstring": "Event Persistence Layer\n=======================\n\nPersists unprocessed events to disk to prevent data loss on restart.\nAddresses issue #S4: Event bus doesn't persist unprocessed events.\n\nFeatures:\n- SQLite-based persistence for durability\n- Write-ahead logging for crash safety\n- Automatic cleanup of processed events\n- Recovery of unprocessed events on startup\n- Support for event priority ordering",
      "classes": [
        {
          "name": "EventStatus",
          "module": "event_persistence",
          "docstring": "Status of persisted event.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 60
        },
        {
          "name": "PersistedEvent",
          "module": "event_persistence",
          "docstring": "Wrapper for persisted event with metadata.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "id",
              "type": "int"
            },
            {
              "name": "event_id",
              "type": "str"
            },
            {
              "name": "event_type",
              "type": "str"
            },
            {
              "name": "event_data",
              "type": "dict[str, Any]"
            },
            {
              "name": "status",
              "type": "EventStatus"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "processed_at",
              "type": ""
            },
            {
              "name": "retry_count",
              "type": "int"
            },
            {
              "name": "priority",
              "type": "bool"
            },
            {
              "name": "error_message",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 69
        },
        {
          "name": "PersistenceConfig",
          "module": "event_persistence",
          "docstring": "Configuration for event persistence.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "db_path",
              "type": "str"
            },
            {
              "name": "enable_wal",
              "type": "bool"
            },
            {
              "name": "checkpoint_interval_seconds",
              "type": "int"
            },
            {
              "name": "cleanup_completed_after_hours",
              "type": "int"
            },
            {
              "name": "max_retry_count",
              "type": "int"
            },
            {
              "name": "persist_market_data",
              "type": "bool"
            },
            {
              "name": "batch_insert_size",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 84
        },
        {
          "name": "EventPersistence",
          "module": "event_persistence",
          "docstring": "Event persistence layer using SQLite.\n\nProvides durability for events to prevent loss on system restart.\nUses WAL mode for better concurrent performance.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "event_persistence",
              "signature": "def __init__(self, config: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 103
            },
            {
              "name": "initialize",
              "module": "event_persistence",
              "signature": "def initialize(self) -> None",
              "docstring": "Initialize the database and create tables if needed.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 113
            },
            {
              "name": "_get_connection",
              "module": "event_persistence",
              "signature": "def _get_connection(self) -> Generator[sqlite3.Connection, None, None]",
              "docstring": "Get a database connection (thread-safe).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Generator[sqlite3.Connection, None, None]",
              "raises": [],
              "examples": [],
              "decorators": [
                "contextmanager"
              ],
              "is_async": false,
              "line_number": 161
            },
            {
              "name": "persist_event",
              "module": "event_persistence",
              "signature": "def persist_event(self, event: Event, priority: bool) -> bool",
              "docstring": "Persist an event to the database.\n\nArgs:\n    event: Event to persist\n    priority: If True, mark as high priority\n\nReturns:\n    True if persisted successfully, False otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                },
                {
                  "name": "priority",
                  "type": "bool"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 173
            },
            {
              "name": "persist_event_async",
              "module": "event_persistence",
              "signature": "async def persist_event_async(self, event: Event, priority: bool) -> bool",
              "docstring": "Async version of persist_event using run_in_executor.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                },
                {
                  "name": "priority",
                  "type": "bool"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 215
            },
            {
              "name": "mark_processing",
              "module": "event_persistence",
              "signature": "def mark_processing(self, event_id: str) -> bool",
              "docstring": "Mark an event as being processed.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 220
            },
            {
              "name": "mark_completed",
              "module": "event_persistence",
              "signature": "def mark_completed(self, event_id: str) -> bool",
              "docstring": "Mark an event as completed (processed successfully).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 240
            },
            {
              "name": "mark_completed_async",
              "module": "event_persistence",
              "signature": "async def mark_completed_async(self, event_id: str) -> bool",
              "docstring": "Async version of mark_completed.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 262
            },
            {
              "name": "mark_failed",
              "module": "event_persistence",
              "signature": "def mark_failed(self, event_id: str, error_message: str) -> bool",
              "docstring": "Mark an event as failed with error message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_id",
                  "type": "str"
                },
                {
                  "name": "error_message",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 267
            },
            {
              "name": "get_pending_events",
              "module": "event_persistence",
              "signature": "def get_pending_events(self, limit: int, include_failed: bool) -> list[PersistedEvent]",
              "docstring": "Get pending events for processing.\n\nArgs:\n    limit: Maximum number of events to return\n    include_failed: Include failed events that can be retried\n\nReturns:\n    List of persisted events ordered by priority and creation time",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit",
                  "type": "int"
                },
                {
                  "name": "include_failed",
                  "type": "bool"
                }
              ],
              "return_type": "list[PersistedEvent]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 294
            },
            {
              "name": "reconstruct_event",
              "module": "event_persistence",
              "signature": "def reconstruct_event(self, persisted: PersistedEvent)",
              "docstring": "Reconstruct an Event object from persisted data.\n\nArgs:\n    persisted: Persisted event data\n\nReturns:\n    Reconstructed Event or None if reconstruction fails",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "persisted",
                  "type": "PersistedEvent"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 354
            },
            {
              "name": "cleanup_completed_events",
              "module": "event_persistence",
              "signature": "def cleanup_completed_events(self, hours: ) -> int",
              "docstring": "Clean up completed events older than the specified hours.\n\nArgs:\n    hours: Hours to keep completed events (uses config default if None)\n\nReturns:\n    Number of events deleted",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hours",
                  "type": ""
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 589
            },
            {
              "name": "get_statistics",
              "module": "event_persistence",
              "signature": "def get_statistics(self) -> dict[str, Any]",
              "docstring": "Get persistence statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 620
            },
            {
              "name": "reset_stale_processing",
              "module": "event_persistence",
              "signature": "def reset_stale_processing(self, timeout_minutes: int) -> int",
              "docstring": "Reset events stuck in 'processing' status back to 'pending'.\n\nThis handles cases where a process crashed while processing an event.\n\nArgs:\n    timeout_minutes: Minutes after which processing is considered stale\n\nReturns:\n    Number of events reset",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "timeout_minutes",
                  "type": "int"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 661
            },
            {
              "name": "close",
              "module": "event_persistence",
              "signature": "def close(self) -> None",
              "docstring": "Close the database connection.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 699
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 95
        }
      ],
      "functions": [
        {
          "name": "get_event_persistence",
          "module": "event_persistence",
          "signature": "def get_event_persistence(config: ) -> EventPersistence",
          "docstring": "Get or create the global event persistence instance.",
          "parameters": [
            {
              "name": "config",
              "type": ""
            }
          ],
          "return_type": "EventPersistence",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 712
        },
        {
          "name": "reset_event_persistence",
          "module": "event_persistence",
          "signature": "def reset_event_persistence() -> None",
          "docstring": "Reset the global event persistence instance (for testing).",
          "parameters": [],
          "return_type": "None",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 721
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "json",
        "logging",
        "sqlite3",
        "threading",
        "contextlib",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing",
        "core.events"
      ],
      "dependencies": [
        "__future__",
        "sqlite3",
        "threading",
        "contextlib",
        "core.events"
      ]
    },
    "core.execution_benchmark": {
      "name": "execution_benchmark",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\execution_benchmark.py",
      "docstring": "Execution Benchmark Comparison Module\n=====================================\n\nAddresses issues:\n- #E32: No execution benchmark comparison\n- #E33: Missing execution alert system\n\nFeatures:\n- Multiple benchmark comparisons (VWAP, TWAP, arrival price)\n- Real-time execution quality monitoring\n- Automated alerting on poor execution\n- Historical comparison analysis",
      "classes": [
        {
          "name": "ExecutionBenchmark",
          "module": "execution_benchmark",
          "docstring": "Standard execution benchmarks.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 30
        },
        {
          "name": "ExecutionAlertLevel",
          "module": "execution_benchmark",
          "docstring": "Alert severity for execution issues.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 42
        },
        {
          "name": "BenchmarkPrice",
          "module": "execution_benchmark",
          "docstring": "A single benchmark price observation.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "benchmark",
              "type": "ExecutionBenchmark"
            },
            {
              "name": "price",
              "type": "float"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "metadata",
              "type": "dict"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 50
        },
        {
          "name": "ExecutionComparison",
          "module": "execution_benchmark",
          "docstring": "Comparison of execution against benchmarks.",
          "bases": [],
          "methods": [
            {
              "name": "vs_arrival_bps",
              "module": "execution_benchmark",
              "signature": "def vs_arrival_bps(self)",
              "docstring": "Slippage vs arrival price in bps.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 72
            },
            {
              "name": "vs_vwap_bps",
              "module": "execution_benchmark",
              "signature": "def vs_vwap_bps(self)",
              "docstring": "Slippage vs VWAP in bps.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 77
            },
            {
              "name": "best_benchmark_performance",
              "module": "execution_benchmark",
              "signature": "def best_benchmark_performance(self)",
              "docstring": "Best benchmark performance (lowest slippage).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 82
            },
            {
              "name": "worst_benchmark_performance",
              "module": "execution_benchmark",
              "signature": "def worst_benchmark_performance(self)",
              "docstring": "Worst benchmark performance (highest slippage).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 89
            },
            {
              "name": "to_dict",
              "module": "execution_benchmark",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 95
            }
          ],
          "class_attributes": [
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "fill_price",
              "type": "float"
            },
            {
              "name": "fill_time",
              "type": "datetime"
            },
            {
              "name": "benchmarks",
              "type": "dict[ExecutionBenchmark, float]"
            },
            {
              "name": "slippage_vs_benchmarks",
              "type": "dict[ExecutionBenchmark, float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 60
        },
        {
          "name": "ExecutionAlert",
          "module": "execution_benchmark",
          "docstring": "Alert for execution quality issues (#E33).",
          "bases": [],
          "methods": [
            {
              "name": "acknowledge",
              "module": "execution_benchmark",
              "signature": "def acknowledge(self, user: str) -> None",
              "docstring": "Acknowledge the alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "user",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 123
            },
            {
              "name": "to_dict",
              "module": "execution_benchmark",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 129
            }
          ],
          "class_attributes": [
            {
              "name": "alert_id",
              "type": "str"
            },
            {
              "name": "level",
              "type": "ExecutionAlertLevel"
            },
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "details",
              "type": "dict"
            },
            {
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "name": "acknowledged_by",
              "type": ""
            },
            {
              "name": "acknowledged_at",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 110
        },
        {
          "name": "ExecutionAlertThresholds",
          "module": "execution_benchmark",
          "docstring": "Configurable thresholds for execution alerts (#E33).",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "execution_benchmark",
              "signature": "def __init__(self, slippage_warning_bps: float, slippage_critical_bps: float, fill_time_warning_ms: float, fill_time_critical_ms: float, rejection_rate_warning_pct: float, rejection_rate_critical_pct: float, partial_fill_warning_pct: float, implementation_shortfall_warning_bps: float, implementation_shortfall_critical_bps: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "slippage_warning_bps",
                  "type": "float"
                },
                {
                  "name": "slippage_critical_bps",
                  "type": "float"
                },
                {
                  "name": "fill_time_warning_ms",
                  "type": "float"
                },
                {
                  "name": "fill_time_critical_ms",
                  "type": "float"
                },
                {
                  "name": "rejection_rate_warning_pct",
                  "type": "float"
                },
                {
                  "name": "rejection_rate_critical_pct",
                  "type": "float"
                },
                {
                  "name": "partial_fill_warning_pct",
                  "type": "float"
                },
                {
                  "name": "implementation_shortfall_warning_bps",
                  "type": "float"
                },
                {
                  "name": "implementation_shortfall_critical_bps",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 148
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 145
        },
        {
          "name": "ExecutionBenchmarkComparator",
          "module": "execution_benchmark",
          "docstring": "Compares execution quality against multiple benchmarks (#E32).\n\nProvides comprehensive execution analysis and tracking.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "execution_benchmark",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 178
            },
            {
              "name": "compare_execution",
              "module": "execution_benchmark",
              "signature": "def compare_execution(self, order_id: str, symbol: str, side: str, quantity: int, fill_price: float, fill_time: datetime, benchmarks: dict[ExecutionBenchmark, float]) -> ExecutionComparison",
              "docstring": "Compare an execution against benchmarks.\n\nArgs:\n    order_id: Order identifier\n    symbol: Trading symbol\n    side: 'BUY' or 'SELL'\n    quantity: Order quantity\n    fill_price: Actual fill price\n    fill_time: Fill timestamp\n    benchmarks: Dictionary of benchmark prices\n\nReturns:\n    ExecutionComparison with slippage analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "fill_price",
                  "type": "float"
                },
                {
                  "name": "fill_time",
                  "type": "datetime"
                },
                {
                  "name": "benchmarks",
                  "type": "dict[ExecutionBenchmark, float]"
                }
              ],
              "return_type": "ExecutionComparison",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 183
            },
            {
              "name": "get_aggregate_stats",
              "module": "execution_benchmark",
              "signature": "def get_aggregate_stats(self, symbol: , start_time: , end_time: ) -> dict[str, Any]",
              "docstring": "Get aggregate execution statistics.\n\nArgs:\n    symbol: Optional symbol filter\n    start_time: Optional start time filter\n    end_time: Optional end time filter\n\nReturns:\n    Dictionary of aggregate statistics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": ""
                },
                {
                  "name": "start_time",
                  "type": ""
                },
                {
                  "name": "end_time",
                  "type": ""
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 239
            },
            {
              "name": "get_symbol_ranking",
              "module": "execution_benchmark",
              "signature": "def get_symbol_ranking(self, benchmark: ExecutionBenchmark) -> list[dict]",
              "docstring": "Rank symbols by execution quality.\n\nReturns:\n    List of symbols with avg slippage, sorted best to worst",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "benchmark",
                  "type": "ExecutionBenchmark"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 314
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 171
        },
        {
          "name": "ExecutionAlertManager",
          "module": "execution_benchmark",
          "docstring": "Manages execution quality alerts (#E33).\n\nMonitors executions and generates alerts when thresholds are breached.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "execution_benchmark",
              "signature": "def __init__(self, thresholds: , alert_callback: )",
              "docstring": "Initialize alert manager.\n\nArgs:\n    thresholds: Alert thresholds\n    alert_callback: Optional callback for alerts",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "thresholds",
                  "type": ""
                },
                {
                  "name": "alert_callback",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 345
            },
            {
              "name": "check_execution",
              "module": "execution_benchmark",
              "signature": "def check_execution(self, comparison: ExecutionComparison, fill_time_ms: ) -> list[ExecutionAlert]",
              "docstring": "Check execution and generate alerts if needed.\n\nArgs:\n    comparison: Execution comparison result\n    fill_time_ms: Fill time in milliseconds\n\nReturns:\n    List of generated alerts",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "comparison",
                  "type": "ExecutionComparison"
                },
                {
                  "name": "fill_time_ms",
                  "type": ""
                }
              ],
              "return_type": "list[ExecutionAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 368
            },
            {
              "name": "check_rejection",
              "module": "execution_benchmark",
              "signature": "def check_rejection(self, order_id: str, symbol: str, reason: str, recent_rejection_rate: float)",
              "docstring": "Check for rejection rate alerts.\n\nArgs:\n    order_id: Rejected order ID\n    symbol: Symbol\n    reason: Rejection reason\n    recent_rejection_rate: Recent rejection rate (0-100)\n\nReturns:\n    Alert if threshold exceeded",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "reason",
                  "type": "str"
                },
                {
                  "name": "recent_rejection_rate",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 439
            },
            {
              "name": "check_partial_fill",
              "module": "execution_benchmark",
              "signature": "def check_partial_fill(self, order_id: str, symbol: str, filled_pct: float, elapsed_time_minutes: float)",
              "docstring": "Check for partial fill alerts.\n\nArgs:\n    order_id: Order ID\n    symbol: Symbol\n    filled_pct: Percentage filled (0-100)\n    elapsed_time_minutes: Time since order submission\n\nReturns:\n    Alert if conditions met",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "filled_pct",
                  "type": "float"
                },
                {
                  "name": "elapsed_time_minutes",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 479
            },
            {
              "name": "_create_alert",
              "module": "execution_benchmark",
              "signature": "def _create_alert(self, level: ExecutionAlertLevel, order_id: str, symbol: str, message: str, details: dict, cooldown_key: str)",
              "docstring": "Create alert with rate limiting.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "level",
                  "type": "ExecutionAlertLevel"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "details",
                  "type": "dict"
                },
                {
                  "name": "cooldown_key",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 510
            },
            {
              "name": "get_alerts",
              "module": "execution_benchmark",
              "signature": "def get_alerts(self, level: , symbol: , unacknowledged_only: bool, limit: int) -> list[ExecutionAlert]",
              "docstring": "Get alerts with optional filters.\n\nArgs:\n    level: Filter by level\n    symbol: Filter by symbol\n    unacknowledged_only: Only unacknowledged alerts\n    limit: Max alerts to return\n\nReturns:\n    List of matching alerts",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "level",
                  "type": ""
                },
                {
                  "name": "symbol",
                  "type": ""
                },
                {
                  "name": "unacknowledged_only",
                  "type": "bool"
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[ExecutionAlert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 550
            },
            {
              "name": "acknowledge_alert",
              "module": "execution_benchmark",
              "signature": "def acknowledge_alert(self, alert_id: str, user: str) -> bool",
              "docstring": "Acknowledge an alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_id",
                  "type": "str"
                },
                {
                  "name": "user",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 584
            },
            {
              "name": "get_alert_summary",
              "module": "execution_benchmark",
              "signature": "def get_alert_summary(self) -> dict",
              "docstring": "Get summary of alert counts.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 593
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 338
        },
        {
          "name": "ExecutionQualityMonitor",
          "module": "execution_benchmark",
          "docstring": "Comprehensive execution quality monitoring.\n\nCombines benchmark comparison and alerting.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "execution_benchmark",
              "signature": "def __init__(self, thresholds: , alert_callback: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "thresholds",
                  "type": ""
                },
                {
                  "name": "alert_callback",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 619
            },
            {
              "name": "record_execution",
              "module": "execution_benchmark",
              "signature": "def record_execution(self, order_id: str, symbol: str, side: str, quantity: int, fill_price: float, fill_time: datetime, benchmarks: dict[ExecutionBenchmark, float], fill_latency_ms: ) -> tuple[ExecutionComparison, list[ExecutionAlert]]",
              "docstring": "Record and analyze an execution.\n\nReturns:\n    Tuple of (comparison, alerts)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "fill_price",
                  "type": "float"
                },
                {
                  "name": "fill_time",
                  "type": "datetime"
                },
                {
                  "name": "benchmarks",
                  "type": "dict[ExecutionBenchmark, float]"
                },
                {
                  "name": "fill_latency_ms",
                  "type": ""
                }
              ],
              "return_type": "tuple[ExecutionComparison, list[ExecutionAlert]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 630
            },
            {
              "name": "get_dashboard_data",
              "module": "execution_benchmark",
              "signature": "def get_dashboard_data(self) -> dict",
              "docstring": "Get data for execution dashboard.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 666
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 612
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "threading"
      ],
      "dependencies": [
        "__future__",
        "threading"
      ]
    },
    "core.futures_roll_manager": {
      "name": "futures_roll_manager",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\futures_roll_manager.py",
      "docstring": "Futures Roll Manager\n====================\n\nManages futures contract rolling for continuous exposure.\nHandles roll schedules, roll date detection, price adjustment,\nand roll notifications.",
      "classes": [
        {
          "name": "RollMethod",
          "module": "futures_roll_manager",
          "docstring": "Method for rolling futures contracts.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 24
        },
        {
          "name": "RollStatus",
          "module": "futures_roll_manager",
          "docstring": "Current roll status for a contract.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 32
        },
        {
          "name": "RollSchedule",
          "module": "futures_roll_manager",
          "docstring": "Roll schedule configuration for a contract.",
          "bases": [],
          "methods": [
            {
              "name": "get_next_contract_month",
              "module": "futures_roll_manager",
              "signature": "def get_next_contract_month(self, current_month: str, current_year: int) -> tuple[str, int]",
              "docstring": "Get next contract month after current.\n\nArgs:\n    current_month: Current month code (e.g., \"H\")\n    current_year: Current year\n\nReturns:\n    Tuple of (next_month_code, year)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_month",
                  "type": "str"
                },
                {
                  "name": "current_year",
                  "type": "int"
                }
              ],
              "return_type": "tuple[str, int]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 55
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "roll_days_before_expiry",
              "type": "int"
            },
            {
              "name": "roll_window_days",
              "type": "int"
            },
            {
              "name": "roll_method",
              "type": "RollMethod"
            },
            {
              "name": "contract_months",
              "type": "tuple[str, Ellipsis]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 41
        },
        {
          "name": "FNDViolationLevel",
          "module": "futures_roll_manager",
          "docstring": "Level of FND (First Notice Date) violation risk.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 235
        },
        {
          "name": "FNDStatus",
          "module": "futures_roll_manager",
          "docstring": "First Notice Date status for a contract.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "contract_code",
              "type": "str"
            },
            {
              "name": "is_physical_delivery",
              "type": "bool"
            },
            {
              "name": "first_notice_date",
              "type": ""
            },
            {
              "name": "days_to_fnd",
              "type": ""
            },
            {
              "name": "violation_level",
              "type": "FNDViolationLevel"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "requires_action",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 244
        },
        {
          "name": "ContractInfo",
          "module": "futures_roll_manager",
          "docstring": "Information about a specific contract.",
          "bases": [],
          "methods": [
            {
              "name": "is_expired",
              "module": "futures_roll_manager",
              "signature": "def is_expired(self) -> bool",
              "docstring": "Check if contract is expired.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 267
            },
            {
              "name": "days_to_expiry",
              "module": "futures_roll_manager",
              "signature": "def days_to_expiry(self) -> int",
              "docstring": "Days until expiry.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 272
            },
            {
              "name": "days_to_fnd",
              "module": "futures_roll_manager",
              "signature": "def days_to_fnd(self)",
              "docstring": "Days until First Notice Date.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 277
            },
            {
              "name": "is_physical_delivery",
              "module": "futures_roll_manager",
              "signature": "def is_physical_delivery(self) -> bool",
              "docstring": "Check if this is a physical delivery contract.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 284
            },
            {
              "name": "is_past_fnd",
              "module": "futures_roll_manager",
              "signature": "def is_past_fnd(self) -> bool",
              "docstring": "Check if we're past First Notice Date.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 290
            },
            {
              "name": "to_dict",
              "module": "futures_roll_manager",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 296
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "contract_code",
              "type": "str"
            },
            {
              "name": "month_code",
              "type": "str"
            },
            {
              "name": "year",
              "type": "int"
            },
            {
              "name": "expiry_date",
              "type": "date"
            },
            {
              "name": "first_notice_date",
              "type": ""
            },
            {
              "name": "last_trading_date",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 256
        },
        {
          "name": "RollEvent",
          "module": "futures_roll_manager",
          "docstring": "Event representing a roll signal or completion.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "futures_roll_manager",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary for logging.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 325
            }
          ],
          "class_attributes": [
            {
              "name": "event_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "event_type",
              "type": "str"
            },
            {
              "name": "from_contract",
              "type": "str"
            },
            {
              "name": "to_contract",
              "type": "str"
            },
            {
              "name": "price_adjustment",
              "type": "float"
            },
            {
              "name": "details",
              "type": "dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 314
        },
        {
          "name": "FuturesRollManager",
          "module": "futures_roll_manager",
          "docstring": "Manages futures contract rolling.\n\nFeatures:\n- Automatic roll date detection\n- Roll signal generation\n- Continuous contract price adjustment\n- Roll event notifications",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "futures_roll_manager",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize roll manager.\n\nArgs:\n    config: Configuration with:\n        - enabled: Enable auto-roll detection (default: True)\n        - auto_roll: Automatically generate roll signals (default: True)\n        - custom_schedules: Override default roll schedules",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 440
            },
            {
              "name": "register_callback",
              "module": "futures_roll_manager",
              "signature": "def register_callback(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for roll events.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 477
            },
            {
              "name": "set_current_contract",
              "module": "futures_roll_manager",
              "signature": "def set_current_contract(self, symbol: str, contract_code: str, expiry_date: date, first_notice_date: ) -> None",
              "docstring": "Set the current active contract for a symbol.\n\nArgs:\n    symbol: Base symbol (e.g., \"ES\", \"NG\", \"RTY\")\n    contract_code: Full contract code (e.g., \"ESH25\", \"NGF25\", \"RTYZ24\")\n    expiry_date: Contract expiry date\n    first_notice_date: First notice date for physical delivery",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                },
                {
                  "name": "expiry_date",
                  "type": "date"
                },
                {
                  "name": "first_notice_date",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 481
            },
            {
              "name": "check_roll_status",
              "module": "futures_roll_manager",
              "signature": "def check_roll_status(self, symbol: str) -> RollStatus",
              "docstring": "Check if a contract needs to be rolled.\n\nArgs:\n    symbol: Base symbol\n\nReturns:\n    Current roll status",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "RollStatus",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 537
            },
            {
              "name": "_handle_status_change",
              "module": "futures_roll_manager",
              "signature": "def _handle_status_change(self, symbol: str, old_status: RollStatus, new_status: RollStatus) -> None",
              "docstring": "Handle roll status change.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "old_status",
                  "type": "RollStatus"
                },
                {
                  "name": "new_status",
                  "type": "RollStatus"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 583
            },
            {
              "name": "_generate_roll_event",
              "module": "futures_roll_manager",
              "signature": "def _generate_roll_event(self, symbol: str, event_type: str, details: ) -> RollEvent",
              "docstring": "Generate and dispatch a roll event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "details",
                  "type": ""
                }
              ],
              "return_type": "RollEvent",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 613
            },
            {
              "name": "complete_roll",
              "module": "futures_roll_manager",
              "signature": "def complete_roll(self, symbol: str, new_contract_code: str, new_expiry_date: date, roll_price_adjustment: float, first_notice_date: ) -> RollEvent",
              "docstring": "Complete a roll to a new contract.\n\nArgs:\n    symbol: Base symbol\n    new_contract_code: New contract code\n    new_expiry_date: New expiry date\n    roll_price_adjustment: Price adjustment for continuous pricing\n    first_notice_date: First notice date for new contract\n\nReturns:\n    Roll completion event",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "new_contract_code",
                  "type": "str"
                },
                {
                  "name": "new_expiry_date",
                  "type": "date"
                },
                {
                  "name": "roll_price_adjustment",
                  "type": "float"
                },
                {
                  "name": "first_notice_date",
                  "type": ""
                }
              ],
              "return_type": "RollEvent",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 660
            },
            {
              "name": "get_continuous_price",
              "module": "futures_roll_manager",
              "signature": "def get_continuous_price(self, symbol: str, raw_price: float) -> float",
              "docstring": "Get continuous contract adjusted price.\n\nArgs:\n    symbol: Contract symbol\n    raw_price: Raw price from current contract\n\nReturns:\n    Adjusted continuous price",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "raw_price",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 727
            },
            {
              "name": "get_raw_price",
              "module": "futures_roll_manager",
              "signature": "def get_raw_price(self, symbol: str, continuous_price: float) -> float",
              "docstring": "Convert continuous price back to raw price.\n\nArgs:\n    symbol: Contract symbol\n    continuous_price: Adjusted continuous price\n\nReturns:\n    Raw price in current contract",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "continuous_price",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 741
            },
            {
              "name": "get_current_contract",
              "module": "futures_roll_manager",
              "signature": "def get_current_contract(self, symbol: str)",
              "docstring": "Get current contract info for symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 755
            },
            {
              "name": "get_roll_schedule",
              "module": "futures_roll_manager",
              "signature": "def get_roll_schedule(self, symbol: str)",
              "docstring": "Get roll schedule for symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 759
            },
            {
              "name": "get_contracts_approaching_roll",
              "module": "futures_roll_manager",
              "signature": "def get_contracts_approaching_roll(self) -> list[ContractInfo]",
              "docstring": "Get list of contracts approaching roll.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[ContractInfo]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 763
            },
            {
              "name": "get_roll_history",
              "module": "futures_roll_manager",
              "signature": "def get_roll_history(self, symbol: , limit: int) -> list[RollEvent]",
              "docstring": "Get roll event history.\n\nArgs:\n    symbol: Filter by symbol (optional)\n    limit: Maximum events to return\n\nReturns:\n    List of roll events",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": ""
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[RollEvent]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 772
            },
            {
              "name": "check_all_contracts",
              "module": "futures_roll_manager",
              "signature": "def check_all_contracts(self) -> dict[str, RollStatus]",
              "docstring": "Check roll status for all tracked contracts.\n\nReturns:\n    Dictionary of symbol to roll status",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, RollStatus]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 794
            },
            {
              "name": "check_fnd_status",
              "module": "futures_roll_manager",
              "signature": "def check_fnd_status(self, symbol: str, has_position: bool, warning_days: int) -> FNDStatus",
              "docstring": "Check First Notice Date status for a contract.\n\nCRITICAL: Physical delivery contracts must be closed before FND\nto avoid delivery obligations. This is especially important for\nretail/prop traders who cannot take physical delivery.\n\nArgs:\n    symbol: Contract symbol\n    has_position: Whether we currently have a position\n    warning_days: Days before FND to start warning\n\nReturns:\n    FNDStatus with violation level and required action",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "has_position",
                  "type": "bool"
                },
                {
                  "name": "warning_days",
                  "type": "int"
                }
              ],
              "return_type": "FNDStatus",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 806
            },
            {
              "name": "can_hold_position",
              "module": "futures_roll_manager",
              "signature": "def can_hold_position(self, symbol: str) -> tuple[bool, str]",
              "docstring": "Check if it's safe to hold a position in this contract.\n\nEnforces FND rules for physical delivery contracts.\n\nArgs:\n    symbol: Contract symbol\n\nReturns:\n    Tuple of (can_hold, reason)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 902
            },
            {
              "name": "can_open_position",
              "module": "futures_roll_manager",
              "signature": "def can_open_position(self, symbol: str) -> tuple[bool, str]",
              "docstring": "Check if it's safe to open a new position in this contract.\n\nMore restrictive than can_hold_position - prevents opening\npositions too close to FND.\n\nArgs:\n    symbol: Contract symbol\n\nReturns:\n    Tuple of (can_open, reason)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 924
            },
            {
              "name": "get_fnd_violations",
              "module": "futures_roll_manager",
              "signature": "def get_fnd_violations(self, positions: dict[str, float]) -> list[FNDStatus]",
              "docstring": "Check all positions for FND violations.\n\nArgs:\n    positions: Dictionary of symbol -> position quantity\n\nReturns:\n    List of FNDStatus for contracts with violations/warnings",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "list[FNDStatus]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 957
            },
            {
              "name": "get_status",
              "module": "futures_roll_manager",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get manager status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 987
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 429
        },
        {
          "name": "BasisSpread",
          "module": "futures_roll_manager",
          "docstring": "Tracks basis between spot and futures or between contract months (#F5).",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "futures_roll_manager",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1456
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "front_contract",
              "type": "str"
            },
            {
              "name": "back_contract",
              "type": "str"
            },
            {
              "name": "front_price",
              "type": "float"
            },
            {
              "name": "back_price",
              "type": "float"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "spread",
              "type": "float"
            },
            {
              "name": "spread_pct",
              "type": "float"
            },
            {
              "name": "annualized_spread",
              "type": "float"
            },
            {
              "name": "days_between",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1443
        },
        {
          "name": "BasisTracker",
          "module": "futures_roll_manager",
          "docstring": "Tracks basis and calendar spreads for futures (#F5).\n\nMonitors:\n- Spot vs front-month basis (contango/backwardation)\n- Calendar spreads between contract months\n- Roll yield opportunities",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "futures_roll_manager",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1476
            },
            {
              "name": "update_spot_price",
              "module": "futures_roll_manager",
              "signature": "def update_spot_price(self, symbol: str, price: float) -> None",
              "docstring": "Update spot price for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1482
            },
            {
              "name": "update_futures_price",
              "module": "futures_roll_manager",
              "signature": "def update_futures_price(self, symbol: str, contract: str, price: float) -> None",
              "docstring": "Update futures price for a contract.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "contract",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1486
            },
            {
              "name": "calculate_spot_basis",
              "module": "futures_roll_manager",
              "signature": "def calculate_spot_basis(self, symbol: str, front_contract: str)",
              "docstring": "Calculate basis between spot and front month (#F5).\n\nReturns:\n    BasisSpread or None if prices not available",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "front_contract",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1492
            },
            {
              "name": "calculate_calendar_spread",
              "module": "futures_roll_manager",
              "signature": "def calculate_calendar_spread(self, symbol: str, front_contract: str, back_contract: str, days_between: int)",
              "docstring": "Calculate calendar spread between two contract months (#F5).\n\nArgs:\n    symbol: Base symbol\n    front_contract: Front month contract code\n    back_contract: Back month contract code\n    days_between: Approximate days between expiries\n\nReturns:\n    BasisSpread or None if prices not available",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "front_contract",
                  "type": "str"
                },
                {
                  "name": "back_contract",
                  "type": "str"
                },
                {
                  "name": "days_between",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1525
            },
            {
              "name": "get_term_structure",
              "module": "futures_roll_manager",
              "signature": "def get_term_structure(self, symbol: str) -> dict",
              "docstring": "Get full term structure for a symbol (#F5).\n\nReturns prices and spreads across all contract months.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1570
            },
            {
              "name": "detect_roll_yield_opportunity",
              "module": "futures_roll_manager",
              "signature": "def detect_roll_yield_opportunity(self, symbol: str, threshold_bps: float)",
              "docstring": "Detect roll yield opportunities (#F5).\n\nIdentifies when calendar spread offers significant carry.\n\nArgs:\n    symbol: Symbol to analyze\n    threshold_bps: Minimum annualized spread in bps to flag\n\nReturns:\n    Opportunity details or None",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "threshold_bps",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1614
            },
            {
              "name": "get_basis_statistics",
              "module": "futures_roll_manager",
              "signature": "def get_basis_statistics(self, symbol: str, lookback: int) -> dict",
              "docstring": "Get basis statistics for monitoring.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "lookback",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1653
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1466
        },
        {
          "name": "DeliveryMonthValidator",
          "module": "futures_roll_manager",
          "docstring": "Validates delivery month matches between internal specs and IB (#F6).\n\nPrevents mismatches that could lead to wrong contract trading.",
          "bases": [],
          "methods": [
            {
              "name": "validate_contract_month",
              "module": "futures_roll_manager",
              "signature": "def validate_contract_month(cls, symbol: str, month_code: str, source: str) -> dict",
              "docstring": "Validate if month code is valid for symbol (#F6).\n\nArgs:\n    symbol: Contract symbol\n    month_code: Month code to validate\n    source: Source of the month code\n\nReturns:\n    Validation result",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "month_code",
                  "type": "str"
                },
                {
                  "name": "source",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 1720
            },
            {
              "name": "validate_roll_schedule",
              "module": "futures_roll_manager",
              "signature": "def validate_roll_schedule(cls, symbol: str) -> dict",
              "docstring": "Validate roll schedule matches IB contract months (#F6).\n\nArgs:\n    symbol: Contract symbol to validate\n\nReturns:\n    Validation result with any mismatches",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 1767
            },
            {
              "name": "validate_all_schedules",
              "module": "futures_roll_manager",
              "signature": "def validate_all_schedules(cls) -> list[dict]",
              "docstring": "Validate all roll schedules against IB (#F6).",
              "parameters": [
                {
                  "name": "cls"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 1815
            }
          ],
          "class_attributes": [
            {
              "name": "IB_CONTRACT_MONTHS",
              "type": "dict[str, tuple[str, Ellipsis]]"
            }
          ],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1690
        },
        {
          "name": "ExpirationWarning",
          "module": "futures_roll_manager",
          "docstring": "Warning about approaching contract expiration (#F7).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "contract_code",
              "type": "str"
            },
            {
              "name": "days_to_expiry",
              "type": "int"
            },
            {
              "name": "days_to_fnd",
              "type": ""
            },
            {
              "name": "warning_level",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "position_size",
              "type": "int"
            },
            {
              "name": "recommended_action",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1830
        },
        {
          "name": "ExpirationWarningSystem",
          "module": "futures_roll_manager",
          "docstring": "Monitors and alerts on approaching expirations (#F7).\n\nProvides tiered warnings:\n- INFO: 14+ days out\n- WARNING: 7-14 days out\n- CRITICAL: <7 days out",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "futures_roll_manager",
              "signature": "def __init__(self, warning_days: int, critical_days: int, fnd_buffer_days: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "warning_days",
                  "type": "int"
                },
                {
                  "name": "critical_days",
                  "type": "int"
                },
                {
                  "name": "fnd_buffer_days",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1853
            },
            {
              "name": "check_expiration",
              "module": "futures_roll_manager",
              "signature": "def check_expiration(self, symbol: str, contract_code: str, days_to_expiry: int, days_to_fnd: , position_size: int, is_physical_delivery: bool)",
              "docstring": "Check if expiration warning should be issued (#F7).\n\nArgs:\n    symbol: Base symbol\n    contract_code: Full contract code\n    days_to_expiry: Days until expiration\n    days_to_fnd: Days until first notice (physical delivery)\n    position_size: Current position size\n    is_physical_delivery: Whether contract has physical delivery\n\nReturns:\n    ExpirationWarning if warning needed",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                },
                {
                  "name": "days_to_expiry",
                  "type": "int"
                },
                {
                  "name": "days_to_fnd",
                  "type": ""
                },
                {
                  "name": "position_size",
                  "type": "int"
                },
                {
                  "name": "is_physical_delivery",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1865
            },
            {
              "name": "check_all_positions",
              "module": "futures_roll_manager",
              "signature": "def check_all_positions(self, positions: dict[str, int], roll_manager: FuturesRollManager) -> list[ExpirationWarning]",
              "docstring": "Check all positions for expiration warnings (#F7).\n\nArgs:\n    positions: Map of contract codes to position sizes\n    roll_manager: Roll manager for contract info\n\nReturns:\n    List of warnings",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, int]"
                },
                {
                  "name": "roll_manager",
                  "type": "FuturesRollManager"
                }
              ],
              "return_type": "list[ExpirationWarning]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1942
            },
            {
              "name": "acknowledge_warning",
              "module": "futures_roll_manager",
              "signature": "def acknowledge_warning(self, contract_code: str) -> None",
              "docstring": "Acknowledge a warning to suppress repeat alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1985
            },
            {
              "name": "get_active_warnings",
              "module": "futures_roll_manager",
              "signature": "def get_active_warnings(self, level: ) -> list[ExpirationWarning]",
              "docstring": "Get active warnings, optionally filtered by level.\n\nArgs:\n    level: Filter by level (\"INFO\", \"WARNING\", \"CRITICAL\") or None for all\n\nReturns:\n    List of active warnings",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "level",
                  "type": ""
                }
              ],
              "return_type": "list[ExpirationWarning]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1989
            },
            {
              "name": "get_summary",
              "module": "futures_roll_manager",
              "signature": "def get_summary(self) -> dict",
              "docstring": "Get warning summary for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2004
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1843
        },
        {
          "name": "SettlementPrice",
          "module": "futures_roll_manager",
          "docstring": "Settlement price data for a contract (#F8).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "contract_code",
              "type": "str"
            },
            {
              "name": "settlement_date",
              "type": "date"
            },
            {
              "name": "settlement_price",
              "type": "float"
            },
            {
              "name": "settlement_type",
              "type": "str"
            },
            {
              "name": "volume",
              "type": ""
            },
            {
              "name": "open_interest",
              "type": ""
            },
            {
              "name": "source",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 2021
        },
        {
          "name": "SettlementPriceManager",
          "module": "futures_roll_manager",
          "docstring": "Manages settlement prices for futures (#F8).\n\nHandles:\n- Daily settlement prices for mark-to-market\n- Final settlement prices for expiring contracts\n- Settlement price history",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "futures_roll_manager",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2043
            },
            {
              "name": "record_daily_settlement",
              "module": "futures_roll_manager",
              "signature": "def record_daily_settlement(self, symbol: str, contract_code: str, settlement_date: date, settlement_price: float, volume: , open_interest: ) -> SettlementPrice",
              "docstring": "Record daily settlement price (#F8).\n\nArgs:\n    symbol: Base symbol\n    contract_code: Full contract code\n    settlement_date: Date of settlement\n    settlement_price: Settlement price\n    volume: Trading volume\n    open_interest: Open interest\n\nReturns:\n    SettlementPrice record",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                },
                {
                  "name": "settlement_date",
                  "type": "date"
                },
                {
                  "name": "settlement_price",
                  "type": "float"
                },
                {
                  "name": "volume",
                  "type": ""
                },
                {
                  "name": "open_interest",
                  "type": ""
                }
              ],
              "return_type": "SettlementPrice",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2048
            },
            {
              "name": "record_final_settlement",
              "module": "futures_roll_manager",
              "signature": "def record_final_settlement(self, symbol: str, contract_code: str, settlement_date: date, settlement_price: float) -> SettlementPrice",
              "docstring": "Record final settlement price at expiration (#F8).\n\nArgs:\n    symbol: Base symbol\n    contract_code: Full contract code\n    settlement_date: Final settlement date\n    settlement_price: Final settlement price\n\nReturns:\n    SettlementPrice record",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                },
                {
                  "name": "settlement_date",
                  "type": "date"
                },
                {
                  "name": "settlement_price",
                  "type": "float"
                }
              ],
              "return_type": "SettlementPrice",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2091
            },
            {
              "name": "get_latest_settlement",
              "module": "futures_roll_manager",
              "signature": "def get_latest_settlement(self, contract_code: str)",
              "docstring": "Get most recent settlement price for a contract.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2129
            },
            {
              "name": "get_final_settlement",
              "module": "futures_roll_manager",
              "signature": "def get_final_settlement(self, contract_code: str)",
              "docstring": "Get final settlement price if contract has expired.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2133
            },
            {
              "name": "calculate_mark_to_market",
              "module": "futures_roll_manager",
              "signature": "def calculate_mark_to_market(self, contract_code: str, position: int, entry_price: float)",
              "docstring": "Calculate mark-to-market P&L using settlement price (#F8).\n\nArgs:\n    contract_code: Contract code\n    position: Number of contracts (positive=long, negative=short)\n    entry_price: Average entry price\n\nReturns:\n    MTM calculation or None if no settlement",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                },
                {
                  "name": "position",
                  "type": "int"
                },
                {
                  "name": "entry_price",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2137
            },
            {
              "name": "get_settlement_history",
              "module": "futures_roll_manager",
              "signature": "def get_settlement_history(self, contract_code: str, lookback_days: int) -> list[dict]",
              "docstring": "Get settlement price history for a contract.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract_code",
                  "type": "str"
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2181
            },
            {
              "name": "calculate_variation_margin",
              "module": "futures_roll_manager",
              "signature": "def calculate_variation_margin(self, positions: dict[str, tuple[int, float]]) -> dict",
              "docstring": "Calculate total variation margin requirement (#F8).\n\nArgs:\n    positions: Map of contract codes to (position, entry_price) tuples\n\nReturns:\n    Variation margin calculation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, tuple[int, float]]"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2202
            },
            {
              "name": "get_status",
              "module": "futures_roll_manager",
              "signature": "def get_status(self) -> dict",
              "docstring": "Get manager status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 2231
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 2033
        }
      ],
      "functions": [
        {
          "name": "parse_contract_code",
          "module": "futures_roll_manager",
          "signature": "def parse_contract_code(contract_code: str)",
          "docstring": "Parse futures contract code into root symbol, month code, and year.\n\nHandles multiple formats (#F2):\n- \"ESZ4\"   -> (\"ES\", \"Z\", 2024)   2-letter symbol + month + 1-digit year\n- \"ESZ24\"  -> (\"ES\", \"Z\", 2024)   2-letter symbol + month + 2-digit year\n- \"NGF25\"  -> (\"NG\", \"F\", 2025)   2-letter symbol + month + 2-digit year\n- \"RTYZ4\"  -> (\"RTY\", \"Z\", 2024)  3-letter symbol + month + 1-digit year\n- \"RTYZ24\" -> (\"RTY\", \"Z\", 2024)  3-letter symbol + month + 2-digit year\n\nArgs:\n    contract_code: Full contract code string\n\nReturns:\n    Tuple of (root_symbol, month_code, year) or None if parsing fails",
          "parameters": [
            {
              "name": "contract_code",
              "type": "str"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 339
        },
        {
          "name": "format_contract_code",
          "module": "futures_roll_manager",
          "signature": "def format_contract_code(root_symbol: str, month_code: str, year: int, two_digit_year: bool) -> str",
          "docstring": "Format a contract code from components.\n\nArgs:\n    root_symbol: Root symbol (e.g., \"ES\", \"NG\", \"RTY\")\n    month_code: Month code (e.g., \"Z\", \"F\")\n    year: Full year (e.g., 2024)\n    two_digit_year: If True, use 2-digit year (e.g., \"24\"), else 1-digit\n\nReturns:\n    Formatted contract code (e.g., \"ESZ4\" or \"ESZ24\")",
          "parameters": [
            {
              "name": "root_symbol",
              "type": "str"
            },
            {
              "name": "month_code",
              "type": "str"
            },
            {
              "name": "year",
              "type": "int"
            },
            {
              "name": "two_digit_year",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 409
        },
        {
          "name": "calculate_roll_date",
          "module": "futures_roll_manager",
          "signature": "def calculate_roll_date(expiry_date: date, roll_days_before: int, method: RollMethod) -> date",
          "docstring": "Calculate roll date for a contract.\n\nArgs:\n    expiry_date: Contract expiry date\n    roll_days_before: Days before expiry to roll\n    method: Roll method\n\nReturns:\n    Recommended roll date",
          "parameters": [
            {
              "name": "expiry_date",
              "type": "date"
            },
            {
              "name": "roll_days_before",
              "type": "int"
            },
            {
              "name": "method",
              "type": "RollMethod"
            }
          ],
          "return_type": "date",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1012
        },
        {
          "name": "get_contract_expiry",
          "module": "futures_roll_manager",
          "signature": "def get_contract_expiry(symbol: str, month_code: str, year: int)",
          "docstring": "Estimate contract expiry date.\n\nNote: This is an approximation. Use exchange data for production.\n\nArgs:\n    symbol: Base symbol\n    month_code: Contract month code\n    year: Contract year\n\nReturns:\n    Estimated expiry date",
          "parameters": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "month_code",
              "type": "str"
            },
            {
              "name": "year",
              "type": "int"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1037
        },
        {
          "name": "estimate_first_notice_date",
          "module": "futures_roll_manager",
          "signature": "def estimate_first_notice_date(symbol: str, contract_month: str, contract_year: int)",
          "docstring": "P2-18: Automatically estimate First Notice Date (FND) for physical delivery contracts.\n\nFND varies by exchange and commodity type:\n- CME Energy (CL, NG): Last business day of month prior to delivery month\n- CME Metals (GC, SI): Last business day of month prior to delivery month\n- CME Grains (ZC, ZW, ZS): Last business day of month prior to delivery month\n- COMEX (HG): 2 business days before 1st delivery day\n- Cash-settled contracts (ES, NQ, etc.): No FND (returns None)\n\nArgs:\n    symbol: Futures symbol (e.g., \"CL\", \"GC\")\n    contract_month: Contract month code (F, G, H, J, K, M, N, Q, U, V, X, Z)\n    contract_year: Contract year\n\nReturns:\n    Estimated FND date, or None for cash-settled contracts",
          "parameters": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "contract_month",
              "type": "str"
            },
            {
              "name": "contract_year",
              "type": "int"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1077
        },
        {
          "name": "get_fnd_with_auto_estimate",
          "module": "futures_roll_manager",
          "signature": "def get_fnd_with_auto_estimate(symbol: str, contract_month: str, contract_year: int, manual_fnd: )",
          "docstring": "P2-18: Get FND with automatic estimation fallback.\n\nArgs:\n    symbol: Futures symbol\n    contract_month: Contract month code\n    contract_year: Contract year\n    manual_fnd: Manually specified FND (takes precedence if provided)\n\nReturns:\n    FND date (manual if provided, else estimated, else None for cash-settled)",
          "parameters": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "contract_month",
              "type": "str"
            },
            {
              "name": "contract_year",
              "type": "int"
            },
            {
              "name": "manual_fnd",
              "type": ""
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1214
        },
        {
          "name": "get_complete_roll_calendar",
          "module": "futures_roll_manager",
          "signature": "def get_complete_roll_calendar(year: int) -> list[dict]",
          "docstring": "Generate complete roll calendar for a year (#F4).\n\nArgs:\n    year: Calendar year\n\nReturns:\n    List of roll events with dates and symbols",
          "parameters": [
            {
              "name": "year",
              "type": "int"
            }
          ],
          "return_type": "list[dict]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1403
        },
        {
          "name": "parse_contract_month",
          "module": "futures_roll_manager",
          "signature": "def parse_contract_month(contract_code: str) -> tuple[int, str]",
          "docstring": "Parse contract code to (year, month_code) for sorting.",
          "parameters": [
            {
              "name": "contract_code",
              "type": "str"
            }
          ],
          "return_type": "tuple[int, str]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1671
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.contract_specs"
      ],
      "dependencies": [
        "__future__",
        "core.contract_specs"
      ]
    },
    "core.fx_analytics": {
      "name": "fx_analytics",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\fx_analytics.py",
      "docstring": "FX Analytics Module\n===================\n\nAdvanced FX analytics including volatility smile, central bank detection, and carry trade.\n\nIssues Addressed:\n- #X10: Missing FX volatility smile data\n- #X11: No central bank intervention detection\n- #X12: FX fixing rates not tracked\n- #X13: No carry trade optimization",
      "classes": [
        {
          "name": "FXVolPoint",
          "module": "fx_analytics",
          "docstring": "Single point on FX volatility surface (#X10).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "delta",
              "type": "float"
            },
            {
              "name": "expiry_days",
              "type": "int"
            },
            {
              "name": "implied_vol",
              "type": "float"
            },
            {
              "name": "vol_type",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 58
        },
        {
          "name": "FXVolSmile",
          "module": "fx_analytics",
          "docstring": "FX volatility smile at single expiry (#X10).",
          "bases": [],
          "methods": [
            {
              "name": "skew",
              "module": "fx_analytics",
              "signature": "def skew(self) -> float",
              "docstring": "Get smile skew (positive = call premium).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 79
            },
            {
              "name": "smile_curvature",
              "module": "fx_analytics",
              "signature": "def smile_curvature(self) -> float",
              "docstring": "Get smile curvature (convexity).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 84
            },
            {
              "name": "get_vol_at_delta",
              "module": "fx_analytics",
              "signature": "def get_vol_at_delta(self, delta: float) -> float",
              "docstring": "Interpolate volatility at specific delta (#X10).\n\nUses polynomial fitting through ATM, RR, and BF quotes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "delta",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 88
            },
            {
              "name": "to_dict",
              "module": "fx_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 105
            }
          ],
          "class_attributes": [
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "expiry_days",
              "type": "int"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "atm_vol",
              "type": "float"
            },
            {
              "name": "rr_25d",
              "type": "float"
            },
            {
              "name": "rr_10d",
              "type": "float"
            },
            {
              "name": "bf_25d",
              "type": "float"
            },
            {
              "name": "bf_10d",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 67
        },
        {
          "name": "FXVolSurface",
          "module": "fx_analytics",
          "docstring": "Complete FX volatility surface (#X10).",
          "bases": [],
          "methods": [
            {
              "name": "get_vol",
              "module": "fx_analytics",
              "signature": "def get_vol(self, delta: float, expiry_days: int) -> float",
              "docstring": "Get interpolated volatility from surface (#X10).\n\nArgs:\n    delta: Delta (0-1 for calls)\n    expiry_days: Days to expiry\n\nReturns:\n    Interpolated implied volatility",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "delta",
                  "type": "float"
                },
                {
                  "name": "expiry_days",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 128
            },
            {
              "name": "to_dict",
              "module": "fx_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 172
            }
          ],
          "class_attributes": [
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "smiles",
              "type": "list[FXVolSmile]"
            },
            {
              "name": "term_structure_atm",
              "type": "list[tuple[int, float]]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 121
        },
        {
          "name": "FXVolSmileManager",
          "module": "fx_analytics",
          "docstring": "FX volatility smile management (#X10).\n\nTracks and manages vol surfaces for FX pairs with:\n- Standard tenor smiles (1W, 1M, 3M, 6M, 1Y)\n- Delta interpolation\n- Term structure",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "fx_analytics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 203
            },
            {
              "name": "update_smile",
              "module": "fx_analytics",
              "signature": "def update_smile(self, smile: FXVolSmile) -> None",
              "docstring": "Update smile for a pair/tenor.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "smile",
                  "type": "FXVolSmile"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 207
            },
            {
              "name": "_rebuild_surface",
              "module": "fx_analytics",
              "signature": "def _rebuild_surface(self, pair: str) -> None",
              "docstring": "Rebuild complete surface from smiles.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 216
            },
            {
              "name": "get_surface",
              "module": "fx_analytics",
              "signature": "def get_surface(self, pair: str)",
              "docstring": "Get vol surface for pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 239
            },
            {
              "name": "get_vol",
              "module": "fx_analytics",
              "signature": "def get_vol(self, pair: str, delta: float, expiry_days: int)",
              "docstring": "Get interpolated vol from surface.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "delta",
                  "type": "float"
                },
                {
                  "name": "expiry_days",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 243
            },
            {
              "name": "analyze_smile",
              "module": "fx_analytics",
              "signature": "def analyze_smile(self, pair: str, expiry_days: int) -> dict",
              "docstring": "Analyze smile characteristics (#X10).\n\nReturns analysis of smile shape and signals.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "expiry_days",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 250
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 181
        },
        {
          "name": "InterventionType",
          "module": "fx_analytics",
          "docstring": "Type of central bank intervention.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 314
        },
        {
          "name": "InterventionSignal",
          "module": "fx_analytics",
          "docstring": "Signal of potential central bank intervention (#X11).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "fx_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 333
            }
          ],
          "class_attributes": [
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "signal_type",
              "type": "str"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "indicators",
              "type": "dict[str, float]"
            },
            {
              "name": "recommendation",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 324
        },
        {
          "name": "InterventionEvent",
          "module": "fx_analytics",
          "docstring": "Historical intervention event (#X11).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "date",
              "type": "date"
            },
            {
              "name": "central_bank",
              "type": "str"
            },
            {
              "name": "intervention_type",
              "type": "InterventionType"
            },
            {
              "name": "direction",
              "type": "str"
            },
            {
              "name": "estimated_size_usd",
              "type": ""
            },
            {
              "name": "market_impact_pct",
              "type": "float"
            },
            {
              "name": "notes",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 345
        },
        {
          "name": "CentralBankInterventionDetector",
          "module": "fx_analytics",
          "docstring": "Central bank intervention detection (#X11).\n\nDetects potential intervention through:\n- Abnormal price movements\n- Volume spikes\n- Volatility patterns\n- Historical intervention levels",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "fx_analytics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 392
            },
            {
              "name": "update_price",
              "module": "fx_analytics",
              "signature": "def update_price(self, pair: str, price: float) -> None",
              "docstring": "Update price for intervention monitoring.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 396
            },
            {
              "name": "check_intervention_risk",
              "module": "fx_analytics",
              "signature": "def check_intervention_risk(self, pair: str, current_price: float)",
              "docstring": "Check for intervention risk (#X11).\n\nArgs:\n    pair: Currency pair\n    current_price: Current spot price\n\nReturns:\n    InterventionSignal if risk detected",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "current_price",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 401
            },
            {
              "name": "record_intervention",
              "module": "fx_analytics",
              "signature": "def record_intervention(self, event: InterventionEvent) -> None",
              "docstring": "Record historical intervention event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "InterventionEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 487
            },
            {
              "name": "get_intervention_history",
              "module": "fx_analytics",
              "signature": "def get_intervention_history(self, pair: str) -> list[InterventionEvent]",
              "docstring": "Get intervention history for pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "list[InterventionEvent]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 491
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 357
        },
        {
          "name": "FixingType",
          "module": "fx_analytics",
          "docstring": "Type of FX fixing rate.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 500
        },
        {
          "name": "FXFixingRate",
          "module": "fx_analytics",
          "docstring": "FX fixing rate (#X12).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "fx_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 521
            }
          ],
          "class_attributes": [
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "fixing_type",
              "type": "FixingType"
            },
            {
              "name": "fixing_date",
              "type": "date"
            },
            {
              "name": "fixing_time",
              "type": "time"
            },
            {
              "name": "rate",
              "type": "float"
            },
            {
              "name": "source",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 512
        },
        {
          "name": "FXFixingManager",
          "module": "fx_analytics",
          "docstring": "FX fixing rate tracking (#X12).\n\nTracks official fixing rates for:\n- Portfolio valuation\n- Benchmark comparison\n- Execution analysis",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "fx_analytics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 561
            },
            {
              "name": "record_fixing",
              "module": "fx_analytics",
              "signature": "def record_fixing(self, fixing: FXFixingRate) -> None",
              "docstring": "Record fixing rate (#X12).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fixing",
                  "type": "FXFixingRate"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 565
            },
            {
              "name": "get_latest_fixing",
              "module": "fx_analytics",
              "signature": "def get_latest_fixing(self, pair: str, fixing_type: FixingType)",
              "docstring": "Get latest fixing rate.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "fixing_type",
                  "type": "FixingType"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 576
            },
            {
              "name": "get_fixing_history",
              "module": "fx_analytics",
              "signature": "def get_fixing_history(self, pair: str, fixing_type: FixingType, days: int) -> list[FXFixingRate]",
              "docstring": "Get fixing rate history.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "fixing_type",
                  "type": "FixingType"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "list[FXFixingRate]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 584
            },
            {
              "name": "calculate_fixing_vs_spot",
              "module": "fx_analytics",
              "signature": "def calculate_fixing_vs_spot(self, pair: str, spot_rate: float, fixing_type: FixingType) -> dict",
              "docstring": "Compare current spot to last fixing (#X12).\n\nReturns analysis useful for fixing orders.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "spot_rate",
                  "type": "float"
                },
                {
                  "name": "fixing_type",
                  "type": "FixingType"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 595
            },
            {
              "name": "get_upcoming_fixings",
              "module": "fx_analytics",
              "signature": "def get_upcoming_fixings(self) -> list[dict]",
              "docstring": "Get upcoming fixing times.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 630
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 532
        },
        {
          "name": "CarryTradeOpportunity",
          "module": "fx_analytics",
          "docstring": "Carry trade opportunity (#X13).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "fx_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 666
            }
          ],
          "class_attributes": [
            {
              "name": "long_currency",
              "type": "str"
            },
            {
              "name": "short_currency",
              "type": "str"
            },
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "long_rate",
              "type": "float"
            },
            {
              "name": "short_rate",
              "type": "float"
            },
            {
              "name": "carry_bps",
              "type": "float"
            },
            {
              "name": "volatility",
              "type": "float"
            },
            {
              "name": "sharpe_ratio",
              "type": "float"
            },
            {
              "name": "correlation_to_risk",
              "type": "float"
            },
            {
              "name": "score",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 653
        },
        {
          "name": "CarryPortfolio",
          "module": "fx_analytics",
          "docstring": "Optimized carry portfolio (#X13).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "fx_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 691
            }
          ],
          "class_attributes": [
            {
              "name": "positions",
              "type": "list[dict]"
            },
            {
              "name": "total_carry_bps",
              "type": "float"
            },
            {
              "name": "portfolio_volatility",
              "type": "float"
            },
            {
              "name": "portfolio_sharpe",
              "type": "float"
            },
            {
              "name": "max_drawdown_estimate",
              "type": "float"
            },
            {
              "name": "diversification_ratio",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 682
        },
        {
          "name": "CarryTradeOptimizer",
          "module": "fx_analytics",
          "docstring": "Carry trade optimization (#X13).\n\nOptimizes carry trades considering:\n- Interest rate differentials\n- Currency volatility\n- Correlations\n- Risk-off sensitivity",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "fx_analytics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 713
            },
            {
              "name": "update_rate",
              "module": "fx_analytics",
              "signature": "def update_rate(self, currency: str, rate: float) -> None",
              "docstring": "Update interest rate for currency.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "currency",
                  "type": "str"
                },
                {
                  "name": "rate",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 726
            },
            {
              "name": "update_volatility",
              "module": "fx_analytics",
              "signature": "def update_volatility(self, pair: str, vol: float) -> None",
              "docstring": "Update volatility for pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "vol",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 730
            },
            {
              "name": "update_correlation",
              "module": "fx_analytics",
              "signature": "def update_correlation(self, pair1: str, pair2: str, corr: float) -> None",
              "docstring": "Update correlation between pairs.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair1",
                  "type": "str"
                },
                {
                  "name": "pair2",
                  "type": "str"
                },
                {
                  "name": "corr",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 734
            },
            {
              "name": "update_risk_correlation",
              "module": "fx_analytics",
              "signature": "def update_risk_correlation(self, pair: str, corr: float) -> None",
              "docstring": "Update correlation to risk-off (e.g., VIX or S&P).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "corr",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 739
            },
            {
              "name": "find_opportunities",
              "module": "fx_analytics",
              "signature": "def find_opportunities(self, min_carry_bps: float, max_volatility: float) -> list[CarryTradeOpportunity]",
              "docstring": "Find carry trade opportunities (#X13).\n\nArgs:\n    min_carry_bps: Minimum annual carry in bps\n    max_volatility: Maximum acceptable volatility\n\nReturns:\n    List of opportunities sorted by score",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "min_carry_bps",
                  "type": "float"
                },
                {
                  "name": "max_volatility",
                  "type": "float"
                }
              ],
              "return_type": "list[CarryTradeOpportunity]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 743
            },
            {
              "name": "optimize_portfolio",
              "module": "fx_analytics",
              "signature": "def optimize_portfolio(self, opportunities: list[CarryTradeOpportunity], max_positions: int, target_volatility: float) -> CarryPortfolio",
              "docstring": "Optimize carry portfolio (#X13).\n\nUses simple diversification approach.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "opportunities",
                  "type": "list[CarryTradeOpportunity]"
                },
                {
                  "name": "max_positions",
                  "type": "int"
                },
                {
                  "name": "target_volatility",
                  "type": "float"
                }
              ],
              "return_type": "CarryPortfolio",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 815
            },
            {
              "name": "get_carry_dashboard",
              "module": "fx_analytics",
              "signature": "def get_carry_dashboard(self) -> dict",
              "docstring": "Get carry trade dashboard (#X13).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 894
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 702
        }
      ],
      "functions": [
        {
          "name": "get_pip_multiplier",
          "module": "fx_analytics",
          "signature": "def get_pip_multiplier(pair: str) -> int",
          "docstring": "Get pip multiplier for FX pair.\n\nFor JPY pairs (USDJPY, EURJPY, etc.): 1 pip = 0.01, so multiplier = 100\nFor other pairs (EURUSD, GBPUSD, etc.): 1 pip = 0.0001, so multiplier = 10000\n\nArgs:\n    pair: Currency pair (e.g., \"USDJPY\", \"EURUSD\")\n\nReturns:\n    Pip multiplier (100 for JPY pairs, 10000 for others)",
          "parameters": [
            {
              "name": "pair",
              "type": "str"
            }
          ],
          "return_type": "int",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 35
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "numpy",
        "scipy",
        "scipy.interpolate"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "scipy",
        "scipy.interpolate"
      ]
    },
    "core.fx_correlation": {
      "name": "fx_correlation",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\fx_correlation.py",
      "docstring": "FX Correlation Module\n=====================\n\nAddresses issues:\n- #X14: FX market depth not utilized\n- #X15: No FX correlation regime switching\n\nFeatures:\n- FX market depth analysis\n- Correlation regime detection and switching\n- Cross-pair correlation tracking\n- Regime-based strategy adjustment",
      "classes": [
        {
          "name": "FXCorrelationRegime",
          "module": "fx_correlation",
          "docstring": "FX correlation regime states.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 52
        },
        {
          "name": "FXMarketDepth",
          "module": "fx_correlation",
          "docstring": "FX market depth analysis (#X14).\n\nTracks order book depth for FX pairs.",
          "bases": [],
          "methods": [
            {
              "name": "mid_price",
              "module": "fx_correlation",
              "signature": "def mid_price(self)",
              "docstring": "Calculate mid price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 79
            },
            {
              "name": "to_dict",
              "module": "fx_correlation",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 89
            }
          ],
          "class_attributes": [
            {
              "name": "pair",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "bid_levels",
              "type": "list[tuple[float, float]]"
            },
            {
              "name": "ask_levels",
              "type": "list[tuple[float, float]]"
            },
            {
              "name": "total_bid_depth",
              "type": "float"
            },
            {
              "name": "total_ask_depth",
              "type": "float"
            },
            {
              "name": "spread_pips",
              "type": "float"
            },
            {
              "name": "depth_imbalance",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 63
        },
        {
          "name": "FXMarketDepthAnalyzer",
          "module": "fx_correlation",
          "docstring": "Analyzes FX market depth (#X14).\n\nUses depth data for execution optimization and market insight.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "fx_correlation",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 110
            },
            {
              "name": "update_depth",
              "module": "fx_correlation",
              "signature": "def update_depth(self, depth: FXMarketDepth) -> None",
              "docstring": "Update depth for a pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "depth",
                  "type": "FXMarketDepth"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 113
            },
            {
              "name": "get_current_depth",
              "module": "fx_correlation",
              "signature": "def get_current_depth(self, pair: str)",
              "docstring": "Get most recent depth for pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 117
            },
            {
              "name": "estimate_market_impact",
              "module": "fx_correlation",
              "signature": "def estimate_market_impact(self, pair: str, size_millions: float, side: str)",
              "docstring": "Estimate market impact for a trade.\n\nArgs:\n    pair: FX pair\n    size_millions: Trade size in millions\n    side: 'buy' or 'sell'\n\nReturns:\n    Dict with impact estimates",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "size_millions",
                  "type": "float"
                },
                {
                  "name": "side",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 124
            },
            {
              "name": "get_depth_quality",
              "module": "fx_correlation",
              "signature": "def get_depth_quality(self, pair: str) -> dict",
              "docstring": "Assess depth quality for a pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 181
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 103
        },
        {
          "name": "RegimeIndicators",
          "module": "fx_correlation",
          "docstring": "Indicators used for regime detection.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "fx_correlation",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 244
            }
          ],
          "class_attributes": [
            {
              "name": "usd_index_change",
              "type": "float"
            },
            {
              "name": "vix_level",
              "type": "float"
            },
            {
              "name": "avg_g10_correlation",
              "type": "float"
            },
            {
              "name": "carry_performance",
              "type": "float"
            },
            {
              "name": "spread_volatility",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 236
        },
        {
          "name": "RegimeState",
          "module": "fx_correlation",
          "docstring": "Current regime state with probabilities.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "fx_correlation",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 265
            }
          ],
          "class_attributes": [
            {
              "name": "current_regime",
              "type": "FXCorrelationRegime"
            },
            {
              "name": "regime_probability",
              "type": "float"
            },
            {
              "name": "regime_duration_days",
              "type": "int"
            },
            {
              "name": "all_probabilities",
              "type": "dict[FXCorrelationRegime, float]"
            },
            {
              "name": "indicators",
              "type": "RegimeIndicators"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 256
        },
        {
          "name": "FXCorrelationRegimeDetector",
          "module": "fx_correlation",
          "docstring": "Detects FX correlation regime switches (#X15).\n\nMonitors cross-pair correlations and market indicators\nto identify regime changes.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "fx_correlation",
              "signature": "def __init__(self, correlation_window: int, regime_change_threshold: float)",
              "docstring": "Initialize regime detector.\n\nArgs:\n    correlation_window: Days for correlation calculation\n    regime_change_threshold: Min probability change to trigger switch",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "correlation_window",
                  "type": "int"
                },
                {
                  "name": "regime_change_threshold",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 297
            },
            {
              "name": "update_return",
              "module": "fx_correlation",
              "signature": "def update_return(self, pair: str, daily_return: float) -> None",
              "docstring": "Update daily return for a pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "daily_return",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 322
            },
            {
              "name": "update_indicators",
              "module": "fx_correlation",
              "signature": "def update_indicators(self, vix: , dxy_change: ) -> None",
              "docstring": "Update market indicators.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "vix",
                  "type": ""
                },
                {
                  "name": "dxy_change",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 326
            },
            {
              "name": "detect_regime",
              "module": "fx_correlation",
              "signature": "def detect_regime(self) -> RegimeState",
              "docstring": "Detect current correlation regime.\n\nReturns:\n    RegimeState with current regime and indicators",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RegimeState",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 337
            },
            {
              "name": "_calculate_indicators",
              "module": "fx_correlation",
              "signature": "def _calculate_indicators(self) -> RegimeIndicators",
              "docstring": "Calculate regime indicators.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RegimeIndicators",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 376
            },
            {
              "name": "_calculate_correlation",
              "module": "fx_correlation",
              "signature": "def _calculate_correlation(self, pair1: str, pair2: str)",
              "docstring": "Calculate correlation between two pairs.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair1",
                  "type": "str"
                },
                {
                  "name": "pair2",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 428
            },
            {
              "name": "_calculate_regime_probabilities",
              "module": "fx_correlation",
              "signature": "def _calculate_regime_probabilities(self, indicators: RegimeIndicators) -> dict[FXCorrelationRegime, float]",
              "docstring": "Calculate probability of each regime.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "indicators",
                  "type": "RegimeIndicators"
                }
              ],
              "return_type": "dict[FXCorrelationRegime, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 458
            },
            {
              "name": "get_strategy_adjustments",
              "module": "fx_correlation",
              "signature": "def get_strategy_adjustments(self) -> dict",
              "docstring": "Get strategy adjustments based on current regime.\n\nReturns recommendations for position sizing, pair selection, etc.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 502
            },
            {
              "name": "get_regime_history",
              "module": "fx_correlation",
              "signature": "def get_regime_history(self, lookback_days: int) -> list[dict]",
              "docstring": "Get regime history for analysis.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 574
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 277
        }
      ],
      "functions": [
        {
          "name": "get_pip_multiplier",
          "module": "fx_correlation",
          "signature": "def get_pip_multiplier(pair: str) -> int",
          "docstring": "Get pip multiplier for FX pair.\n\nFor JPY pairs (USDJPY, EURJPY, etc.): 1 pip = 0.01, so multiplier = 100\nFor other pairs (EURUSD, GBPUSD, etc.): 1 pip = 0.0001, so multiplier = 10000\n\nArgs:\n    pair: Currency pair (e.g., \"USDJPY\", \"EURUSD\")\n\nReturns:\n    Pip multiplier (100 for JPY pairs, 10000 for others)",
          "parameters": [
            {
              "name": "pair",
              "type": "str"
            }
          ],
          "return_type": "int",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 34
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "math"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.fx_sessions": {
      "name": "fx_sessions",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\fx_sessions.py",
      "docstring": "FX Session Awareness Module\n===========================\n\nForex trading session awareness and analytics (Issue #X9).\n\nFeatures:\n- Major FX session tracking (Sydney, Tokyo, London, New York)\n- Session overlap detection\n- Liquidity estimation by session\n- Volatility patterns by session\n- Best execution timing recommendations",
      "classes": [
        {
          "name": "FXSession",
          "module": "fx_sessions",
          "docstring": "Major FX trading sessions.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 28
        },
        {
          "name": "SessionOverlap",
          "module": "fx_sessions",
          "docstring": "Session overlap periods.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 36
        },
        {
          "name": "SessionTime",
          "module": "fx_sessions",
          "docstring": "Trading session times.",
          "bases": [],
          "methods": [
            {
              "name": "is_open",
              "module": "fx_sessions",
              "signature": "def is_open(self, utc_time: time) -> bool",
              "docstring": "Check if session is open at given UTC time.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "utc_time",
                  "type": "time"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 52
            },
            {
              "name": "is_peak",
              "module": "fx_sessions",
              "signature": "def is_peak(self, utc_time: time) -> bool",
              "docstring": "Check if in peak hours.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "utc_time",
                  "type": "time"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 60
            }
          ],
          "class_attributes": [
            {
              "name": "session",
              "type": "FXSession"
            },
            {
              "name": "open_utc",
              "type": "time"
            },
            {
              "name": "close_utc",
              "type": "time"
            },
            {
              "name": "peak_hours",
              "type": "tuple[time, time]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 45
        },
        {
          "name": "SessionCharacteristics",
          "module": "fx_sessions",
          "docstring": "Trading characteristics for a session.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "session",
              "type": "FXSession"
            },
            {
              "name": "avg_volatility_pips",
              "type": "float"
            },
            {
              "name": "avg_spread_pips",
              "type": "float"
            },
            {
              "name": "liquidity_score",
              "type": "float"
            },
            {
              "name": "dominant_pairs",
              "type": "list[str]"
            },
            {
              "name": "typical_moves",
              "type": "dict[str, float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 95
        },
        {
          "name": "FXSessionState",
          "module": "fx_sessions",
          "docstring": "Current FX session state.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "fx_sessions",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 153
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "active_sessions",
              "type": "list[FXSession]"
            },
            {
              "name": "overlaps",
              "type": "list[SessionOverlap]"
            },
            {
              "name": "liquidity_level",
              "type": "str"
            },
            {
              "name": "recommended_pairs",
              "type": "list[str]"
            },
            {
              "name": "spread_multiplier",
              "type": "float"
            },
            {
              "name": "volatility_adjustment",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 143
        },
        {
          "name": "FXSessionManager",
          "module": "fx_sessions",
          "docstring": "Manages FX session awareness and provides trading recommendations.\n\nTracks which sessions are active and their characteristics.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "fx_sessions",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 173
            },
            {
              "name": "get_current_state",
              "module": "fx_sessions",
              "signature": "def get_current_state(self, utc_now: ) -> FXSessionState",
              "docstring": "Get current FX session state.\n\nArgs:\n    utc_now: Current UTC time (defaults to now)\n\nReturns:\n    FXSessionState with active sessions and recommendations",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "utc_now",
                  "type": ""
                }
              ],
              "return_type": "FXSessionState",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 181
            },
            {
              "name": "_detect_overlaps",
              "module": "fx_sessions",
              "signature": "def _detect_overlaps(self, active_sessions: list[FXSession]) -> list[SessionOverlap]",
              "docstring": "Detect session overlaps.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "active_sessions",
                  "type": "list[FXSession]"
                }
              ],
              "return_type": "list[SessionOverlap]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 225
            },
            {
              "name": "_calculate_liquidity_level",
              "module": "fx_sessions",
              "signature": "def _calculate_liquidity_level(self, active_sessions: list[FXSession], overlaps: list[SessionOverlap]) -> str",
              "docstring": "Calculate overall liquidity level.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "active_sessions",
                  "type": "list[FXSession]"
                },
                {
                  "name": "overlaps",
                  "type": "list[SessionOverlap]"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 243
            },
            {
              "name": "_get_recommended_pairs",
              "module": "fx_sessions",
              "signature": "def _get_recommended_pairs(self, active_sessions: list[FXSession]) -> list[str]",
              "docstring": "Get recommended pairs for active sessions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "active_sessions",
                  "type": "list[FXSession]"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 271
            },
            {
              "name": "_calculate_spread_multiplier",
              "module": "fx_sessions",
              "signature": "def _calculate_spread_multiplier(self, liquidity_level: str) -> float",
              "docstring": "Calculate spread multiplier based on liquidity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "liquidity_level",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 286
            },
            {
              "name": "_calculate_volatility_adjustment",
              "module": "fx_sessions",
              "signature": "def _calculate_volatility_adjustment(self, active_sessions: list[FXSession], overlaps: list[SessionOverlap]) -> float",
              "docstring": "Calculate volatility adjustment factor.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "active_sessions",
                  "type": "list[FXSession]"
                },
                {
                  "name": "overlaps",
                  "type": "list[SessionOverlap]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 296
            },
            {
              "name": "get_best_execution_window",
              "module": "fx_sessions",
              "signature": "def get_best_execution_window(self, pair: str) -> dict",
              "docstring": "Get best execution window for a currency pair.\n\nReturns recommended times and expected conditions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 323
            },
            {
              "name": "record_volatility",
              "module": "fx_sessions",
              "signature": "def record_volatility(self, session: FXSession, volatility: float) -> None",
              "docstring": "Record observed volatility for session.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "session",
                  "type": "FXSession"
                },
                {
                  "name": "volatility",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 379
            },
            {
              "name": "record_spread",
              "module": "fx_sessions",
              "signature": "def record_spread(self, session: FXSession, spread: float) -> None",
              "docstring": "Record observed spread for session.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "session",
                  "type": "FXSession"
                },
                {
                  "name": "spread",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 387
            },
            {
              "name": "get_session_stats",
              "module": "fx_sessions",
              "signature": "def get_session_stats(self) -> dict",
              "docstring": "Get session statistics from recorded data.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 395
            },
            {
              "name": "is_trading_recommended",
              "module": "fx_sessions",
              "signature": "def is_trading_recommended(self, pair: str, utc_now: ) -> tuple[bool, str]",
              "docstring": "Check if trading is recommended for a pair at current time.\n\nReturns (recommended, reason).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pair",
                  "type": "str"
                },
                {
                  "name": "utc_now",
                  "type": ""
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 418
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 166
        },
        {
          "name": "SessionVolatilityPattern",
          "module": "fx_sessions",
          "docstring": "Volatility pattern by hour for a session.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "session",
              "type": "FXSession"
            },
            {
              "name": "hourly_vol_multipliers",
              "type": "dict[int, float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 463
        }
      ],
      "functions": [
        {
          "name": "get_expected_volatility_multiplier",
          "module": "fx_sessions",
          "signature": "def get_expected_volatility_multiplier(utc_now: ) -> float",
          "docstring": "Get expected volatility multiplier for current time.",
          "parameters": [
            {
              "name": "utc_now",
              "type": ""
            }
          ],
          "return_type": "float",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 504
        }
      ],
      "constants": [
        {
          "name": "SESSION_TIMES",
          "line": 66
        },
        {
          "name": "SESSION_CHARACTERISTICS",
          "line": 106
        },
        {
          "name": "VOLATILITY_PATTERNS",
          "line": 470
        }
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "statistics"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.greeks_analytics": {
      "name": "greeks_analytics",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\greeks_analytics.py",
      "docstring": "Greeks Analytics Module\n=======================\n\nComprehensive Greeks sensitivity analysis and risk exposure trending.\n\nIssues Addressed:\n- #R15: Greeks sensitivity analysis not comprehensive\n- #R20: No risk exposure trending/forecasting\n- #R21: Missing P&L attribution by risk factor\n- #R24: No scenario-specific position limits",
      "classes": [
        {
          "name": "SensitivityType",
          "module": "greeks_analytics",
          "docstring": "Types of sensitivity analysis.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 34
        },
        {
          "name": "GreeksSensitivity",
          "module": "greeks_analytics",
          "docstring": "Result of Greeks sensitivity analysis (#R15).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "greeks_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 60
            }
          ],
          "class_attributes": [
            {
              "name": "greek",
              "type": "str"
            },
            {
              "name": "base_value",
              "type": "float"
            },
            {
              "name": "sensitivities",
              "type": "dict[str, float]"
            },
            {
              "name": "stress_values",
              "type": "dict[str, float]"
            },
            {
              "name": "confidence_interval",
              "type": "tuple[float, float]"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 51
        },
        {
          "name": "PortfolioGreeksSummary",
          "module": "greeks_analytics",
          "docstring": "Complete portfolio Greeks summary with sensitivities (#R15).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "greeks_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 103
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "delta",
              "type": "float"
            },
            {
              "name": "gamma",
              "type": "float"
            },
            {
              "name": "vega",
              "type": "float"
            },
            {
              "name": "theta",
              "type": "float"
            },
            {
              "name": "rho",
              "type": "float"
            },
            {
              "name": "vanna",
              "type": "float"
            },
            {
              "name": "volga",
              "type": "float"
            },
            {
              "name": "charm",
              "type": "float"
            },
            {
              "name": "veta",
              "type": "float"
            },
            {
              "name": "speed",
              "type": "float"
            },
            {
              "name": "color",
              "type": "float"
            },
            {
              "name": "ultima",
              "type": "float"
            },
            {
              "name": "delta_1pct_spot",
              "type": "float"
            },
            {
              "name": "gamma_1pct_spot",
              "type": "float"
            },
            {
              "name": "vega_1vol_point",
              "type": "float"
            },
            {
              "name": "theta_1day",
              "type": "float"
            },
            {
              "name": "by_underlying",
              "type": "dict[str, dict]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 72
        },
        {
          "name": "GreeksSensitivityAnalyzer",
          "module": "greeks_analytics",
          "docstring": "Comprehensive Greeks sensitivity analysis (#R15).\n\nAnalyzes:\n- First, second, and third-order Greeks\n- Greeks sensitivity to underlying factors\n- Stress testing of Greeks under various scenarios\n- Greeks term structure analysis",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "greeks_analytics",
              "signature": "def __init__(self, spot_shock_range: tuple[float, float], vol_shock_range: tuple[float, float], rate_shock_range: tuple[float, float], n_scenarios: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spot_shock_range",
                  "type": "tuple[float, float]"
                },
                {
                  "name": "vol_shock_range",
                  "type": "tuple[float, float]"
                },
                {
                  "name": "rate_shock_range",
                  "type": "tuple[float, float]"
                },
                {
                  "name": "n_scenarios",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 145
            },
            {
              "name": "update_position",
              "module": "greeks_analytics",
              "signature": "def update_position(self, symbol: str, position: dict) -> None",
              "docstring": "Update position for Greeks analysis.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "position",
                  "type": "dict"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 160
            },
            {
              "name": "calculate_delta_sensitivity",
              "module": "greeks_analytics",
              "signature": "def calculate_delta_sensitivity(self, portfolio_delta: float, portfolio_gamma: float, spot_price: float) -> GreeksSensitivity",
              "docstring": "Calculate delta sensitivity to spot price changes (#R15).\n\nShows how delta changes across spot price scenarios.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_delta",
                  "type": "float"
                },
                {
                  "name": "portfolio_gamma",
                  "type": "float"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                }
              ],
              "return_type": "GreeksSensitivity",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 168
            },
            {
              "name": "calculate_gamma_sensitivity",
              "module": "greeks_analytics",
              "signature": "def calculate_gamma_sensitivity(self, portfolio_gamma: float, portfolio_speed: float, spot_price: float) -> GreeksSensitivity",
              "docstring": "Calculate gamma sensitivity to spot price changes (#R15).\n\nSpeed = dGamma/dSpot",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_gamma",
                  "type": "float"
                },
                {
                  "name": "portfolio_speed",
                  "type": "float"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                }
              ],
              "return_type": "GreeksSensitivity",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 210
            },
            {
              "name": "calculate_vega_sensitivity",
              "module": "greeks_analytics",
              "signature": "def calculate_vega_sensitivity(self, portfolio_vega: float, portfolio_volga: float, current_vol: float) -> GreeksSensitivity",
              "docstring": "Calculate vega sensitivity to volatility changes (#R15).\n\nVolga = dVega/dVol",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_vega",
                  "type": "float"
                },
                {
                  "name": "portfolio_volga",
                  "type": "float"
                },
                {
                  "name": "current_vol",
                  "type": "float"
                }
              ],
              "return_type": "GreeksSensitivity",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 247
            },
            {
              "name": "calculate_cross_greek_sensitivity",
              "module": "greeks_analytics",
              "signature": "def calculate_cross_greek_sensitivity(self, portfolio_delta: float, portfolio_vanna: float, spot_price: float, current_vol: float) -> dict",
              "docstring": "Calculate cross-Greek sensitivities (delta-vol interaction) (#R15).\n\nVanna = dDelta/dVol = dVega/dSpot",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_delta",
                  "type": "float"
                },
                {
                  "name": "portfolio_vanna",
                  "type": "float"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "current_vol",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 284
            },
            {
              "name": "run_full_sensitivity_analysis",
              "module": "greeks_analytics",
              "signature": "def run_full_sensitivity_analysis(self, portfolio_greeks: dict, spot_price: float, current_vol: float) -> dict",
              "docstring": "Run comprehensive sensitivity analysis on all Greeks (#R15).\n\nReturns full sensitivity report.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_greeks",
                  "type": "dict"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "current_vol",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 321
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 134
        },
        {
          "name": "RiskExposureForecast",
          "module": "greeks_analytics",
          "docstring": "Forecasted risk exposure (#R20).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "greeks_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 393
            }
          ],
          "class_attributes": [
            {
              "name": "metric",
              "type": "str"
            },
            {
              "name": "current_value",
              "type": "float"
            },
            {
              "name": "forecast_1d",
              "type": "float"
            },
            {
              "name": "forecast_5d",
              "type": "float"
            },
            {
              "name": "forecast_10d",
              "type": "float"
            },
            {
              "name": "trend",
              "type": "str"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "factors",
              "type": "dict[str, float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 382
        },
        {
          "name": "RiskExposureTrending",
          "module": "greeks_analytics",
          "docstring": "Risk exposure trending and forecasting (#R20).\n\nTracks and forecasts:\n- VaR trends\n- Greeks evolution\n- Exposure concentration\n- Correlation regime",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "greeks_analytics",
              "signature": "def __init__(self, lookback_days: int, forecast_horizon: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                },
                {
                  "name": "forecast_horizon",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 417
            },
            {
              "name": "record_var",
              "module": "greeks_analytics",
              "signature": "def record_var(self, var_value: float) -> None",
              "docstring": "Record daily VaR observation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "var_value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 431
            },
            {
              "name": "record_greeks",
              "module": "greeks_analytics",
              "signature": "def record_greeks(self, delta: float, vega: float) -> None",
              "docstring": "Record daily Greeks snapshot.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "delta",
                  "type": "float"
                },
                {
                  "name": "vega",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 436
            },
            {
              "name": "record_concentration",
              "module": "greeks_analytics",
              "signature": "def record_concentration(self, hhi: float) -> None",
              "docstring": "Record portfolio concentration (HHI).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hhi",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 444
            },
            {
              "name": "_fit_trend",
              "module": "greeks_analytics",
              "signature": "def _fit_trend(self, data: list[tuple[datetime, float]]) -> tuple[float, float, float]",
              "docstring": "Fit linear trend to time series.\n\nReturns: (slope, intercept, r_squared)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "list[tuple[datetime, float]]"
                }
              ],
              "return_type": "tuple[float, float, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 449
            },
            {
              "name": "_forecast_value",
              "module": "greeks_analytics",
              "signature": "def _forecast_value(self, data: list[tuple[datetime, float]], horizon_days: int) -> tuple[float, float]",
              "docstring": "Forecast value using exponential smoothing.\n\nReturns: (forecast, confidence)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "list[tuple[datetime, float]]"
                },
                {
                  "name": "horizon_days",
                  "type": "int"
                }
              ],
              "return_type": "tuple[float, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 464
            },
            {
              "name": "forecast_var",
              "module": "greeks_analytics",
              "signature": "def forecast_var(self) -> RiskExposureForecast",
              "docstring": "Forecast VaR trend (#R20).\n\nReturns VaR forecast with trend analysis.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RiskExposureForecast",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 496
            },
            {
              "name": "get_trend_dashboard",
              "module": "greeks_analytics",
              "signature": "def get_trend_dashboard(self) -> dict",
              "docstring": "Get complete trend dashboard (#R20).\n\nReturns trends and forecasts for all risk metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 554
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 406
        },
        {
          "name": "PnLAttribution",
          "module": "greeks_analytics",
          "docstring": "P&L attribution by risk factor (#R21).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "greeks_analytics",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 637
            }
          ],
          "class_attributes": [
            {
              "name": "period_start",
              "type": "datetime"
            },
            {
              "name": "period_end",
              "type": "datetime"
            },
            {
              "name": "total_pnl",
              "type": "float"
            },
            {
              "name": "delta_pnl",
              "type": "float"
            },
            {
              "name": "gamma_pnl",
              "type": "float"
            },
            {
              "name": "vega_pnl",
              "type": "float"
            },
            {
              "name": "theta_pnl",
              "type": "float"
            },
            {
              "name": "rho_pnl",
              "type": "float"
            },
            {
              "name": "cross_gamma_pnl",
              "type": "float"
            },
            {
              "name": "vanna_pnl",
              "type": "float"
            },
            {
              "name": "volga_pnl",
              "type": "float"
            },
            {
              "name": "residual_pnl",
              "type": "float"
            },
            {
              "name": "by_underlying",
              "type": "dict[str, dict]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 613
        },
        {
          "name": "PnLAttributionEngine",
          "module": "greeks_analytics",
          "docstring": "P&L attribution by risk factor (#R21).\n\nDecomposes P&L into:\n- First-order Greeks (delta, vega, theta, rho)\n- Second-order effects (gamma, vanna, volga)\n- Cross-effects and residual",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "greeks_analytics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 680
            },
            {
              "name": "record_snapshot",
              "module": "greeks_analytics",
              "signature": "def record_snapshot(self, greeks: dict, market_data: dict) -> None",
              "docstring": "Record Greeks and market snapshot for attribution.\n\nArgs:\n    greeks: Portfolio Greeks {delta, gamma, vega, theta, rho, vanna, volga}\n    market_data: Market data {spot_prices, vols, rates}",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "greeks",
                  "type": "dict"
                },
                {
                  "name": "market_data",
                  "type": "dict"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 684
            },
            {
              "name": "attribute_pnl",
              "module": "greeks_analytics",
              "signature": "def attribute_pnl(self, total_pnl: float, start_greeks: dict, end_greeks: dict, start_market: dict, end_market: dict) -> PnLAttribution",
              "docstring": "Attribute P&L to risk factors (#R21).\n\nUses Taylor series expansion for attribution.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "total_pnl",
                  "type": "float"
                },
                {
                  "name": "start_greeks",
                  "type": "dict"
                },
                {
                  "name": "end_greeks",
                  "type": "dict"
                },
                {
                  "name": "start_market",
                  "type": "dict"
                },
                {
                  "name": "end_market",
                  "type": "dict"
                }
              ],
              "return_type": "PnLAttribution",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 704
            },
            {
              "name": "get_attribution_report",
              "module": "greeks_analytics",
              "signature": "def get_attribution_report(self, lookback_days: int) -> dict",
              "docstring": "Generate P&L attribution report (#R21).\n\nProvides cumulative attribution over period.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 769
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 670
        },
        {
          "name": "ScenarioType",
          "module": "greeks_analytics",
          "docstring": "Market scenario types for position limits (#R24).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 827
        },
        {
          "name": "ScenarioPositionLimit",
          "module": "greeks_analytics",
          "docstring": "Position limit for a specific scenario (#R24).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "scenario",
              "type": "ScenarioType"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "max_position",
              "type": "int"
            },
            {
              "name": "max_notional",
              "type": "float"
            },
            {
              "name": "max_delta",
              "type": "float"
            },
            {
              "name": "max_gamma",
              "type": "float"
            },
            {
              "name": "max_vega",
              "type": "float"
            },
            {
              "name": "rationale",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 838
        },
        {
          "name": "ScenarioLimitCheck",
          "module": "greeks_analytics",
          "docstring": "Result of scenario limit check (#R24).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "scenario",
              "type": "ScenarioType"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "current_position",
              "type": "int"
            },
            {
              "name": "current_notional",
              "type": "float"
            },
            {
              "name": "limit_position",
              "type": "int"
            },
            {
              "name": "limit_notional",
              "type": "float"
            },
            {
              "name": "is_within_limit",
              "type": "bool"
            },
            {
              "name": "utilization_pct",
              "type": "float"
            },
            {
              "name": "warning_message",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 851
        },
        {
          "name": "ScenarioPositionLimits",
          "module": "greeks_analytics",
          "docstring": "Scenario-specific position limits (#R24).\n\nDifferent limits apply under different market conditions:\n- Normal: Standard limits\n- High Vol: Reduced limits when VIX elevated\n- Crisis: Severely reduced limits during market stress\n- Earnings: Reduced limits around earnings\n- FOMC: Reduced limits around Fed meetings\n- Expiration: Reduced limits near option expiry",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "greeks_analytics",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 887
            },
            {
              "name": "set_base_limit",
              "module": "greeks_analytics",
              "signature": "def set_base_limit(self, symbol: str, max_position: int, max_notional: float, max_delta: float, max_gamma: float, max_vega: float) -> None",
              "docstring": "Set base position limits for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "max_position",
                  "type": "int"
                },
                {
                  "name": "max_notional",
                  "type": "float"
                },
                {
                  "name": "max_delta",
                  "type": "float"
                },
                {
                  "name": "max_gamma",
                  "type": "float"
                },
                {
                  "name": "max_vega",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 901
            },
            {
              "name": "set_scenario_limit",
              "module": "greeks_analytics",
              "signature": "def set_scenario_limit(self, scenario: ScenarioType, symbol: str, max_position: int, max_notional: float, max_delta: float, max_gamma: float, max_vega: float, rationale: str) -> None",
              "docstring": "Set custom limit for specific scenario (#R24).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario",
                  "type": "ScenarioType"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "max_position",
                  "type": "int"
                },
                {
                  "name": "max_notional",
                  "type": "float"
                },
                {
                  "name": "max_delta",
                  "type": "float"
                },
                {
                  "name": "max_gamma",
                  "type": "float"
                },
                {
                  "name": "max_vega",
                  "type": "float"
                },
                {
                  "name": "rationale",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 919
            },
            {
              "name": "detect_scenario",
              "module": "greeks_analytics",
              "signature": "def detect_scenario(self, vix_level: float, is_earnings: bool, is_fomc: bool, days_to_expiry: ) -> ScenarioType",
              "docstring": "Detect current market scenario (#R24).\n\nArgs:\n    vix_level: Current VIX level\n    is_earnings: Whether in earnings period\n    is_fomc: Whether FOMC meeting today/tomorrow\n    days_to_expiry: Days to option expiry\n\nReturns:\n    Detected scenario type",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "vix_level",
                  "type": "float"
                },
                {
                  "name": "is_earnings",
                  "type": "bool"
                },
                {
                  "name": "is_fomc",
                  "type": "bool"
                },
                {
                  "name": "days_to_expiry",
                  "type": ""
                }
              ],
              "return_type": "ScenarioType",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 942
            },
            {
              "name": "get_effective_limit",
              "module": "greeks_analytics",
              "signature": "def get_effective_limit(self, symbol: str, scenario: ) -> dict",
              "docstring": "Get effective position limit for symbol under scenario (#R24).\n\nArgs:\n    symbol: Symbol to get limit for\n    scenario: Scenario (uses current if not specified)\n\nReturns:\n    Effective limits",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "scenario",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 980
            },
            {
              "name": "check_limit",
              "module": "greeks_analytics",
              "signature": "def check_limit(self, symbol: str, current_position: int, current_notional: float, current_delta: float, current_gamma: float, current_vega: float, scenario: ) -> ScenarioLimitCheck",
              "docstring": "Check if position is within scenario limits (#R24).\n\nReturns limit check result with utilization.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "current_position",
                  "type": "int"
                },
                {
                  "name": "current_notional",
                  "type": "float"
                },
                {
                  "name": "current_delta",
                  "type": "float"
                },
                {
                  "name": "current_gamma",
                  "type": "float"
                },
                {
                  "name": "current_vega",
                  "type": "float"
                },
                {
                  "name": "scenario",
                  "type": ""
                }
              ],
              "return_type": "ScenarioLimitCheck",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1037
            },
            {
              "name": "update_scenario",
              "module": "greeks_analytics",
              "signature": "def update_scenario(self, vix_level: float, is_earnings: bool, is_fomc: bool, days_to_expiry: ) -> ScenarioType",
              "docstring": "Update current scenario based on market conditions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "vix_level",
                  "type": "float"
                },
                {
                  "name": "is_earnings",
                  "type": "bool"
                },
                {
                  "name": "is_fomc",
                  "type": "bool"
                },
                {
                  "name": "days_to_expiry",
                  "type": ""
                }
              ],
              "return_type": "ScenarioType",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1095
            },
            {
              "name": "get_status",
              "module": "greeks_analytics",
              "signature": "def get_status(self) -> dict",
              "docstring": "Get position limits status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1113
            }
          ],
          "class_attributes": [
            {
              "name": "SCENARIO_MULTIPLIERS",
              "type": "dict[ScenarioType, float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 864
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "numpy",
        "scipy"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "scipy"
      ]
    },
    "core.health_check": {
      "name": "health_check",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\health_check.py",
      "docstring": "Health Check Server\n===================\n\nHTTP health check endpoints for monitoring and orchestration systems.\nAddresses issue #S5: No health check endpoint for monitoring.\n\nFeatures:\n- Kubernetes-style liveness and readiness probes\n- Detailed health status with component checks\n- Prometheus-compatible metrics endpoint\n- Configurable health check criteria",
      "classes": [
        {
          "name": "HealthStatus",
          "module": "health_check",
          "docstring": "Health status levels.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 36
        },
        {
          "name": "ComponentHealth",
          "module": "health_check",
          "docstring": "Health status for a single component.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "status",
              "type": "HealthStatus"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "last_check",
              "type": "datetime"
            },
            {
              "name": "details",
              "type": "dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 44
        },
        {
          "name": "HealthCheckResult",
          "module": "health_check",
          "docstring": "Overall health check result.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "health_check",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary for JSON response.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 62
            }
          ],
          "class_attributes": [
            {
              "name": "status",
              "type": "HealthStatus"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "components",
              "type": "dict[str, ComponentHealth]"
            },
            {
              "name": "uptime_seconds",
              "type": "float"
            },
            {
              "name": "version",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 54
        },
        {
          "name": "HealthCheckConfig",
          "module": "health_check",
          "docstring": "Configuration for health check server.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "host",
              "type": "str"
            },
            {
              "name": "port",
              "type": "int"
            },
            {
              "name": "max_event_queue_pct",
              "type": "float"
            },
            {
              "name": "max_latency_ms",
              "type": "float"
            },
            {
              "name": "max_error_rate_pct",
              "type": "float"
            },
            {
              "name": "min_active_agents",
              "type": "int"
            },
            {
              "name": "broker_required",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 82
        },
        {
          "name": "HealthChecker",
          "module": "health_check",
          "docstring": "Health checking logic for the trading system.\n\nPerforms checks on:\n- Event bus health\n- Broker connectivity\n- Agent status\n- Resource utilization",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "health_check",
              "signature": "def __init__(self, config: , get_status_fn: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                },
                {
                  "name": "get_status_fn",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 105
            },
            {
              "name": "set_event_bus",
              "module": "health_check",
              "signature": "def set_event_bus(self, event_bus: EventBus) -> None",
              "docstring": "Set the event bus reference for health checks.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 118
            },
            {
              "name": "set_monitoring",
              "module": "health_check",
              "signature": "def set_monitoring(self, monitoring: MonitoringSystem) -> None",
              "docstring": "Set the monitoring system reference.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "monitoring",
                  "type": "MonitoringSystem"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 122
            },
            {
              "name": "set_ready",
              "module": "health_check",
              "signature": "def set_ready(self, ready: bool) -> None",
              "docstring": "Mark the system as ready (or not ready).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "ready",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 126
            },
            {
              "name": "add_custom_check",
              "module": "health_check",
              "signature": "def add_custom_check(self, check_fn: Callable[, ComponentHealth]) -> None",
              "docstring": "Add a custom health check function.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "check_fn",
                  "type": "Callable[, ComponentHealth]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 131
            },
            {
              "name": "check_liveness",
              "module": "health_check",
              "signature": "def check_liveness(self) -> tuple[bool, str]",
              "docstring": "Liveness probe - is the process alive and not deadlocked?\n\nReturns:\n    Tuple of (is_live, message)",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 135
            },
            {
              "name": "check_readiness",
              "module": "health_check",
              "signature": "def check_readiness(self) -> tuple[bool, str]",
              "docstring": "Readiness probe - is the system ready to accept work?\n\nReturns:\n    Tuple of (is_ready, message)",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 149
            },
            {
              "name": "_check_event_bus",
              "module": "health_check",
              "signature": "def _check_event_bus(self) -> ComponentHealth",
              "docstring": "Check event bus health.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "ComponentHealth",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 165
            },
            {
              "name": "_check_broker",
              "module": "health_check",
              "signature": "def _check_broker(self) -> ComponentHealth",
              "docstring": "Check broker connectivity.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "ComponentHealth",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 212
            },
            {
              "name": "_check_agents",
              "module": "health_check",
              "signature": "def _check_agents(self) -> ComponentHealth",
              "docstring": "Check agent health.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "ComponentHealth",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 247
            },
            {
              "name": "_check_monitoring",
              "module": "health_check",
              "signature": "def _check_monitoring(self) -> ComponentHealth",
              "docstring": "Check monitoring system health.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "ComponentHealth",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 309
            },
            {
              "name": "perform_health_check",
              "module": "health_check",
              "signature": "def perform_health_check(self) -> HealthCheckResult",
              "docstring": "Perform comprehensive health check.\n\nReturns:\n    HealthCheckResult with all component statuses",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "HealthCheckResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 344
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 94
        },
        {
          "name": "HealthCheckHandler",
          "module": "health_check",
          "docstring": "HTTP request handler for health check endpoints.",
          "bases": [
            "BaseHTTPRequestHandler"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "health_check",
              "signature": "def __init__(self, checker: HealthChecker)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "checker",
                  "type": "HealthChecker"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 394
            },
            {
              "name": "log_message",
              "module": "health_check",
              "signature": "def log_message(self, format: str) -> None",
              "docstring": "Suppress default logging, use our logger instead.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "format",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 398
            },
            {
              "name": "do_GET",
              "module": "health_check",
              "signature": "def do_GET(self) -> None",
              "docstring": "Handle GET requests.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 402
            },
            {
              "name": "_handle_health",
              "module": "health_check",
              "signature": "def _handle_health(self) -> None",
              "docstring": "Handle /health endpoint - comprehensive health check.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 417
            },
            {
              "name": "_handle_liveness",
              "module": "health_check",
              "signature": "def _handle_liveness(self) -> None",
              "docstring": "Handle /live endpoint - Kubernetes liveness probe.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 428
            },
            {
              "name": "_handle_readiness",
              "module": "health_check",
              "signature": "def _handle_readiness(self) -> None",
              "docstring": "Handle /ready endpoint - Kubernetes readiness probe.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 439
            },
            {
              "name": "_handle_metrics",
              "module": "health_check",
              "signature": "def _handle_metrics(self) -> None",
              "docstring": "Handle /metrics endpoint - Prometheus-compatible metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 450
            },
            {
              "name": "_send_response",
              "module": "health_check",
              "signature": "def _send_response(self, status_code: int, data: dict) -> None",
              "docstring": "Send JSON response.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "status_code",
                  "type": "int"
                },
                {
                  "name": "data",
                  "type": "dict"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 479
            },
            {
              "name": "_send_text_response",
              "module": "health_check",
              "signature": "def _send_text_response(self, status_code: int, content: str, content_type: str) -> None",
              "docstring": "Send text response.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "status_code",
                  "type": "int"
                },
                {
                  "name": "content",
                  "type": "str"
                },
                {
                  "name": "content_type",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 484
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 391
        },
        {
          "name": "HealthCheckServer",
          "module": "health_check",
          "docstring": "HTTP server for health check endpoints.\n\nRuns in a separate thread to avoid blocking the event loop.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "health_check",
              "signature": "def __init__(self, checker: HealthChecker, config: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "checker",
                  "type": "HealthChecker"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 502
            },
            {
              "name": "start",
              "module": "health_check",
              "signature": "def start(self) -> None",
              "docstring": "Start the health check server.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 513
            },
            {
              "name": "_run_server",
              "module": "health_check",
              "signature": "def _run_server(self) -> None",
              "docstring": "Server loop running in thread.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 546
            },
            {
              "name": "stop",
              "module": "health_check",
              "signature": "def stop(self) -> None",
              "docstring": "Stop the health check server.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 555
            },
            {
              "name": "is_running",
              "module": "health_check",
              "signature": "def is_running(self) -> bool",
              "docstring": "Check if server is running.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 573
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 495
        }
      ],
      "functions": [
        {
          "name": "create_health_check_server",
          "module": "health_check",
          "signature": "def create_health_check_server(get_status_fn: Callable[, dict[str, Any]], event_bus: EventBus | None, monitoring: MonitoringSystem | None, config: ) -> tuple[HealthChecker, HealthCheckServer]",
          "docstring": "Create a configured health check server.\n\nArgs:\n    get_status_fn: Function that returns system status dict\n    event_bus: Optional event bus reference\n    monitoring: Optional monitoring system reference\n    config: Optional configuration\n\nReturns:\n    Tuple of (HealthChecker, HealthCheckServer)",
          "parameters": [
            {
              "name": "get_status_fn",
              "type": "Callable[, dict[str, Any]]"
            },
            {
              "name": "event_bus",
              "type": "EventBus | None"
            },
            {
              "name": "monitoring",
              "type": "MonitoringSystem | None"
            },
            {
              "name": "config",
              "type": ""
            }
          ],
          "return_type": "tuple[HealthChecker, HealthCheckServer]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 579
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "http.server",
        "typing",
        "threading",
        "functools",
        "core.event_bus",
        "core.monitoring"
      ],
      "dependencies": [
        "__future__",
        "http.server",
        "threading",
        "core.event_bus",
        "core.monitoring"
      ]
    },
    "core.infrastructure_ops": {
      "name": "infrastructure_ops",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\infrastructure_ops.py",
      "docstring": "Infrastructure Operations Module\n\nAddresses MEDIUM priority issues:\n- #I15: Log aggregation framework\n- #I16: Application Performance Monitoring (APM)\n- #I17: Alert management and escalation\n- #I18: Chaos testing framework\n- #I19: Connection pooling\n- #I20: Cache warming strategies\n- #I21: Request tracing\n- #I22: Blue-green deployment support\n- #I23: Feature flags system\n\nProvides production-grade infrastructure components for trading systems.",
      "classes": [
        {
          "name": "LogLevel",
          "module": "infrastructure_ops",
          "docstring": "Log level enumeration.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 43
        },
        {
          "name": "AlertSeverity",
          "module": "infrastructure_ops",
          "docstring": "Alert severity levels.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 52
        },
        {
          "name": "AlertStatus",
          "module": "infrastructure_ops",
          "docstring": "Alert status.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 60
        },
        {
          "name": "DeploymentColor",
          "module": "infrastructure_ops",
          "docstring": "Blue-green deployment color.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 68
        },
        {
          "name": "FeatureFlagStatus",
          "module": "infrastructure_ops",
          "docstring": "Feature flag status.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 74
        },
        {
          "name": "ChaosExperimentType",
          "module": "infrastructure_ops",
          "docstring": "Types of chaos experiments.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 82
        },
        {
          "name": "LogEntry",
          "module": "infrastructure_ops",
          "docstring": "Structured log entry.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "level",
              "type": "LogLevel"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "service",
              "type": "str"
            },
            {
              "name": "component",
              "type": "str"
            },
            {
              "name": "trace_id",
              "type": "Optional[str]"
            },
            {
              "name": "span_id",
              "type": "Optional[str]"
            },
            {
              "name": "metadata",
              "type": "Dict[str, Any]"
            },
            {
              "name": "exception",
              "type": "Optional[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 92
        },
        {
          "name": "PerformanceMetric",
          "module": "infrastructure_ops",
          "docstring": "APM performance metric.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "value",
              "type": "float"
            },
            {
              "name": "unit",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "tags",
              "type": "Dict[str, str]"
            },
            {
              "name": "aggregation",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 106
        },
        {
          "name": "Alert",
          "module": "infrastructure_ops",
          "docstring": "Alert definition.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "id",
              "type": "str"
            },
            {
              "name": "severity",
              "type": "AlertSeverity"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "source",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "status",
              "type": "AlertStatus"
            },
            {
              "name": "acknowledged_by",
              "type": "Optional[str]"
            },
            {
              "name": "acknowledged_at",
              "type": "Optional[datetime]"
            },
            {
              "name": "resolved_at",
              "type": "Optional[datetime]"
            },
            {
              "name": "escalation_level",
              "type": "int"
            },
            {
              "name": "metadata",
              "type": "Dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 117
        },
        {
          "name": "TraceSpan",
          "module": "infrastructure_ops",
          "docstring": "Distributed trace span.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "trace_id",
              "type": "str"
            },
            {
              "name": "span_id",
              "type": "str"
            },
            {
              "name": "parent_span_id",
              "type": "Optional[str]"
            },
            {
              "name": "operation_name",
              "type": "str"
            },
            {
              "name": "service_name",
              "type": "str"
            },
            {
              "name": "start_time",
              "type": "datetime"
            },
            {
              "name": "end_time",
              "type": "Optional[datetime]"
            },
            {
              "name": "duration_ms",
              "type": "float"
            },
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "tags",
              "type": "Dict[str, str]"
            },
            {
              "name": "logs",
              "type": "List[Dict[str, Any]]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 134
        },
        {
          "name": "FeatureFlag",
          "module": "infrastructure_ops",
          "docstring": "Feature flag definition.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "status",
              "type": "FeatureFlagStatus"
            },
            {
              "name": "default_value",
              "type": "bool"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "percentage",
              "type": "float"
            },
            {
              "name": "user_segments",
              "type": "List[str]"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "updated_at",
              "type": "datetime"
            },
            {
              "name": "metadata",
              "type": "Dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 150
        },
        {
          "name": "ChaosExperiment",
          "module": "infrastructure_ops",
          "docstring": "Chaos experiment definition.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "id",
              "type": "str"
            },
            {
              "name": "experiment_type",
              "type": "ChaosExperimentType"
            },
            {
              "name": "target_service",
              "type": "str"
            },
            {
              "name": "parameters",
              "type": "Dict[str, Any]"
            },
            {
              "name": "duration_seconds",
              "type": "int"
            },
            {
              "name": "start_time",
              "type": "Optional[datetime]"
            },
            {
              "name": "end_time",
              "type": "Optional[datetime]"
            },
            {
              "name": "is_active",
              "type": "bool"
            },
            {
              "name": "results",
              "type": "Dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 164
        },
        {
          "name": "LogAggregator",
          "module": "infrastructure_ops",
          "docstring": "Centralized log aggregation system.\n\nFeatures:\n- Structured logging\n- Log buffering and batching\n- Multiple output destinations\n- Log correlation with trace IDs\n- Log level filtering\n- Log retention policies",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, service_name: str, buffer_size: int, flush_interval_seconds: int)",
              "docstring": "Initialize log aggregator.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_name",
                  "type": "str"
                },
                {
                  "name": "buffer_size",
                  "type": "int"
                },
                {
                  "name": "flush_interval_seconds",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 194
            },
            {
              "name": "start",
              "module": "infrastructure_ops",
              "signature": "def start(self) -> None",
              "docstring": "Start the log aggregator background flush thread.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 212
            },
            {
              "name": "stop",
              "module": "infrastructure_ops",
              "signature": "def stop(self) -> None",
              "docstring": "Stop the log aggregator and flush remaining logs.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 219
            },
            {
              "name": "add_output",
              "module": "infrastructure_ops",
              "signature": "def add_output(self, output_handler: Callable[, None]) -> None",
              "docstring": "Add an output destination for logs.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "output_handler",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 226
            },
            {
              "name": "add_filter",
              "module": "infrastructure_ops",
              "signature": "def add_filter(self, filter_func: Callable[, bool]) -> None",
              "docstring": "Add a log filter (returns True to keep log).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filter_func",
                  "type": "Callable[, bool]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 230
            },
            {
              "name": "set_trace_context",
              "module": "infrastructure_ops",
              "signature": "def set_trace_context(self, trace_id: str) -> None",
              "docstring": "Set current trace context for log correlation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trace_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 234
            },
            {
              "name": "clear_trace_context",
              "module": "infrastructure_ops",
              "signature": "def clear_trace_context(self) -> None",
              "docstring": "Clear current trace context.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 238
            },
            {
              "name": "log",
              "module": "infrastructure_ops",
              "signature": "def log(self, level: LogLevel, message: str, component: str, metadata: Optional[Dict[str, Any]], exception: Optional[str]) -> None",
              "docstring": "Log a message with structured data.\n\nArgs:\n    level: Log level\n    message: Log message\n    component: Component name\n    metadata: Additional metadata\n    exception: Exception string if any",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "level",
                  "type": "LogLevel"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "component",
                  "type": "str"
                },
                {
                  "name": "metadata",
                  "type": "Optional[Dict[str, Any]]"
                },
                {
                  "name": "exception",
                  "type": "Optional[str]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 242
            },
            {
              "name": "debug",
              "module": "infrastructure_ops",
              "signature": "def debug(self, message: str, component: str) -> None",
              "docstring": "Log debug message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "component",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 282
            },
            {
              "name": "info",
              "module": "infrastructure_ops",
              "signature": "def info(self, message: str, component: str) -> None",
              "docstring": "Log info message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "component",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 286
            },
            {
              "name": "warning",
              "module": "infrastructure_ops",
              "signature": "def warning(self, message: str, component: str) -> None",
              "docstring": "Log warning message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "component",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 290
            },
            {
              "name": "error",
              "module": "infrastructure_ops",
              "signature": "def error(self, message: str, component: str, exception: Optional[str]) -> None",
              "docstring": "Log error message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "component",
                  "type": "str"
                },
                {
                  "name": "exception",
                  "type": "Optional[str]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 294
            },
            {
              "name": "critical",
              "module": "infrastructure_ops",
              "signature": "def critical(self, message: str, component: str, exception: Optional[str]) -> None",
              "docstring": "Log critical message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "component",
                  "type": "str"
                },
                {
                  "name": "exception",
                  "type": "Optional[str]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 298
            },
            {
              "name": "flush",
              "module": "infrastructure_ops",
              "signature": "def flush(self) -> None",
              "docstring": "Flush buffered logs to outputs.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 302
            },
            {
              "name": "_flush_internal",
              "module": "infrastructure_ops",
              "signature": "def _flush_internal(self) -> None",
              "docstring": "Internal flush (must hold lock).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 307
            },
            {
              "name": "_flush_loop",
              "module": "infrastructure_ops",
              "signature": "def _flush_loop(self) -> None",
              "docstring": "Background flush loop.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 321
            },
            {
              "name": "search_logs",
              "module": "infrastructure_ops",
              "signature": "def search_logs(self, start_time: datetime, end_time: datetime, level: Optional[LogLevel], component: Optional[str], trace_id: Optional[str]) -> List[LogEntry]",
              "docstring": "Search logs (in-memory buffer only for this implementation).\n\nIn production, this would query a log storage backend.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_time",
                  "type": "datetime"
                },
                {
                  "name": "end_time",
                  "type": "datetime"
                },
                {
                  "name": "level",
                  "type": "Optional[LogLevel]"
                },
                {
                  "name": "component",
                  "type": "Optional[str]"
                },
                {
                  "name": "trace_id",
                  "type": "Optional[str]"
                }
              ],
              "return_type": "List[LogEntry]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 327
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 181
        },
        {
          "name": "APMCollector",
          "module": "infrastructure_ops",
          "docstring": "Application Performance Monitoring collector.\n\nFeatures:\n- Metric collection (counters, gauges, histograms)\n- Transaction tracing\n- Resource utilization tracking\n- SLA monitoring\n- Custom dashboards data",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, service_name: str, flush_interval_seconds: int)",
              "docstring": "Initialize APM collector.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_name",
                  "type": "str"
                },
                {
                  "name": "flush_interval_seconds",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 397
            },
            {
              "name": "record_metric",
              "module": "infrastructure_ops",
              "signature": "def record_metric(self, name: str, value: float, unit: str, tags: Optional[Dict[str, str]], aggregation: str) -> None",
              "docstring": "Record a performance metric.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                },
                {
                  "name": "unit",
                  "type": "str"
                },
                {
                  "name": "tags",
                  "type": "Optional[Dict[str, str]]"
                },
                {
                  "name": "aggregation",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 409
            },
            {
              "name": "increment_counter",
              "module": "infrastructure_ops",
              "signature": "def increment_counter(self, name: str, value: float, tags: Optional[Dict[str, str]]) -> None",
              "docstring": "Increment a counter metric.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                },
                {
                  "name": "tags",
                  "type": "Optional[Dict[str, str]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 437
            },
            {
              "name": "set_gauge",
              "module": "infrastructure_ops",
              "signature": "def set_gauge(self, name: str, value: float, unit: str, tags: Optional[Dict[str, str]]) -> None",
              "docstring": "Set a gauge metric.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                },
                {
                  "name": "unit",
                  "type": "str"
                },
                {
                  "name": "tags",
                  "type": "Optional[Dict[str, str]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 441
            },
            {
              "name": "record_histogram",
              "module": "infrastructure_ops",
              "signature": "def record_histogram(self, name: str, value: float, unit: str, tags: Optional[Dict[str, str]]) -> None",
              "docstring": "Record a histogram value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                },
                {
                  "name": "unit",
                  "type": "str"
                },
                {
                  "name": "tags",
                  "type": "Optional[Dict[str, str]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 445
            },
            {
              "name": "start_transaction",
              "module": "infrastructure_ops",
              "signature": "def start_transaction(self, transaction_name: str) -> TransactionContext",
              "docstring": "Start a transaction for timing.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "transaction_name",
                  "type": "str"
                }
              ],
              "return_type": "TransactionContext",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 449
            },
            {
              "name": "record_transaction_time",
              "module": "infrastructure_ops",
              "signature": "def record_transaction_time(self, transaction_name: str, duration_ms: float) -> None",
              "docstring": "Record a transaction duration.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "transaction_name",
                  "type": "str"
                },
                {
                  "name": "duration_ms",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 453
            },
            {
              "name": "set_sla_threshold",
              "module": "infrastructure_ops",
              "signature": "def set_sla_threshold(self, transaction_name: str, threshold_ms: float) -> None",
              "docstring": "Set SLA threshold for a transaction.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "transaction_name",
                  "type": "str"
                },
                {
                  "name": "threshold_ms",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 464
            },
            {
              "name": "get_counter",
              "module": "infrastructure_ops",
              "signature": "def get_counter(self, name: str) -> float",
              "docstring": "Get current counter value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 468
            },
            {
              "name": "get_gauge",
              "module": "infrastructure_ops",
              "signature": "def get_gauge(self, name: str) -> float",
              "docstring": "Get current gauge value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 473
            },
            {
              "name": "get_histogram_stats",
              "module": "infrastructure_ops",
              "signature": "def get_histogram_stats(self, name: str) -> Dict[str, float]",
              "docstring": "Get histogram statistics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "Dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 478
            },
            {
              "name": "get_transaction_stats",
              "module": "infrastructure_ops",
              "signature": "def get_transaction_stats(self, transaction_name: str) -> Dict[str, Any]",
              "docstring": "Get transaction timing statistics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "transaction_name",
                  "type": "str"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 501
            },
            {
              "name": "get_all_metrics",
              "module": "infrastructure_ops",
              "signature": "def get_all_metrics(self) -> Dict[str, Any]",
              "docstring": "Get all collected metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 533
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 385
        },
        {
          "name": "TransactionContext",
          "module": "infrastructure_ops",
          "docstring": "Context manager for transaction timing.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, apm: APMCollector, transaction_name: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "apm",
                  "type": "APMCollector"
                },
                {
                  "name": "transaction_name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 547
            },
            {
              "name": "__enter__",
              "module": "infrastructure_ops",
              "signature": "def __enter__(self) -> TransactionContext",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "TransactionContext",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 552
            },
            {
              "name": "__exit__",
              "module": "infrastructure_ops",
              "signature": "def __exit__(self, exc_type, exc_val, exc_tb) -> None",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exc_type"
                },
                {
                  "name": "exc_val"
                },
                {
                  "name": "exc_tb"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 556
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 544
        },
        {
          "name": "EscalationPolicy",
          "module": "infrastructure_ops",
          "docstring": "Escalation policy definition.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "levels",
              "type": "List[Dict[str, Any]]"
            },
            {
              "name": "repeat_interval_minutes",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 578
        },
        {
          "name": "AlertManager",
          "module": "infrastructure_ops",
          "docstring": "Alert management and escalation system.\n\nFeatures:\n- Alert creation and routing\n- Escalation policies\n- Alert grouping and deduplication\n- On-call integration\n- Alert suppression rules",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, service_name: str)",
              "docstring": "Initialize alert manager.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 597
            },
            {
              "name": "start",
              "module": "infrastructure_ops",
              "signature": "def start(self) -> None",
              "docstring": "Start the alert manager escalation thread.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 609
            },
            {
              "name": "stop",
              "module": "infrastructure_ops",
              "signature": "def stop(self) -> None",
              "docstring": "Stop the alert manager.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 616
            },
            {
              "name": "create_alert",
              "module": "infrastructure_ops",
              "signature": "def create_alert(self, severity: AlertSeverity, title: str, description: str, source: str, metadata: Optional[Dict[str, Any]], group_key: Optional[str]) -> Alert",
              "docstring": "Create a new alert.\n\nArgs:\n    severity: Alert severity\n    title: Alert title\n    description: Detailed description\n    source: Source component\n    metadata: Additional metadata\n    group_key: Key for alert grouping\n\nReturns:\n    Created alert",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                },
                {
                  "name": "title",
                  "type": "str"
                },
                {
                  "name": "description",
                  "type": "str"
                },
                {
                  "name": "source",
                  "type": "str"
                },
                {
                  "name": "metadata",
                  "type": "Optional[Dict[str, Any]]"
                },
                {
                  "name": "group_key",
                  "type": "Optional[str]"
                }
              ],
              "return_type": "Alert",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 622
            },
            {
              "name": "acknowledge_alert",
              "module": "infrastructure_ops",
              "signature": "def acknowledge_alert(self, alert_id: str, acknowledged_by: str) -> bool",
              "docstring": "Acknowledge an alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_id",
                  "type": "str"
                },
                {
                  "name": "acknowledged_by",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 699
            },
            {
              "name": "resolve_alert",
              "module": "infrastructure_ops",
              "signature": "def resolve_alert(self, alert_id: str) -> bool",
              "docstring": "Resolve an alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 713
            },
            {
              "name": "add_escalation_policy",
              "module": "infrastructure_ops",
              "signature": "def add_escalation_policy(self, policy: EscalationPolicy) -> None",
              "docstring": "Add an escalation policy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "policy",
                  "type": "EscalationPolicy"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 726
            },
            {
              "name": "add_notification_handler",
              "module": "infrastructure_ops",
              "signature": "def add_notification_handler(self, severity: AlertSeverity, handler: Callable[, None]) -> None",
              "docstring": "Add a notification handler for a severity level.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                },
                {
                  "name": "handler",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 730
            },
            {
              "name": "add_suppression_rule",
              "module": "infrastructure_ops",
              "signature": "def add_suppression_rule(self, rule: Callable[, bool]) -> None",
              "docstring": "Add an alert suppression rule (returns True to suppress).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "rule",
                  "type": "Callable[, bool]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 738
            },
            {
              "name": "get_open_alerts",
              "module": "infrastructure_ops",
              "signature": "def get_open_alerts(self, severity: Optional[AlertSeverity]) -> List[Alert]",
              "docstring": "Get all open alerts, optionally filtered by severity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "Optional[AlertSeverity]"
                }
              ],
              "return_type": "List[Alert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 742
            },
            {
              "name": "get_alert_statistics",
              "module": "infrastructure_ops",
              "signature": "def get_alert_statistics(self) -> Dict[str, Any]",
              "docstring": "Get alert statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 750
            },
            {
              "name": "_notify",
              "module": "infrastructure_ops",
              "signature": "def _notify(self, alert: Alert) -> None",
              "docstring": "Send notifications for an alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 778
            },
            {
              "name": "_escalation_loop",
              "module": "infrastructure_ops",
              "signature": "def _escalation_loop(self) -> None",
              "docstring": "Background escalation loop.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 787
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 585
        },
        {
          "name": "ChaosEngine",
          "module": "infrastructure_ops",
          "docstring": "Chaos engineering framework for resilience testing.\n\nFeatures:\n- Latency injection\n- Error injection\n- Resource exhaustion simulation\n- Network partition simulation\n- Dependency failure simulation",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self)",
              "docstring": "Initialize chaos engine.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 828
            },
            {
              "name": "create_experiment",
              "module": "infrastructure_ops",
              "signature": "def create_experiment(self, experiment_type: ChaosExperimentType, target_service: str, parameters: Dict[str, Any], duration_seconds: int) -> ChaosExperiment",
              "docstring": "Create a chaos experiment.\n\nArgs:\n    experiment_type: Type of chaos to inject\n    target_service: Target service name\n    parameters: Experiment-specific parameters\n    duration_seconds: How long to run the experiment\n\nReturns:\n    Created experiment",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "experiment_type",
                  "type": "ChaosExperimentType"
                },
                {
                  "name": "target_service",
                  "type": "str"
                },
                {
                  "name": "parameters",
                  "type": "Dict[str, Any]"
                },
                {
                  "name": "duration_seconds",
                  "type": "int"
                }
              ],
              "return_type": "ChaosExperiment",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 835
            },
            {
              "name": "start_experiment",
              "module": "infrastructure_ops",
              "signature": "def start_experiment(self, experiment_id: str) -> bool",
              "docstring": "Start a chaos experiment.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "experiment_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 872
            },
            {
              "name": "stop_experiment",
              "module": "infrastructure_ops",
              "signature": "def stop_experiment(self, experiment_id: str) -> bool",
              "docstring": "Stop a chaos experiment.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "experiment_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 896
            },
            {
              "name": "_setup_interceptor",
              "module": "infrastructure_ops",
              "signature": "def _setup_interceptor(self, experiment: ChaosExperiment) -> None",
              "docstring": "Set up chaos interceptor for experiment.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "experiment",
                  "type": "ChaosExperiment"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 913
            },
            {
              "name": "_teardown_interceptor",
              "module": "infrastructure_ops",
              "signature": "def _teardown_interceptor(self, experiment: ChaosExperiment) -> None",
              "docstring": "Remove chaos interceptor.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "experiment",
                  "type": "ChaosExperiment"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 926
            },
            {
              "name": "_maybe_raise",
              "module": "infrastructure_ops",
              "signature": "def _maybe_raise(self, error_rate: float, message: str) -> None",
              "docstring": "Maybe raise an error based on error rate.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "error_rate",
                  "type": "float"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 931
            },
            {
              "name": "inject_chaos",
              "module": "infrastructure_ops",
              "signature": "def inject_chaos(self, service_name: str, experiment_type: ChaosExperimentType) -> None",
              "docstring": "Inject chaos if there's an active experiment for this service/type.\n\nCall this from your code at points where you want chaos injection.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_name",
                  "type": "str"
                },
                {
                  "name": "experiment_type",
                  "type": "ChaosExperimentType"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 936
            },
            {
              "name": "get_active_experiments",
              "module": "infrastructure_ops",
              "signature": "def get_active_experiments(self) -> List[ChaosExperiment]",
              "docstring": "Get all active experiments.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "List[ChaosExperiment]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 947
            },
            {
              "name": "get_experiment_results",
              "module": "infrastructure_ops",
              "signature": "def get_experiment_results(self, experiment_id: str) -> Optional[Dict[str, Any]]",
              "docstring": "Get results for an experiment.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "experiment_id",
                  "type": "str"
                }
              ],
              "return_type": "Optional[Dict[str, Any]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 952
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 816
        },
        {
          "name": "PooledConnection",
          "module": "infrastructure_ops",
          "docstring": "Wrapper for pooled connections.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "connection",
              "type": "Any"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "last_used",
              "type": "datetime"
            },
            {
              "name": "use_count",
              "type": "int"
            },
            {
              "name": "is_healthy",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 979
        },
        {
          "name": "ConnectionPool",
          "module": "infrastructure_ops",
          "docstring": "Generic connection pool implementation.\n\nFeatures:\n- Min/max pool size\n- Connection health checking\n- Automatic connection recycling\n- Connection timeout handling\n- Pool statistics",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, factory: Callable[, T], min_size: int, max_size: int, max_idle_seconds: int, health_check: Optional[Callable[, bool]], cleanup: Optional[Callable[, None]])",
              "docstring": "Initialize connection pool.\n\nArgs:\n    factory: Function to create new connections\n    min_size: Minimum pool size\n    max_size: Maximum pool size\n    max_idle_seconds: Max idle time before recycling\n    health_check: Function to check connection health\n    cleanup: Function to cleanup connections",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "factory",
                  "type": "Callable[, T]"
                },
                {
                  "name": "min_size",
                  "type": "int"
                },
                {
                  "name": "max_size",
                  "type": "int"
                },
                {
                  "name": "max_idle_seconds",
                  "type": "int"
                },
                {
                  "name": "health_check",
                  "type": "Optional[Callable[, bool]]"
                },
                {
                  "name": "cleanup",
                  "type": "Optional[Callable[, None]]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1000
            },
            {
              "name": "_create_connection",
              "module": "infrastructure_ops",
              "signature": "def _create_connection(self) -> PooledConnection",
              "docstring": "Create a new pooled connection.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "PooledConnection",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1043
            },
            {
              "name": "acquire",
              "module": "infrastructure_ops",
              "signature": "def acquire(self, timeout: float) -> T",
              "docstring": "Acquire a connection from the pool.\n\nArgs:\n    timeout: Timeout in seconds\n\nReturns:\n    Connection object\n\nRaises:\n    TimeoutError if no connection available",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "timeout",
                  "type": "float"
                }
              ],
              "return_type": "T",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1056
            },
            {
              "name": "release",
              "module": "infrastructure_ops",
              "signature": "def release(self, connection: T) -> None",
              "docstring": "Release a connection back to the pool.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "connection",
                  "type": "T"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1107
            },
            {
              "name": "_is_connection_healthy",
              "module": "infrastructure_ops",
              "signature": "def _is_connection_healthy(self, pooled: PooledConnection) -> bool",
              "docstring": "Check if a connection is healthy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pooled",
                  "type": "PooledConnection"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1120
            },
            {
              "name": "_recycle_connection",
              "module": "infrastructure_ops",
              "signature": "def _recycle_connection(self, pooled: PooledConnection) -> None",
              "docstring": "Recycle an unhealthy or stale connection.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pooled",
                  "type": "PooledConnection"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1135
            },
            {
              "name": "get_stats",
              "module": "infrastructure_ops",
              "signature": "def get_stats(self) -> Dict[str, Any]",
              "docstring": "Get pool statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1158
            },
            {
              "name": "close",
              "module": "infrastructure_ops",
              "signature": "def close(self) -> None",
              "docstring": "Close all connections in the pool.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1168
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 988
        },
        {
          "name": "PooledConnectionContext",
          "module": "infrastructure_ops",
          "docstring": "Context manager for automatic connection release.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, pool: ConnectionPool)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pool",
                  "type": "ConnectionPool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1185
            },
            {
              "name": "__enter__",
              "module": "infrastructure_ops",
              "signature": "def __enter__(self) -> Any",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1189
            },
            {
              "name": "__exit__",
              "module": "infrastructure_ops",
              "signature": "def __exit__(self, exc_type, exc_val, exc_tb) -> None",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exc_type"
                },
                {
                  "name": "exc_val"
                },
                {
                  "name": "exc_tb"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1193
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1182
        },
        {
          "name": "CacheEntry",
          "module": "infrastructure_ops",
          "docstring": "Cache entry with metadata.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "key",
              "type": "str"
            },
            {
              "name": "value",
              "type": "Any"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "ttl_seconds",
              "type": "int"
            },
            {
              "name": "access_count",
              "type": "int"
            },
            {
              "name": "last_accessed",
              "type": "Optional[datetime]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1203
        },
        {
          "name": "CacheWarmer",
          "module": "infrastructure_ops",
          "docstring": "Cache warming and management system.\n\nFeatures:\n- Proactive cache warming\n- TTL-based expiration\n- LRU eviction\n- Warm-up strategies\n- Cache statistics",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, max_size: int, default_ttl_seconds: int)",
              "docstring": "Initialize cache warmer.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "max_size",
                  "type": "int"
                },
                {
                  "name": "default_ttl_seconds",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1225
            },
            {
              "name": "get",
              "module": "infrastructure_ops",
              "signature": "def get(self, key: str) -> Optional[Any]",
              "docstring": "Get value from cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "Optional[Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1243
            },
            {
              "name": "set",
              "module": "infrastructure_ops",
              "signature": "def set(self, key: str, value: Any, ttl_seconds: Optional[int]) -> None",
              "docstring": "Set value in cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "Any"
                },
                {
                  "name": "ttl_seconds",
                  "type": "Optional[int]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1264
            },
            {
              "name": "delete",
              "module": "infrastructure_ops",
              "signature": "def delete(self, key: str) -> bool",
              "docstring": "Delete key from cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1285
            },
            {
              "name": "_evict_lru",
              "module": "infrastructure_ops",
              "signature": "def _evict_lru(self) -> None",
              "docstring": "Evict least recently used entry.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1293
            },
            {
              "name": "add_warming_task",
              "module": "infrastructure_ops",
              "signature": "def add_warming_task(self, task: Callable[, Dict[str, Any]]) -> None",
              "docstring": "Add a cache warming task.\n\nTask should return a dict of {key: value} to cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "task",
                  "type": "Callable[, Dict[str, Any]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1307
            },
            {
              "name": "warm_cache",
              "module": "infrastructure_ops",
              "signature": "def warm_cache(self, ttl_seconds: Optional[int]) -> int",
              "docstring": "Execute all warming tasks and populate cache.\n\nReturns number of entries added.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "ttl_seconds",
                  "type": "Optional[int]"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1315
            },
            {
              "name": "get_or_set",
              "module": "infrastructure_ops",
              "signature": "def get_or_set(self, key: str, factory: Callable[, Any], ttl_seconds: Optional[int]) -> Any",
              "docstring": "Get from cache or compute and set.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "factory",
                  "type": "Callable[, Any]"
                },
                {
                  "name": "ttl_seconds",
                  "type": "Optional[int]"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1336
            },
            {
              "name": "get_stats",
              "module": "infrastructure_ops",
              "signature": "def get_stats(self) -> Dict[str, Any]",
              "docstring": "Get cache statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1351
            },
            {
              "name": "clear",
              "module": "infrastructure_ops",
              "signature": "def clear(self) -> None",
              "docstring": "Clear all cache entries.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1364
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1213
        },
        {
          "name": "RequestTracer",
          "module": "infrastructure_ops",
          "docstring": "Distributed request tracing system.\n\nFeatures:\n- Trace context propagation\n- Span creation and management\n- Cross-service tracing\n- Trace sampling\n- Trace export",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, service_name: str, sample_rate: float)",
              "docstring": "Initialize request tracer.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_name",
                  "type": "str"
                },
                {
                  "name": "sample_rate",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1398
            },
            {
              "name": "start_trace",
              "module": "infrastructure_ops",
              "signature": "def start_trace(self, operation_name: str) -> TraceSpan",
              "docstring": "Start a new trace.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation_name",
                  "type": "str"
                }
              ],
              "return_type": "TraceSpan",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1412
            },
            {
              "name": "start_span",
              "module": "infrastructure_ops",
              "signature": "def start_span(self, operation_name: str, parent_span: Optional[TraceSpan]) -> TraceSpan",
              "docstring": "Start a new span within current trace.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation_name",
                  "type": "str"
                },
                {
                  "name": "parent_span",
                  "type": "Optional[TraceSpan]"
                }
              ],
              "return_type": "TraceSpan",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1437
            },
            {
              "name": "end_span",
              "module": "infrastructure_ops",
              "signature": "def end_span(self, span: TraceSpan, status: str) -> None",
              "docstring": "End a span.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "span",
                  "type": "TraceSpan"
                },
                {
                  "name": "status",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1468
            },
            {
              "name": "add_span_tag",
              "module": "infrastructure_ops",
              "signature": "def add_span_tag(self, span: TraceSpan, key: str, value: str) -> None",
              "docstring": "Add a tag to a span.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "span",
                  "type": "TraceSpan"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1478
            },
            {
              "name": "add_span_log",
              "module": "infrastructure_ops",
              "signature": "def add_span_log(self, span: TraceSpan, message: str, fields: Optional[Dict[str, Any]]) -> None",
              "docstring": "Add a log entry to a span.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "span",
                  "type": "TraceSpan"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "fields",
                  "type": "Optional[Dict[str, Any]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1482
            },
            {
              "name": "add_exporter",
              "module": "infrastructure_ops",
              "signature": "def add_exporter(self, exporter: Callable[, None]) -> None",
              "docstring": "Add a trace exporter.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exporter",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1490
            },
            {
              "name": "get_trace",
              "module": "infrastructure_ops",
              "signature": "def get_trace(self, trace_id: str) -> List[TraceSpan]",
              "docstring": "Get all spans for a trace.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trace_id",
                  "type": "str"
                }
              ],
              "return_type": "List[TraceSpan]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1494
            },
            {
              "name": "_generate_id",
              "module": "infrastructure_ops",
              "signature": "def _generate_id(self) -> str",
              "docstring": "Generate a unique ID.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1499
            },
            {
              "name": "_create_noop_span",
              "module": "infrastructure_ops",
              "signature": "def _create_noop_span(self, operation_name: str) -> TraceSpan",
              "docstring": "Create a no-op span for sampled-out traces.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation_name",
                  "type": "str"
                }
              ],
              "return_type": "TraceSpan",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1505
            },
            {
              "name": "_export_trace",
              "module": "infrastructure_ops",
              "signature": "def _export_trace(self, trace_id: str) -> None",
              "docstring": "Export a completed trace.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trace_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1516
            },
            {
              "name": "inject_context",
              "module": "infrastructure_ops",
              "signature": "def inject_context(self, span: TraceSpan) -> Dict[str, str]",
              "docstring": "Inject trace context for propagation to other services.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "span",
                  "type": "TraceSpan"
                }
              ],
              "return_type": "Dict[str, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1527
            },
            {
              "name": "extract_context",
              "module": "infrastructure_ops",
              "signature": "def extract_context(self, headers: Dict[str, str]) -> Optional[Tuple[str, str]]",
              "docstring": "Extract trace context from propagated headers.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "headers",
                  "type": "Dict[str, str]"
                }
              ],
              "return_type": "Optional[Tuple[str, str]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1535
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1386
        },
        {
          "name": "SpanContext",
          "module": "infrastructure_ops",
          "docstring": "Context manager for automatic span management.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, tracer: RequestTracer, operation_name: str, parent: Optional[TraceSpan])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "tracer",
                  "type": "RequestTracer"
                },
                {
                  "name": "operation_name",
                  "type": "str"
                },
                {
                  "name": "parent",
                  "type": "Optional[TraceSpan]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1548
            },
            {
              "name": "__enter__",
              "module": "infrastructure_ops",
              "signature": "def __enter__(self) -> TraceSpan",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "TraceSpan",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1554
            },
            {
              "name": "__exit__",
              "module": "infrastructure_ops",
              "signature": "def __exit__(self, exc_type, exc_val, exc_tb) -> None",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exc_type"
                },
                {
                  "name": "exc_val"
                },
                {
                  "name": "exc_tb"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1558
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1545
        },
        {
          "name": "DeploymentInstance",
          "module": "infrastructure_ops",
          "docstring": "Deployment instance information.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "color",
              "type": "DeploymentColor"
            },
            {
              "name": "version",
              "type": "str"
            },
            {
              "name": "health_endpoint",
              "type": "str"
            },
            {
              "name": "weight",
              "type": "float"
            },
            {
              "name": "is_healthy",
              "type": "bool"
            },
            {
              "name": "last_health_check",
              "type": "Optional[datetime]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1584
        },
        {
          "name": "BlueGreenDeployer",
          "module": "infrastructure_ops",
          "docstring": "Blue-green deployment manager.\n\nFeatures:\n- Zero-downtime deployments\n- Traffic shifting\n- Health checking\n- Rollback support\n- Canary deployments",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self, service_name: str)",
              "docstring": "Initialize blue-green deployer.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1606
            },
            {
              "name": "register_deployment",
              "module": "infrastructure_ops",
              "signature": "def register_deployment(self, color: DeploymentColor, version: str, health_endpoint: str) -> None",
              "docstring": "Register a deployment instance.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "color",
                  "type": "DeploymentColor"
                },
                {
                  "name": "version",
                  "type": "str"
                },
                {
                  "name": "health_endpoint",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1615
            },
            {
              "name": "start_health_checks",
              "module": "infrastructure_ops",
              "signature": "def start_health_checks(self, interval_seconds: int) -> None",
              "docstring": "Start background health checking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "interval_seconds",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1633
            },
            {
              "name": "stop_health_checks",
              "module": "infrastructure_ops",
              "signature": "def stop_health_checks(self) -> None",
              "docstring": "Stop health checking.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1643
            },
            {
              "name": "_health_check_loop",
              "module": "infrastructure_ops",
              "signature": "def _health_check_loop(self, interval: int) -> None",
              "docstring": "Background health check loop.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "interval",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1649
            },
            {
              "name": "_perform_health_checks",
              "module": "infrastructure_ops",
              "signature": "def _perform_health_checks(self) -> None",
              "docstring": "Check health of all deployments.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1655
            },
            {
              "name": "set_active",
              "module": "infrastructure_ops",
              "signature": "def set_active(self, color: DeploymentColor) -> bool",
              "docstring": "Set the active deployment (100% traffic).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "color",
                  "type": "DeploymentColor"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1664
            },
            {
              "name": "shift_traffic",
              "module": "infrastructure_ops",
              "signature": "def shift_traffic(self, target_color: DeploymentColor, percentage: float) -> bool",
              "docstring": "Shift a percentage of traffic to target deployment.\n\nArgs:\n    target_color: Deployment to shift traffic to\n    percentage: Percentage of traffic (0-100)\n\nReturns:\n    True if successful",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "target_color",
                  "type": "DeploymentColor"
                },
                {
                  "name": "percentage",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1684
            },
            {
              "name": "get_deployment_for_request",
              "module": "infrastructure_ops",
              "signature": "def get_deployment_for_request(self) -> Optional[DeploymentInstance]",
              "docstring": "Get deployment to route a request to based on traffic weights.\n\nReturns:\n    Selected deployment instance",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Optional[DeploymentInstance]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1720
            },
            {
              "name": "rollback",
              "module": "infrastructure_ops",
              "signature": "def rollback(self) -> bool",
              "docstring": "Rollback to the inactive deployment.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1749
            },
            {
              "name": "get_status",
              "module": "infrastructure_ops",
              "signature": "def get_status(self) -> Dict[str, Any]",
              "docstring": "Get deployment status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1767
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1594
        },
        {
          "name": "FeatureFlagManager",
          "module": "infrastructure_ops",
          "docstring": "Feature flag management system.\n\nFeatures:\n- Boolean flags\n- Percentage rollouts\n- User segment targeting\n- A/B testing support\n- Flag analytics",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "infrastructure_ops",
              "signature": "def __init__(self)",
              "docstring": "Initialize feature flag manager.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1800
            },
            {
              "name": "create_flag",
              "module": "infrastructure_ops",
              "signature": "def create_flag(self, name: str, default_value: bool, description: str, status: FeatureFlagStatus) -> FeatureFlag",
              "docstring": "Create a new feature flag.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "default_value",
                  "type": "bool"
                },
                {
                  "name": "description",
                  "type": "str"
                },
                {
                  "name": "status",
                  "type": "FeatureFlagStatus"
                }
              ],
              "return_type": "FeatureFlag",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1807
            },
            {
              "name": "set_flag_status",
              "module": "infrastructure_ops",
              "signature": "def set_flag_status(self, name: str, status: FeatureFlagStatus) -> bool",
              "docstring": "Set flag status.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "status",
                  "type": "FeatureFlagStatus"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1828
            },
            {
              "name": "set_percentage_rollout",
              "module": "infrastructure_ops",
              "signature": "def set_percentage_rollout(self, name: str, percentage: float) -> bool",
              "docstring": "Set percentage rollout for a flag.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "percentage",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1840
            },
            {
              "name": "set_user_segments",
              "module": "infrastructure_ops",
              "signature": "def set_user_segments(self, name: str, segments: List[str]) -> bool",
              "docstring": "Set user segments for a flag.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "segments",
                  "type": "List[str]"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1856
            },
            {
              "name": "set_user_override",
              "module": "infrastructure_ops",
              "signature": "def set_user_override(self, user_id: str, flag_name: str, value: bool) -> None",
              "docstring": "Set a user-specific override for a flag.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "user_id",
                  "type": "str"
                },
                {
                  "name": "flag_name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1869
            },
            {
              "name": "is_enabled",
              "module": "infrastructure_ops",
              "signature": "def is_enabled(self, name: str, user_id: Optional[str], user_segments: Optional[List[str]], default: bool) -> bool",
              "docstring": "Check if a feature flag is enabled.\n\nArgs:\n    name: Flag name\n    user_id: Optional user ID for percentage/override checks\n    user_segments: Optional user segments for targeting\n    default: Default value if flag not found\n\nReturns:\n    True if flag is enabled",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "user_id",
                  "type": "Optional[str]"
                },
                {
                  "name": "user_segments",
                  "type": "Optional[List[str]]"
                },
                {
                  "name": "default",
                  "type": "bool"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1874
            },
            {
              "name": "_log_evaluation",
              "module": "infrastructure_ops",
              "signature": "def _log_evaluation(self, flag_name: str, user_id: Optional[str], result: bool, reason: str) -> None",
              "docstring": "Log flag evaluation for analytics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "flag_name",
                  "type": "str"
                },
                {
                  "name": "user_id",
                  "type": "Optional[str]"
                },
                {
                  "name": "result",
                  "type": "bool"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1934
            },
            {
              "name": "get_flag_analytics",
              "module": "infrastructure_ops",
              "signature": "def get_flag_analytics(self, name: str) -> Dict[str, Any]",
              "docstring": "Get analytics for a flag.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1954
            },
            {
              "name": "_group_by_key",
              "module": "infrastructure_ops",
              "signature": "def _group_by_key(self, items: List[Dict], key: str) -> Dict[str, int]",
              "docstring": "Group items by key and count.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "items",
                  "type": "List[Dict]"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "Dict[str, int]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1971
            },
            {
              "name": "get_all_flags",
              "module": "infrastructure_ops",
              "signature": "def get_all_flags(self) -> Dict[str, Dict[str, Any]]",
              "docstring": "Get all flags and their status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Dict[str, Any]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1978
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1788
        }
      ],
      "functions": [
        {
          "name": "console_log_output",
          "module": "infrastructure_ops",
          "signature": "def console_log_output(entries: List[LogEntry]) -> None",
          "docstring": "Console output handler for logs.",
          "parameters": [
            {
              "name": "entries",
              "type": "List[LogEntry]"
            }
          ],
          "return_type": "None",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 355
        },
        {
          "name": "json_log_output",
          "module": "infrastructure_ops",
          "signature": "def json_log_output(entries: List[LogEntry]) -> List[str]",
          "docstring": "JSON output handler for logs.",
          "parameters": [
            {
              "name": "entries",
              "type": "List[LogEntry]"
            }
          ],
          "return_type": "List[str]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 362
        },
        {
          "name": "apm_timed",
          "module": "infrastructure_ops",
          "signature": "def apm_timed(apm: APMCollector, transaction_name: str)",
          "docstring": "Decorator for automatic transaction timing.",
          "parameters": [
            {
              "name": "apm",
              "type": "APMCollector"
            },
            {
              "name": "transaction_name",
              "type": "str"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 562
        },
        {
          "name": "chaos_injection_point",
          "module": "infrastructure_ops",
          "signature": "def chaos_injection_point(engine: ChaosEngine, service_name: str, experiment_type: ChaosExperimentType)",
          "docstring": "Decorator to add chaos injection point to a function.",
          "parameters": [
            {
              "name": "engine",
              "type": "ChaosEngine"
            },
            {
              "name": "service_name",
              "type": "str"
            },
            {
              "name": "experiment_type",
              "type": "ChaosExperimentType"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 960
        },
        {
          "name": "cached",
          "module": "infrastructure_ops",
          "signature": "def cached(cache: CacheWarmer, ttl_seconds: Optional[int])",
          "docstring": "Decorator for automatic caching.",
          "parameters": [
            {
              "name": "cache",
              "type": "CacheWarmer"
            },
            {
              "name": "ttl_seconds",
              "type": "Optional[int]"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1370
        },
        {
          "name": "traced",
          "module": "infrastructure_ops",
          "signature": "def traced(tracer: RequestTracer, operation_name: Optional[str])",
          "docstring": "Decorator for automatic span creation.",
          "parameters": [
            {
              "name": "tracer",
              "type": "RequestTracer"
            },
            {
              "name": "operation_name",
              "type": "Optional[str]"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1566
        },
        {
          "name": "feature_flag",
          "module": "infrastructure_ops",
          "signature": "def feature_flag(manager: FeatureFlagManager, flag_name: str, default: bool)",
          "docstring": "Decorator for feature-flagged functions.",
          "parameters": [
            {
              "name": "manager",
              "type": "FeatureFlagManager"
            },
            {
              "name": "flag_name",
              "type": "str"
            },
            {
              "name": "default",
              "type": "bool"
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1994
        },
        {
          "name": "create_infrastructure_suite",
          "module": "infrastructure_ops",
          "signature": "def create_infrastructure_suite(service_name: str) -> Dict[str, Any]",
          "docstring": "Create a complete infrastructure suite.\n\nReturns:\n    Dictionary containing all infrastructure components",
          "parameters": [
            {
              "name": "service_name",
              "type": "str"
            }
          ],
          "return_type": "Dict[str, Any]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 2015
        }
      ],
      "constants": [
        {
          "name": "T",
          "line": 975
        }
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "random",
        "threading",
        "time",
        "abc",
        "collections",
        "dataclasses",
        "datetime",
        "enum",
        "functools",
        "queue",
        "typing",
        "weakref",
        "statistics",
        "statistics",
        "statistics"
      ],
      "dependencies": [
        "__future__",
        "hashlib",
        "random",
        "threading",
        "time",
        "abc",
        "queue",
        "weakref"
      ]
    },
    "core.logger": {
      "name": "logger",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\logger.py",
      "docstring": "Audit Logger\n============\n\nComprehensive logging for regulatory compliance (EU/AMF).\nAll decisions must be logged with timestamp, data sources, rationale, and responsible agent.",
      "classes": [
        {
          "name": "AuditEntry",
          "module": "logger",
          "docstring": "Single audit log entry.",
          "bases": [],
          "methods": [
            {
              "name": "to_json",
              "module": "logger",
              "signature": "def to_json(self) -> str",
              "docstring": "Convert to JSON string.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 35
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "str"
            },
            {
              "name": "entry_type",
              "type": "str"
            },
            {
              "name": "agent_name",
              "type": "str"
            },
            {
              "name": "event_id",
              "type": ""
            },
            {
              "name": "details",
              "type": "dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 27
        },
        {
          "name": "AuditLogger",
          "module": "logger",
          "docstring": "Audit logger for regulatory compliance.\n\nRequirements (EU/AMF):\n- All decisions logged with timestamp\n- Data sources recorded\n- Rationale documented\n- Responsible agent identified\n- Retention: 7 years (MiFID II)\n\nFeatures:\n- Rotating file handlers to prevent unbounded log growth\n- Configurable max file size and backup count\n- Both size-based and time-based rotation options",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "logger",
              "signature": "def __init__(self, audit_file: str, trade_file: str, decision_file: str, max_bytes: int, backup_count: int, log_max_bytes: int, log_backup_count: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "audit_file",
                  "type": "str"
                },
                {
                  "name": "trade_file",
                  "type": "str"
                },
                {
                  "name": "decision_file",
                  "type": "str"
                },
                {
                  "name": "max_bytes",
                  "type": "int"
                },
                {
                  "name": "backup_count",
                  "type": "int"
                },
                {
                  "name": "log_max_bytes",
                  "type": "int"
                },
                {
                  "name": "log_backup_count",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 63
            },
            {
              "name": "_setup_python_logging",
              "module": "logger",
              "signature": "def _setup_python_logging(self) -> None",
              "docstring": "Configure Python logging with rotation.\n\nUses RotatingFileHandler to prevent unbounded log growth.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 92
            },
            {
              "name": "_write_entry",
              "module": "logger",
              "signature": "def _write_entry(self, file_path: Path, entry: AuditEntry) -> None",
              "docstring": "Write entry to JSONL file with rotation support.\n\nChecks file size and rotates if necessary.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "file_path",
                  "type": "Path"
                },
                {
                  "name": "entry",
                  "type": "AuditEntry"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 135
            },
            {
              "name": "_check_rotation",
              "module": "logger",
              "signature": "def _check_rotation(self, file_path: Path) -> None",
              "docstring": "Check if file needs rotation and perform if necessary.\n\nFiles are rotated when they exceed max_bytes.\nOld files are renamed with numeric suffixes: file.1.jsonl, file.2.jsonl, etc.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "file_path",
                  "type": "Path"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 155
            },
            {
              "name": "get_log_stats",
              "module": "logger",
              "signature": "def get_log_stats(self) -> dict[str, Any]",
              "docstring": "Get statistics about log files.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            },
            {
              "name": "log_event",
              "module": "logger",
              "signature": "def log_event(self, event: Event) -> None",
              "docstring": "Log any event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "Event"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 226
            },
            {
              "name": "log_decision",
              "module": "logger",
              "signature": "def log_decision(self, agent_name: str, decision_id: str, symbol: str, action: str, quantity: int, rationale: str, data_sources: list[str], contributing_signals: list[str], conviction_score: float) -> None",
              "docstring": "Log a trading decision with full compliance data.\n\nThis is a critical audit function - all decisions MUST be logged.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                },
                {
                  "name": "decision_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "action",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "rationale",
                  "type": "str"
                },
                {
                  "name": "data_sources",
                  "type": "list[str]"
                },
                {
                  "name": "contributing_signals",
                  "type": "list[str]"
                },
                {
                  "name": "conviction_score",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 237
            },
            {
              "name": "log_trade",
              "module": "logger",
              "signature": "def log_trade(self, agent_name: str, order_id: str, symbol: str, side: str, quantity: int, price: float, commission: float, decision_id: str) -> None",
              "docstring": "Log a trade execution.\n\nLinks back to the original decision for audit trail.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "commission",
                  "type": "float"
                },
                {
                  "name": "decision_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 272
            },
            {
              "name": "log_risk_alert",
              "module": "logger",
              "signature": "def log_risk_alert(self, agent_name: str, alert_type: str, severity: str, message: str, current_value: float, threshold_value: float, halt_trading: bool) -> None",
              "docstring": "Log a risk alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                },
                {
                  "name": "alert_type",
                  "type": "str"
                },
                {
                  "name": "severity",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "current_value",
                  "type": "float"
                },
                {
                  "name": "threshold_value",
                  "type": "float"
                },
                {
                  "name": "halt_trading",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 306
            },
            {
              "name": "log_compliance_check",
              "module": "logger",
              "signature": "def log_compliance_check(self, decision_id: str, agent_name: str, approved: bool, checks: list[dict[str, Any]], rejection_code: , rejection_reason: ) -> None",
              "docstring": "Log a compliance check result.\n\nRequired for EU/AMF regulatory compliance - all compliance\ndecisions must be fully documented.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision_id",
                  "type": "str"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                },
                {
                  "name": "approved",
                  "type": "bool"
                },
                {
                  "name": "checks",
                  "type": "list[dict[str, Any]]"
                },
                {
                  "name": "rejection_code",
                  "type": ""
                },
                {
                  "name": "rejection_reason",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 338
            },
            {
              "name": "log_agent_event",
              "module": "logger",
              "signature": "def log_agent_event(self, agent_name: str, event_type: str, details: dict[str, Any]) -> None",
              "docstring": "Log an agent lifecycle event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "details",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 372
            },
            {
              "name": "log_system_event",
              "module": "logger",
              "signature": "def log_system_event(self, event_type: str, details: dict[str, Any]) -> None",
              "docstring": "Log a system-level event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "details",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 388
            },
            {
              "name": "get_decisions",
              "module": "logger",
              "signature": "def get_decisions(self, start_date: , end_date: , symbol: ) -> list[dict]",
              "docstring": "Query decision history for audit.\n\nReturns decisions matching the criteria.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                },
                {
                  "name": "symbol",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 404
            },
            {
              "name": "get_trades",
              "module": "logger",
              "signature": "def get_trades(self, start_date: , end_date: ) -> list[dict]",
              "docstring": "Query trade history for audit.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 440
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 40
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "os",
        "dataclasses",
        "datetime",
        "logging.handlers",
        "pathlib",
        "typing",
        "core.events"
      ],
      "dependencies": [
        "__future__",
        "core.events"
      ]
    },
    "core.logging_config": {
      "name": "logging_config",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\logging_config.py",
      "docstring": "Logging Configuration Module\n============================\n\nAddresses issues:\n- #Q24: Logging verbosity inconsistent\n- #R30: Logging of risk calculations verbose\n\nFeatures:\n- Centralized logging configuration\n- Consistent verbosity levels across modules\n- Module-specific log level overrides\n- Performance logging with timing\n- Structured context injection\n- Log filtering and sampling for high-frequency events",
      "classes": [
        {
          "name": "LogLevel",
          "module": "logging_config",
          "docstring": "Standard log levels.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 32
        },
        {
          "name": "LoggingConfig",
          "module": "logging_config",
          "docstring": "Centralized logging configuration.\n\nProvides consistent verbosity across the trading system.",
          "bases": [],
          "methods": [
            {
              "name": "apply",
              "module": "logging_config",
              "signature": "def apply(self) -> None",
              "docstring": "Apply logging configuration to all handlers.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 94
            },
            {
              "name": "set_module_level",
              "module": "logging_config",
              "signature": "def set_module_level(self, module_name: str, level: int) -> None",
              "docstring": "Set log level for a specific module.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "module_name",
                  "type": "str"
                },
                {
                  "name": "level",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 116
            },
            {
              "name": "set_all_debug",
              "module": "logging_config",
              "signature": "def set_all_debug(self) -> None",
              "docstring": "Set all loggers to DEBUG (for debugging).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 122
            },
            {
              "name": "set_production_mode",
              "module": "logging_config",
              "signature": "def set_production_mode(self) -> None",
              "docstring": "Set production-appropriate log levels.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 127
            }
          ],
          "class_attributes": [
            {
              "name": "root_level",
              "type": "int"
            },
            {
              "name": "format_string",
              "type": "str"
            },
            {
              "name": "date_format",
              "type": "str"
            },
            {
              "name": "module_levels",
              "type": "dict[str, int]"
            },
            {
              "name": "sample_rate",
              "type": "float"
            },
            {
              "name": "sampled_messages",
              "type": "set[str]"
            },
            {
              "name": "slow_operation_threshold_ms",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 76
        },
        {
          "name": "LogSampler",
          "module": "logging_config",
          "docstring": "Samples high-frequency log messages to reduce noise.\n\nUseful for risk calculations and market data updates.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "logging_config",
              "signature": "def __init__(self, sample_rate: float, time_window_seconds: float)",
              "docstring": "Initialize sampler.\n\nArgs:\n    sample_rate: Fraction of messages to log (0.0-1.0)\n    time_window_seconds: Window for rate limiting",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "sample_rate",
                  "type": "float"
                },
                {
                  "name": "time_window_seconds",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 142
            },
            {
              "name": "should_log",
              "module": "logging_config",
              "signature": "def should_log(self, message_key: str) -> bool",
              "docstring": "Determine if a message should be logged.\n\nArgs:\n    message_key: Unique key for the message type\n\nReturns:\n    True if message should be logged",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message_key",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 155
            },
            {
              "name": "get_suppressed_count",
              "module": "logging_config",
              "signature": "def get_suppressed_count(self, message_key: str) -> int",
              "docstring": "Get count of suppressed messages for a key.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message_key",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 183
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 135
        },
        {
          "name": "RateLimitedLogger",
          "module": "logging_config",
          "docstring": "Logger wrapper that rate-limits specific message types.\n\nPrevents log flooding from high-frequency events.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "logging_config",
              "signature": "def __init__(self, logger: logging.Logger, max_per_minute: int, summary_interval_seconds: float)",
              "docstring": "Initialize rate-limited logger.\n\nArgs:\n    logger: Underlying logger\n    max_per_minute: Max messages per minute per key\n    summary_interval_seconds: Interval for summary messages",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "logger",
                  "type": "logging.Logger"
                },
                {
                  "name": "max_per_minute",
                  "type": "int"
                },
                {
                  "name": "summary_interval_seconds",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            },
            {
              "name": "log",
              "module": "logging_config",
              "signature": "def log(self, level: int, message: str, rate_limit_key: ) -> None",
              "docstring": "Log message with optional rate limiting.\n\nArgs:\n    level: Log level\n    message: Log message\n    rate_limit_key: Key for rate limiting (None = no limit)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "level",
                  "type": "int"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "rate_limit_key",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 222
            },
            {
              "name": "info",
              "module": "logging_config",
              "signature": "def info(self, message: str, rate_limit_key: )",
              "docstring": "Log at INFO level.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "rate_limit_key",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 270
            },
            {
              "name": "debug",
              "module": "logging_config",
              "signature": "def debug(self, message: str, rate_limit_key: )",
              "docstring": "Log at DEBUG level.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "rate_limit_key",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 274
            },
            {
              "name": "warning",
              "module": "logging_config",
              "signature": "def warning(self, message: str, rate_limit_key: )",
              "docstring": "Log at WARNING level.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "rate_limit_key",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 278
            },
            {
              "name": "error",
              "module": "logging_config",
              "signature": "def error(self, message: str, rate_limit_key: )",
              "docstring": "Log at ERROR level.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "rate_limit_key",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 282
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 193
        },
        {
          "name": "PerformanceLogger",
          "module": "logging_config",
          "docstring": "Logs performance metrics for operations.\n\nUseful for identifying slow operations and bottlenecks.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "logging_config",
              "signature": "def __init__(self, logger: logging.Logger, slow_threshold_ms: float, always_log_slow: bool)",
              "docstring": "Initialize performance logger.\n\nArgs:\n    logger: Underlying logger\n    slow_threshold_ms: Threshold for slow operation warning\n    always_log_slow: Always log operations exceeding threshold",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "logger",
                  "type": "logging.Logger"
                },
                {
                  "name": "slow_threshold_ms",
                  "type": "float"
                },
                {
                  "name": "always_log_slow",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 294
            },
            {
              "name": "measure",
              "module": "logging_config",
              "signature": "def measure(self, operation_name: str, log_always: bool)",
              "docstring": "Context manager to measure operation duration.\n\nArgs:\n    operation_name: Name of the operation\n    log_always: Log even if under threshold\n\nYields:\n    None\n\nExample:\n    with perf_logger.measure(\"var_calculation\"):\n        result = calculate_var()",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation_name",
                  "type": "str"
                },
                {
                  "name": "log_always",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "contextmanager"
              ],
              "is_async": false,
              "line_number": 315
            },
            {
              "name": "get_stats",
              "module": "logging_config",
              "signature": "def get_stats(self, operation_name: str) -> dict[str, float]",
              "docstring": "Get performance statistics for an operation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation_name",
                  "type": "str"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 348
            },
            {
              "name": "log_summary",
              "module": "logging_config",
              "signature": "def log_summary(self) -> None",
              "docstring": "Log summary of all operation statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 367
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 287
        },
        {
          "name": "ContextLogger",
          "module": "logging_config",
          "docstring": "Logger with automatic context injection.\n\nAdds consistent context (strategy, symbol, etc.) to all messages.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "logging_config",
              "signature": "def __init__(self, logger: logging.Logger, context: )",
              "docstring": "Initialize context logger.\n\nArgs:\n    logger: Underlying logger\n    context: Default context to inject",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "logger",
                  "type": "logging.Logger"
                },
                {
                  "name": "context",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 435
            },
            {
              "name": "with_context",
              "module": "logging_config",
              "signature": "def with_context(self) -> ContextLogger",
              "docstring": "Create new logger with additional context.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "ContextLogger",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 447
            },
            {
              "name": "temporary_context",
              "module": "logging_config",
              "signature": "def temporary_context(self)",
              "docstring": "Temporarily add context for a block of code.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "contextmanager"
              ],
              "is_async": false,
              "line_number": 453
            },
            {
              "name": "_format_message",
              "module": "logging_config",
              "signature": "def _format_message(self, message: str) -> str",
              "docstring": "Format message with context.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 462
            },
            {
              "name": "debug",
              "module": "logging_config",
              "signature": "def debug(self, message: str)",
              "docstring": "Log at DEBUG level with context.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 470
            },
            {
              "name": "info",
              "module": "logging_config",
              "signature": "def info(self, message: str)",
              "docstring": "Log at INFO level with context.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 474
            },
            {
              "name": "warning",
              "module": "logging_config",
              "signature": "def warning(self, message: str)",
              "docstring": "Log at WARNING level with context.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 478
            },
            {
              "name": "error",
              "module": "logging_config",
              "signature": "def error(self, message: str)",
              "docstring": "Log at ERROR level with context.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 482
            },
            {
              "name": "exception",
              "module": "logging_config",
              "signature": "def exception(self, message: str)",
              "docstring": "Log exception with context.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 486
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 428
        }
      ],
      "functions": [
        {
          "name": "timed",
          "module": "logging_config",
          "signature": "def timed(logger: , threshold_ms: float, operation_name: )",
          "docstring": "Decorator to time function execution.\n\nArgs:\n    logger: Logger to use (default: function's module logger)\n    threshold_ms: Log warning if exceeds this threshold\n    operation_name: Custom operation name (default: function name)\n\nExample:\n    @timed(threshold_ms=50.0)\n    def calculate_var():\n        ...",
          "parameters": [
            {
              "name": "logger",
              "type": ""
            },
            {
              "name": "threshold_ms",
              "type": "float"
            },
            {
              "name": "operation_name",
              "type": ""
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 383
        },
        {
          "name": "configure_logging",
          "module": "logging_config",
          "signature": "def configure_logging(config: ) -> LoggingConfig",
          "docstring": "Configure logging for the trading system.\n\nArgs:\n    config: Optional custom configuration\n\nReturns:\n    Applied configuration",
          "parameters": [
            {
              "name": "config",
              "type": ""
            }
          ],
          "return_type": "LoggingConfig",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 495
        },
        {
          "name": "get_logging_config",
          "module": "logging_config",
          "signature": "def get_logging_config() -> LoggingConfig",
          "docstring": "Get current logging configuration.",
          "parameters": [],
          "return_type": "LoggingConfig",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 516
        },
        {
          "name": "get_rate_limited_logger",
          "module": "logging_config",
          "signature": "def get_rate_limited_logger(name: str, max_per_minute: int) -> RateLimitedLogger",
          "docstring": "Get a rate-limited logger for a module.\n\nArgs:\n    name: Logger name\n    max_per_minute: Max messages per minute\n\nReturns:\n    Rate-limited logger",
          "parameters": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "max_per_minute",
              "type": "int"
            }
          ],
          "return_type": "RateLimitedLogger",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 527
        },
        {
          "name": "get_performance_logger",
          "module": "logging_config",
          "signature": "def get_performance_logger(name: str, slow_threshold_ms: float) -> PerformanceLogger",
          "docstring": "Get a performance logger for a module.\n\nArgs:\n    name: Logger name\n    slow_threshold_ms: Threshold for slow operation warning\n\nReturns:\n    Performance logger",
          "parameters": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "slow_threshold_ms",
              "type": "float"
            }
          ],
          "return_type": "PerformanceLogger",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 544
        },
        {
          "name": "get_context_logger",
          "module": "logging_config",
          "signature": "def get_context_logger(name: str) -> ContextLogger",
          "docstring": "Get a context logger for a module.\n\nArgs:\n    name: Logger name\n    **context: Initial context\n\nReturns:\n    Context logger",
          "parameters": [
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "ContextLogger",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 561
        }
      ],
      "constants": [
        {
          "name": "MODULE_LOG_LEVELS",
          "line": 42
        }
      ],
      "imports": [
        "__future__",
        "logging",
        "time",
        "functools",
        "contextlib",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "threading",
        "random",
        "statistics"
      ],
      "dependencies": [
        "__future__",
        "time",
        "contextlib",
        "threading",
        "random"
      ]
    },
    "core.margin_optimizer": {
      "name": "margin_optimizer",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\margin_optimizer.py",
      "docstring": "Margin Optimization Module\n==========================\n\nCross-margin benefit calculation and optimization (Issue #R14).\nRisk contribution attribution by strategy (Issue #R16).\n\nFeatures:\n- Portfolio margin vs Reg-T comparison\n- Cross-margin benefits for hedged positions\n- Risk contribution by strategy\n- Margin efficiency optimization",
      "classes": [
        {
          "name": "MarginType",
          "module": "margin_optimizer",
          "docstring": "Margin calculation methodology.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 27
        },
        {
          "name": "PositionMargin",
          "module": "margin_optimizer",
          "docstring": "Margin requirement for a single position.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "margin_optimizer",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 55
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "market_value",
              "type": "float"
            },
            {
              "name": "reg_t_margin",
              "type": "float"
            },
            {
              "name": "portfolio_margin",
              "type": "float"
            },
            {
              "name": "span_margin",
              "type": ""
            },
            {
              "name": "hedging_offset",
              "type": "float"
            },
            {
              "name": "correlation_offset",
              "type": "float"
            },
            {
              "name": "effective_margin",
              "type": "float"
            },
            {
              "name": "margin_type_used",
              "type": "MarginType"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 36
        },
        {
          "name": "CrossMarginBenefit",
          "module": "margin_optimizer",
          "docstring": "Cross-margin benefit analysis.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "margin_optimizer",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 93
            }
          ],
          "class_attributes": [
            {
              "name": "position1_symbol",
              "type": "str"
            },
            {
              "name": "position2_symbol",
              "type": "str"
            },
            {
              "name": "position1_standalone_margin",
              "type": "float"
            },
            {
              "name": "position2_standalone_margin",
              "type": "float"
            },
            {
              "name": "combined_standalone",
              "type": "float"
            },
            {
              "name": "combined_cross_margin",
              "type": "float"
            },
            {
              "name": "margin_savings",
              "type": "float"
            },
            {
              "name": "savings_pct",
              "type": "float"
            },
            {
              "name": "correlation",
              "type": "float"
            },
            {
              "name": "hedge_ratio",
              "type": "float"
            },
            {
              "name": "benefit_type",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 71
        },
        {
          "name": "StrategyRiskContribution",
          "module": "margin_optimizer",
          "docstring": "Risk contribution by strategy (#R16).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "margin_optimizer",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 135
            }
          ],
          "class_attributes": [
            {
              "name": "strategy_name",
              "type": "str"
            },
            {
              "name": "positions",
              "type": "list[str]"
            },
            {
              "name": "gross_exposure",
              "type": "float"
            },
            {
              "name": "net_exposure",
              "type": "float"
            },
            {
              "name": "var_contribution",
              "type": "float"
            },
            {
              "name": "var_contribution_pct",
              "type": "float"
            },
            {
              "name": "marginal_var",
              "type": "float"
            },
            {
              "name": "margin_required",
              "type": "float"
            },
            {
              "name": "margin_pct_of_portfolio",
              "type": "float"
            },
            {
              "name": "sharpe_ratio",
              "type": ""
            },
            {
              "name": "return_on_margin",
              "type": ""
            },
            {
              "name": "risk_adjusted_return",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 110
        },
        {
          "name": "CrossMarginCalculator",
          "module": "margin_optimizer",
          "docstring": "Calculates cross-margin benefits (#R14).\n\nIdentifies margin savings from hedged positions and correlated assets.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "margin_optimizer",
              "signature": "def __init__(self, correlation_threshold: float, hedge_ratio_tolerance: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "correlation_threshold",
                  "type": "float"
                },
                {
                  "name": "hedge_ratio_tolerance",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 179
            },
            {
              "name": "set_correlation",
              "module": "margin_optimizer",
              "signature": "def set_correlation(self, symbol1: str, symbol2: str, correlation: float) -> None",
              "docstring": "Set correlation between two symbols.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol1",
                  "type": "str"
                },
                {
                  "name": "symbol2",
                  "type": "str"
                },
                {
                  "name": "correlation",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 199
            },
            {
              "name": "set_asset_type",
              "module": "margin_optimizer",
              "signature": "def set_asset_type(self, symbol: str, asset_type: str) -> None",
              "docstring": "Set asset type for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "asset_type",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 204
            },
            {
              "name": "set_beta",
              "module": "margin_optimizer",
              "signature": "def set_beta(self, symbol: str, beta: float) -> None",
              "docstring": "Set beta for hedge ratio calculation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "beta",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 208
            },
            {
              "name": "update_position",
              "module": "margin_optimizer",
              "signature": "def update_position(self, symbol: str, quantity: int, price: float, asset_type: ) -> None",
              "docstring": "Update position data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "asset_type",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 212
            },
            {
              "name": "calculate_position_margins",
              "module": "margin_optimizer",
              "signature": "def calculate_position_margins(self) -> dict[str, PositionMargin]",
              "docstring": "Calculate margin for all positions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, PositionMargin]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 230
            },
            {
              "name": "find_cross_margin_benefits",
              "module": "margin_optimizer",
              "signature": "def find_cross_margin_benefits(self) -> list[CrossMarginBenefit]",
              "docstring": "Find all cross-margin benefits in the portfolio.\n\nAnalyzes pairs of positions for hedging/correlation benefits.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[CrossMarginBenefit]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 258
            },
            {
              "name": "_analyze_pair_benefit",
              "module": "margin_optimizer",
              "signature": "def _analyze_pair_benefit(self, symbol1: str, symbol2: str)",
              "docstring": "Analyze cross-margin benefit for a pair.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol1",
                  "type": "str"
                },
                {
                  "name": "symbol2",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 277
            },
            {
              "name": "calculate_portfolio_margin_summary",
              "module": "margin_optimizer",
              "signature": "def calculate_portfolio_margin_summary(self) -> dict",
              "docstring": "Calculate total portfolio margin with cross-benefits.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 382
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 152
        },
        {
          "name": "RiskContributionAnalyzer",
          "module": "margin_optimizer",
          "docstring": "Analyzes risk contribution by strategy (#R16).\n\nDecomposes portfolio risk into strategy components.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "margin_optimizer",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 417
            },
            {
              "name": "register_strategy_position",
              "module": "margin_optimizer",
              "signature": "def register_strategy_position(self, strategy: str, symbol: str, quantity: int, market_value: float, volatility: ) -> None",
              "docstring": "Register a position under a strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "market_value",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 431
            },
            {
              "name": "set_correlation",
              "module": "margin_optimizer",
              "signature": "def set_correlation(self, symbol1: str, symbol2: str, correlation: float) -> None",
              "docstring": "Set correlation between symbols.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol1",
                  "type": "str"
                },
                {
                  "name": "symbol2",
                  "type": "str"
                },
                {
                  "name": "correlation",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 451
            },
            {
              "name": "set_strategy_performance",
              "module": "margin_optimizer",
              "signature": "def set_strategy_performance(self, strategy: str, returns: list[float], sharpe_ratio: float) -> None",
              "docstring": "Set historical performance for a strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "returns",
                  "type": "list[float]"
                },
                {
                  "name": "sharpe_ratio",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 456
            },
            {
              "name": "calculate_strategy_var",
              "module": "margin_optimizer",
              "signature": "def calculate_strategy_var(self, strategy: str, confidence: float) -> float",
              "docstring": "Calculate VaR for a single strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "confidence",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 466
            },
            {
              "name": "calculate_marginal_var",
              "module": "margin_optimizer",
              "signature": "def calculate_marginal_var(self, strategy: str, portfolio_var: float, confidence: float) -> float",
              "docstring": "Calculate marginal VaR contribution of a strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "portfolio_var",
                  "type": "float"
                },
                {
                  "name": "confidence",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 507
            },
            {
              "name": "_calculate_combined_var",
              "module": "margin_optimizer",
              "signature": "def _calculate_combined_var(self, strategies: list[str], confidence: float) -> float",
              "docstring": "Calculate combined VaR for multiple strategies.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategies",
                  "type": "list[str]"
                },
                {
                  "name": "confidence",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 524
            },
            {
              "name": "analyze_all_strategies",
              "module": "margin_optimizer",
              "signature": "def analyze_all_strategies(self, total_margin: float, confidence: float) -> list[StrategyRiskContribution]",
              "docstring": "Analyze risk contribution for all strategies.\n\nReturns list of StrategyRiskContribution sorted by VaR contribution.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "total_margin",
                  "type": "float"
                },
                {
                  "name": "confidence",
                  "type": "float"
                }
              ],
              "return_type": "list[StrategyRiskContribution]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 567
            },
            {
              "name": "get_risk_attribution_summary",
              "module": "margin_optimizer",
              "signature": "def get_risk_attribution_summary(self, total_margin: float, confidence: float) -> dict",
              "docstring": "Generate full risk attribution summary.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "total_margin",
                  "type": "float"
                },
                {
                  "name": "confidence",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 634
            },
            {
              "name": "clear_all",
              "module": "margin_optimizer",
              "signature": "def clear_all(self) -> None",
              "docstring": "Clear all data for reset.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 661
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 410
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.metrics_export": {
      "name": "metrics_export",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\metrics_export.py",
      "docstring": "Strategy Performance Metrics Export\n===================================\n\nAddresses issue #Q23: No strategy performance metrics export.\n\nFeatures:\n- Export performance metrics to multiple formats (JSON, CSV, HTML, Excel)\n- Standardized metric definitions\n- Time-series export support\n- Compliance-ready reporting formats",
      "classes": [
        {
          "name": "ExportFormat",
          "module": "metrics_export",
          "docstring": "Supported export formats.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 29
        },
        {
          "name": "MetricCategory",
          "module": "metrics_export",
          "docstring": "Categories for organizing metrics.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 38
        },
        {
          "name": "MetricDefinition",
          "module": "metrics_export",
          "docstring": "Definition of a performance metric.\n\nProvides standardized descriptions and formatting for compliance reporting.",
          "bases": [],
          "methods": [
            {
              "name": "format_value",
              "module": "metrics_export",
              "signature": "def format_value(self, value: float) -> str",
              "docstring": "Format value according to metric definition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 63
            }
          ],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "display_name",
              "type": "str"
            },
            {
              "name": "category",
              "type": "MetricCategory"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "unit",
              "type": "str"
            },
            {
              "name": "decimal_places",
              "type": "int"
            },
            {
              "name": "is_higher_better",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 49
        },
        {
          "name": "PerformanceSnapshot",
          "module": "metrics_export",
          "docstring": "Snapshot of strategy performance at a point in time.\n\nSupports time-series export of performance metrics.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "metrics_export",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 237
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "strategy_name",
              "type": "str"
            },
            {
              "name": "metrics",
              "type": "dict[str, float]"
            },
            {
              "name": "positions",
              "type": "dict[str, Any]"
            },
            {
              "name": "metadata",
              "type": "dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 225
        },
        {
          "name": "PerformanceMetricsExporter",
          "module": "metrics_export",
          "docstring": "Exports strategy performance metrics to various formats (#Q23).\n\nSupports:\n- Single snapshot export\n- Time-series export\n- Multi-strategy comparison\n- Compliance-ready formats",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "metrics_export",
              "signature": "def __init__(self, output_dir: str, include_definitions: bool)",
              "docstring": "Initialize exporter.\n\nArgs:\n    output_dir: Directory for exported files\n    include_definitions: Include metric definitions in exports",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "output_dir",
                  "type": "str"
                },
                {
                  "name": "include_definitions",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 259
            },
            {
              "name": "add_snapshot",
              "module": "metrics_export",
              "signature": "def add_snapshot(self, snapshot: PerformanceSnapshot) -> None",
              "docstring": "Add performance snapshot for time-series export.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "snapshot",
                  "type": "PerformanceSnapshot"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 276
            },
            {
              "name": "export_metrics",
              "module": "metrics_export",
              "signature": "def export_metrics(self, metrics: dict[str, float], strategy_name: str, format: ExportFormat, filename: , metadata: ) -> str",
              "docstring": "Export metrics to file.\n\nArgs:\n    metrics: Dictionary of metric name to value\n    strategy_name: Name of the strategy\n    format: Export format\n    filename: Optional custom filename\n    metadata: Additional metadata to include\n\nReturns:\n    Path to exported file",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metrics",
                  "type": "dict[str, float]"
                },
                {
                  "name": "strategy_name",
                  "type": "str"
                },
                {
                  "name": "format",
                  "type": "ExportFormat"
                },
                {
                  "name": "filename",
                  "type": ""
                },
                {
                  "name": "metadata",
                  "type": ""
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 280
            },
            {
              "name": "_export_json",
              "module": "metrics_export",
              "signature": "def _export_json(self, metrics: dict[str, float], strategy_name: str, filepath: Path, metadata: ) -> None",
              "docstring": "Export to JSON format.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metrics",
                  "type": "dict[str, float]"
                },
                {
                  "name": "strategy_name",
                  "type": "str"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                },
                {
                  "name": "metadata",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 321
            },
            {
              "name": "_export_csv",
              "module": "metrics_export",
              "signature": "def _export_csv(self, metrics: dict[str, float], strategy_name: str, filepath: Path, metadata: ) -> None",
              "docstring": "Export to CSV format.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metrics",
                  "type": "dict[str, float]"
                },
                {
                  "name": "strategy_name",
                  "type": "str"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                },
                {
                  "name": "metadata",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 356
            },
            {
              "name": "_export_excel_csv",
              "module": "metrics_export",
              "signature": "def _export_excel_csv(self, metrics: dict[str, float], strategy_name: str, filepath: Path, metadata: ) -> None",
              "docstring": "Export to Excel-compatible CSV format.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metrics",
                  "type": "dict[str, float]"
                },
                {
                  "name": "strategy_name",
                  "type": "str"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                },
                {
                  "name": "metadata",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 390
            },
            {
              "name": "_export_html",
              "module": "metrics_export",
              "signature": "def _export_html(self, metrics: dict[str, float], strategy_name: str, filepath: Path, metadata: ) -> None",
              "docstring": "Export to HTML format.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metrics",
                  "type": "dict[str, float]"
                },
                {
                  "name": "strategy_name",
                  "type": "str"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                },
                {
                  "name": "metadata",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 422
            },
            {
              "name": "_export_markdown",
              "module": "metrics_export",
              "signature": "def _export_markdown(self, metrics: dict[str, float], strategy_name: str, filepath: Path, metadata: ) -> None",
              "docstring": "Export to Markdown format.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metrics",
                  "type": "dict[str, float]"
                },
                {
                  "name": "strategy_name",
                  "type": "str"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                },
                {
                  "name": "metadata",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 564
            },
            {
              "name": "export_time_series",
              "module": "metrics_export",
              "signature": "def export_time_series(self, format: ExportFormat, filename: , metrics_to_include: ) -> str",
              "docstring": "Export time-series of performance snapshots.\n\nArgs:\n    format: Export format\n    filename: Optional custom filename\n    metrics_to_include: Specific metrics to include (default: all)\n\nReturns:\n    Path to exported file",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "format",
                  "type": "ExportFormat"
                },
                {
                  "name": "filename",
                  "type": ""
                },
                {
                  "name": "metrics_to_include",
                  "type": ""
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 615
            },
            {
              "name": "_export_timeseries_csv",
              "module": "metrics_export",
              "signature": "def _export_timeseries_csv(self, filepath: Path, metrics: list[str]) -> None",
              "docstring": "Export time series to CSV.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                },
                {
                  "name": "metrics",
                  "type": "list[str]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 658
            },
            {
              "name": "_export_timeseries_json",
              "module": "metrics_export",
              "signature": "def _export_timeseries_json(self, filepath: Path, metrics: list[str]) -> None",
              "docstring": "Export time series to JSON.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                },
                {
                  "name": "metrics",
                  "type": "list[str]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 681
            },
            {
              "name": "export_comparison",
              "module": "metrics_export",
              "signature": "def export_comparison(self, strategies: dict[str, dict[str, float]], format: ExportFormat, filename: ) -> str",
              "docstring": "Export multi-strategy comparison.\n\nArgs:\n    strategies: Dict mapping strategy name to metrics dict\n    format: Export format\n    filename: Optional custom filename\n\nReturns:\n    Path to exported file",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategies",
                  "type": "dict[str, dict[str, float]]"
                },
                {
                  "name": "format",
                  "type": "ExportFormat"
                },
                {
                  "name": "filename",
                  "type": ""
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 696
            },
            {
              "name": "_export_comparison_html",
              "module": "metrics_export",
              "signature": "def _export_comparison_html(self, strategies: dict[str, dict[str, float]], filepath: Path) -> None",
              "docstring": "Export comparison to HTML.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategies",
                  "type": "dict[str, dict[str, float]]"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 731
            },
            {
              "name": "_export_comparison_csv",
              "module": "metrics_export",
              "signature": "def _export_comparison_csv(self, strategies: dict[str, dict[str, float]], filepath: Path) -> None",
              "docstring": "Export comparison to CSV.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategies",
                  "type": "dict[str, dict[str, float]]"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 817
            },
            {
              "name": "_export_comparison_markdown",
              "module": "metrics_export",
              "signature": "def _export_comparison_markdown(self, strategies: dict[str, dict[str, float]], filepath: Path) -> None",
              "docstring": "Export comparison to Markdown.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategies",
                  "type": "dict[str, dict[str, float]]"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 843
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 248
        }
      ],
      "functions": [],
      "constants": [
        {
          "name": "METRIC_DEFINITIONS",
          "line": 81
        }
      ],
      "imports": [
        "__future__",
        "csv",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing",
        "io"
      ],
      "dependencies": [
        "__future__",
        "csv",
        "io"
      ]
    },
    "core.monitoring": {
      "name": "monitoring",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\monitoring.py",
      "docstring": "Monitoring & Observability\n==========================\n\nCentralized monitoring for the trading system.\nCollects metrics, logs, alerts per agent.\n\nPer CLAUDE.md: \"Le syst\u00e8me doit \u00eatre testable, observable et auditable\"",
      "classes": [
        {
          "name": "AlertSeverity",
          "module": "monitoring",
          "docstring": "Alert severity levels.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 30
        },
        {
          "name": "MetricType",
          "module": "monitoring",
          "docstring": "Types of metrics.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 38
        },
        {
          "name": "Metric",
          "module": "monitoring",
          "docstring": "A single metric data point.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "value",
              "type": "float"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "metric_type",
              "type": "MetricType"
            },
            {
              "name": "labels",
              "type": "dict[str, str]"
            },
            {
              "name": "agent",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 47
        },
        {
          "name": "Alert",
          "module": "monitoring",
          "docstring": "An alert from the monitoring system.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "alert_id",
              "type": "str"
            },
            {
              "name": "severity",
              "type": "AlertSeverity"
            },
            {
              "name": "source",
              "type": "str"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "metric_name",
              "type": "Optional[str]"
            },
            {
              "name": "current_value",
              "type": "Optional[float]"
            },
            {
              "name": "threshold_value",
              "type": "Optional[float]"
            },
            {
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "name": "resolved",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 58
        },
        {
          "name": "AgentMetrics",
          "module": "monitoring",
          "docstring": "Metrics for a single agent.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "agent_name",
              "type": "str"
            },
            {
              "name": "events_processed",
              "type": "int"
            },
            {
              "name": "events_per_second",
              "type": "float"
            },
            {
              "name": "avg_processing_time_ms",
              "type": "float"
            },
            {
              "name": "max_processing_time_ms",
              "type": "float"
            },
            {
              "name": "p99_processing_time_ms",
              "type": "float"
            },
            {
              "name": "errors_total",
              "type": "int"
            },
            {
              "name": "errors_last_hour",
              "type": "int"
            },
            {
              "name": "custom_metrics",
              "type": "dict[str, float]"
            },
            {
              "name": "is_healthy",
              "type": "bool"
            },
            {
              "name": "last_event_time",
              "type": "Optional[datetime]"
            },
            {
              "name": "uptime_seconds",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 74
        },
        {
          "name": "SystemMetrics",
          "module": "monitoring",
          "docstring": "System-wide metrics.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "total_decisions",
              "type": "int"
            },
            {
              "name": "decisions_approved",
              "type": "int"
            },
            {
              "name": "decisions_rejected",
              "type": "int"
            },
            {
              "name": "rejection_rate",
              "type": "float"
            },
            {
              "name": "total_orders",
              "type": "int"
            },
            {
              "name": "orders_filled",
              "type": "int"
            },
            {
              "name": "orders_cancelled",
              "type": "int"
            },
            {
              "name": "fill_rate",
              "type": "float"
            },
            {
              "name": "daily_pnl",
              "type": "float"
            },
            {
              "name": "daily_pnl_pct",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "realized_pnl",
              "type": "float"
            },
            {
              "name": "current_drawdown_pct",
              "type": "float"
            },
            {
              "name": "var_95",
              "type": "float"
            },
            {
              "name": "leverage",
              "type": "float"
            },
            {
              "name": "avg_decision_latency_ms",
              "type": "float"
            },
            {
              "name": "avg_execution_latency_ms",
              "type": "float"
            },
            {
              "name": "avg_total_latency_ms",
              "type": "float"
            },
            {
              "name": "active_agents",
              "type": "int"
            },
            {
              "name": "unhealthy_agents",
              "type": "list[str]"
            },
            {
              "name": "kill_switch_active",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 99
        },
        {
          "name": "AnomalyDetection",
          "module": "monitoring",
          "docstring": "Anomaly detection result.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "metric_name",
              "type": "str"
            },
            {
              "name": "is_anomaly",
              "type": "bool"
            },
            {
              "name": "current_value",
              "type": "float"
            },
            {
              "name": "expected_value",
              "type": "float"
            },
            {
              "name": "z_score",
              "type": "float"
            },
            {
              "name": "threshold",
              "type": "float"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 137
        },
        {
          "name": "MetricsCollector",
          "module": "monitoring",
          "docstring": "Collects and aggregates metrics from all agents.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "monitoring",
              "signature": "def __init__(self, retention_hours: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "retention_hours",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 153
            },
            {
              "name": "record_metric",
              "module": "monitoring",
              "signature": "def record_metric(self, name: str, value: float, metric_type: MetricType, labels: Optional[dict[str, str]], agent: str) -> None",
              "docstring": "Record a metric value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                },
                {
                  "name": "metric_type",
                  "type": "MetricType"
                },
                {
                  "name": "labels",
                  "type": "Optional[dict[str, str]]"
                },
                {
                  "name": "agent",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 159
            },
            {
              "name": "record_processing_time",
              "module": "monitoring",
              "signature": "def record_processing_time(self, agent: str, time_ms: float) -> None",
              "docstring": "Record processing time for an agent.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent",
                  "type": "str"
                },
                {
                  "name": "time_ms",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 185
            },
            {
              "name": "increment_counter",
              "module": "monitoring",
              "signature": "def increment_counter(self, name: str, labels: Optional[dict[str, str]], agent: str) -> None",
              "docstring": "Increment a counter metric.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "labels",
                  "type": "Optional[dict[str, str]]"
                },
                {
                  "name": "agent",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 196
            },
            {
              "name": "get_latest_value",
              "module": "monitoring",
              "signature": "def get_latest_value(self, name: str, labels: Optional[dict[str, str]]) -> Optional[float]",
              "docstring": "Get the latest value for a metric.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "labels",
                  "type": "Optional[dict[str, str]]"
                }
              ],
              "return_type": "Optional[float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 207
            },
            {
              "name": "get_metric_history",
              "module": "monitoring",
              "signature": "def get_metric_history(self, name: str, duration_minutes: int, labels: Optional[dict[str, str]]) -> list[Metric]",
              "docstring": "Get metric history for a duration.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "duration_minutes",
                  "type": "int"
                },
                {
                  "name": "labels",
                  "type": "Optional[dict[str, str]]"
                }
              ],
              "return_type": "list[Metric]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 223
            },
            {
              "name": "get_agent_metrics",
              "module": "monitoring",
              "signature": "def get_agent_metrics(self, agent: str) -> AgentMetrics",
              "docstring": "Get aggregated metrics for an agent.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent",
                  "type": "str"
                }
              ],
              "return_type": "AgentMetrics",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 241
            },
            {
              "name": "update_agent_metrics",
              "module": "monitoring",
              "signature": "def update_agent_metrics(self, agent: str) -> None",
              "docstring": "Update agent metrics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 259
            },
            {
              "name": "_cleanup_old_metrics",
              "module": "monitoring",
              "signature": "def _cleanup_old_metrics(self, name: str) -> None",
              "docstring": "Remove metrics older than retention period.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 268
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 148
        },
        {
          "name": "AlertManager",
          "module": "monitoring",
          "docstring": "Manages alerts and notifications.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "monitoring",
              "signature": "def __init__(self, alert_handlers: Optional[list[Callable[, None]]])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_handlers",
                  "type": "Optional[list[Callable[, None]]]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 279
            },
            {
              "name": "add_handler",
              "module": "monitoring",
              "signature": "def add_handler(self, handler: Callable[, None]) -> None",
              "docstring": "Add an alert handler.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "handler",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 296
            },
            {
              "name": "create_alert",
              "module": "monitoring",
              "signature": "def create_alert(self, severity: AlertSeverity, source: str, title: str, message: str, metric_name: Optional[str], current_value: Optional[float], threshold_value: Optional[float]) -> Alert",
              "docstring": "Create and dispatch an alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                },
                {
                  "name": "source",
                  "type": "str"
                },
                {
                  "name": "title",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "metric_name",
                  "type": "Optional[str]"
                },
                {
                  "name": "current_value",
                  "type": "Optional[float]"
                },
                {
                  "name": "threshold_value",
                  "type": "Optional[float]"
                }
              ],
              "return_type": "Alert",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 300
            },
            {
              "name": "check_metric",
              "module": "monitoring",
              "signature": "def check_metric(self, metric_name: str, value: float) -> Optional[Alert]",
              "docstring": "Check a single metric against its threshold and create an alert if needed.\n\nArgs:\n    metric_name: Name of the metric (e.g., \"daily_pnl_pct\", \"drawdown_pct\")\n    value: Current value of the metric\n\nReturns:\n    Alert if threshold exceeded, None otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metric_name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "Optional[Alert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 340
            },
            {
              "name": "check_thresholds",
              "module": "monitoring",
              "signature": "def check_thresholds(self, metrics: SystemMetrics) -> list[Alert]",
              "docstring": "Check metrics against thresholds and create alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metrics",
                  "type": "SystemMetrics"
                }
              ],
              "return_type": "list[Alert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 404
            },
            {
              "name": "acknowledge_alert",
              "module": "monitoring",
              "signature": "def acknowledge_alert(self, alert_id: str) -> bool",
              "docstring": "Acknowledge an alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 478
            },
            {
              "name": "resolve_alert",
              "module": "monitoring",
              "signature": "def resolve_alert(self, alert_id: str) -> bool",
              "docstring": "Resolve an alert.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 487
            },
            {
              "name": "get_active_alerts",
              "module": "monitoring",
              "signature": "def get_active_alerts(self) -> list[Alert]",
              "docstring": "Get all unresolved alerts.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[Alert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 496
            },
            {
              "name": "get_alerts_by_severity",
              "module": "monitoring",
              "signature": "def get_alerts_by_severity(self, severity: AlertSeverity) -> list[Alert]",
              "docstring": "Get alerts by severity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                }
              ],
              "return_type": "list[Alert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 500
            },
            {
              "name": "_dispatch_alert",
              "module": "monitoring",
              "signature": "def _dispatch_alert(self, alert: Alert) -> None",
              "docstring": "Dispatch alert to all handlers.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 504
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 274
        },
        {
          "name": "AnomalyDetector",
          "module": "monitoring",
          "docstring": "Detects anomalies in metrics using statistical methods.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "monitoring",
              "signature": "def __init__(self, z_score_threshold: float, min_samples: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "z_score_threshold",
                  "type": "float"
                },
                {
                  "name": "min_samples",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 518
            },
            {
              "name": "add_sample",
              "module": "monitoring",
              "signature": "def add_sample(self, metric_name: str, value: float) -> Optional[AnomalyDetection]",
              "docstring": "Add a sample and check for anomaly.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metric_name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "Optional[AnomalyDetection]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 524
            },
            {
              "name": "get_baseline",
              "module": "monitoring",
              "signature": "def get_baseline(self, metric_name: str) -> Optional[tuple[float, float]]",
              "docstring": "Get baseline (mean, std) for a metric.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metric_name",
                  "type": "str"
                }
              ],
              "return_type": "Optional[tuple[float, float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 561
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 513
        },
        {
          "name": "MonitoringSystem",
          "module": "monitoring",
          "docstring": "Central monitoring system for the trading platform.\n\nIntegrates:\n- Metrics collection\n- Alert management\n- Anomaly detection\n- Per-agent logging",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "monitoring",
              "signature": "def __init__(self, log_dir: str, metrics_retention_hours: int, alert_handlers: Optional[list[Callable[, None]]])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "log_dir",
                  "type": "str"
                },
                {
                  "name": "metrics_retention_hours",
                  "type": "int"
                },
                {
                  "name": "alert_handlers",
                  "type": "Optional[list[Callable[, None]]]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 584
            },
            {
              "name": "get_agent_logger",
              "module": "monitoring",
              "signature": "def get_agent_logger(self, agent_name: str) -> logging.Logger",
              "docstring": "Get or create a logger for an agent.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                }
              ],
              "return_type": "logging.Logger",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 609
            },
            {
              "name": "register_agent",
              "module": "monitoring",
              "signature": "def register_agent(self, agent_name: str) -> None",
              "docstring": "Register an agent for monitoring.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent_name",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 627
            },
            {
              "name": "record_event",
              "module": "monitoring",
              "signature": "def record_event(self, agent: str, event_type: str, processing_time_ms: float, success: bool, details: Optional[dict]) -> None",
              "docstring": "Record an event processed by an agent.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "agent",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "processing_time_ms",
                  "type": "float"
                },
                {
                  "name": "success",
                  "type": "bool"
                },
                {
                  "name": "details",
                  "type": "Optional[dict]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 637
            },
            {
              "name": "record_decision",
              "module": "monitoring",
              "signature": "def record_decision(self, decision_id: str, symbol: str, action: str, quantity: int, approved: bool, rejection_reason: Optional[str], latency_ms: float) -> None",
              "docstring": "Record a trading decision.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decision_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "action",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "approved",
                  "type": "bool"
                },
                {
                  "name": "rejection_reason",
                  "type": "Optional[str]"
                },
                {
                  "name": "latency_ms",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 680
            },
            {
              "name": "record_order",
              "module": "monitoring",
              "signature": "def record_order(self, order_id: str, symbol: str, side: str, quantity: int, status: str, fill_price: Optional[float], latency_ms: float) -> None",
              "docstring": "Record an order.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "status",
                  "type": "str"
                },
                {
                  "name": "fill_price",
                  "type": "Optional[float]"
                },
                {
                  "name": "latency_ms",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 708
            },
            {
              "name": "record_pnl",
              "module": "monitoring",
              "signature": "def record_pnl(self, daily_pnl: float, daily_pnl_pct: float, unrealized_pnl: float, realized_pnl: float) -> None",
              "docstring": "Record P&L metrics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "daily_pnl",
                  "type": "float"
                },
                {
                  "name": "daily_pnl_pct",
                  "type": "float"
                },
                {
                  "name": "unrealized_pnl",
                  "type": "float"
                },
                {
                  "name": "realized_pnl",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 729
            },
            {
              "name": "record_risk_metrics",
              "module": "monitoring",
              "signature": "def record_risk_metrics(self, drawdown_pct: float, var_95: float, leverage: float) -> None",
              "docstring": "Record risk metrics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "drawdown_pct",
                  "type": "float"
                },
                {
                  "name": "var_95",
                  "type": "float"
                },
                {
                  "name": "leverage",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 755
            },
            {
              "name": "get_system_metrics",
              "module": "monitoring",
              "signature": "def get_system_metrics(self) -> SystemMetrics",
              "docstring": "Get aggregated system metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "SystemMetrics",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 766
            },
            {
              "name": "start",
              "module": "monitoring",
              "signature": "async def start(self, check_interval_seconds: int) -> None",
              "docstring": "Start background monitoring.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "check_interval_seconds",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 828
            },
            {
              "name": "stop",
              "module": "monitoring",
              "signature": "async def stop(self) -> None",
              "docstring": "Stop background monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 836
            },
            {
              "name": "_monitoring_loop",
              "module": "monitoring",
              "signature": "async def _monitoring_loop(self, interval: int) -> None",
              "docstring": "Background monitoring loop.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "interval",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 847
            },
            {
              "name": "export_metrics",
              "module": "monitoring",
              "signature": "def export_metrics(self, filepath: str) -> None",
              "docstring": "Export current metrics to JSON file.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filepath",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 875
            },
            {
              "name": "get_status_summary",
              "module": "monitoring",
              "signature": "def get_status_summary(self) -> dict",
              "docstring": "Get a status summary for display.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 902
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 573
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "json",
        "statistics",
        "dataclasses",
        "datetime",
        "typing",
        "enum",
        "pathlib",
        "numpy",
        "core.event_bus"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "core.event_bus"
      ]
    },
    "core.notifications": {
      "name": "notifications",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\notifications.py",
      "docstring": "Notification System Module\n==========================\n\nNotification system for compliance and risk alerts (Issues #C33, #R27).\n\nFeatures:\n- Multi-channel notifications (email, webhook, file)\n- Alert severity levels\n- Notification throttling\n- Audit trail of all notifications\n- Compliance officer escalation",
      "classes": [
        {
          "name": "AlertSeverity",
          "module": "notifications",
          "docstring": "Alert severity levels.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 36
        },
        {
          "name": "AlertCategory",
          "module": "notifications",
          "docstring": "Alert categories.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 44
        },
        {
          "name": "Alert",
          "module": "notifications",
          "docstring": "Alert notification.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "notifications",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 69
            }
          ],
          "class_attributes": [
            {
              "name": "alert_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "severity",
              "type": "AlertSeverity"
            },
            {
              "name": "category",
              "type": "AlertCategory"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "source",
              "type": "str"
            },
            {
              "name": "details",
              "type": "dict"
            },
            {
              "name": "requires_acknowledgment",
              "type": "bool"
            },
            {
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "name": "acknowledged_by",
              "type": ""
            },
            {
              "name": "acknowledged_at",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 54
        },
        {
          "name": "NotificationChannel",
          "module": "notifications",
          "docstring": "Abstract base class for notification channels.",
          "bases": [
            "ABC"
          ],
          "methods": [
            {
              "name": "send",
              "module": "notifications",
              "signature": "def send(self, alert: Alert) -> bool",
              "docstring": "Send notification. Returns True if successful.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "abstractmethod"
              ],
              "is_async": false,
              "line_number": 91
            },
            {
              "name": "is_available",
              "module": "notifications",
              "signature": "def is_available(self) -> bool",
              "docstring": "Check if channel is available.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "abstractmethod"
              ],
              "is_async": false,
              "line_number": 96
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 87
        },
        {
          "name": "FileNotificationChannel",
          "module": "notifications",
          "docstring": "File-based notification channel.\n\nWrites alerts to a file for log aggregation systems.",
          "bases": [
            "NotificationChannel"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "notifications",
              "signature": "def __init__(self, filepath: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filepath",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 108
            },
            {
              "name": "send",
              "module": "notifications",
              "signature": "def send(self, alert: Alert) -> bool",
              "docstring": "Write alert to file.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 113
            },
            {
              "name": "is_available",
              "module": "notifications",
              "signature": "def is_available(self) -> bool",
              "docstring": "File channel is always available.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 124
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 101
        },
        {
          "name": "WebhookNotificationChannel",
          "module": "notifications",
          "docstring": "Webhook notification channel.\n\nSends alerts to a webhook URL (e.g., Slack, Teams, PagerDuty).",
          "bases": [
            "NotificationChannel"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "notifications",
              "signature": "def __init__(self, webhook_url: str, timeout_seconds: float, headers: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "webhook_url",
                  "type": "str"
                },
                {
                  "name": "timeout_seconds",
                  "type": "float"
                },
                {
                  "name": "headers",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 136
            },
            {
              "name": "send",
              "module": "notifications",
              "signature": "def send(self, alert: Alert) -> bool",
              "docstring": "Send alert to webhook.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 146
            },
            {
              "name": "_format_payload",
              "module": "notifications",
              "signature": "def _format_payload(self, alert: Alert) -> dict",
              "docstring": "Format alert for webhook (Slack-compatible).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 169
            },
            {
              "name": "_get_color",
              "module": "notifications",
              "signature": "def _get_color(self, severity: AlertSeverity) -> str",
              "docstring": "Get color for severity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 192
            },
            {
              "name": "is_available",
              "module": "notifications",
              "signature": "def is_available(self) -> bool",
              "docstring": "Check if webhook is reachable.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 202
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 129
        },
        {
          "name": "EmailNotificationChannel",
          "module": "notifications",
          "docstring": "Email notification channel.\n\nSends alerts via SMTP email.",
          "bases": [
            "NotificationChannel"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "notifications",
              "signature": "def __init__(self, smtp_host: str, smtp_port: int, username: , password: , from_address: str, to_addresses: , use_tls: bool)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "smtp_host",
                  "type": "str"
                },
                {
                  "name": "smtp_port",
                  "type": "int"
                },
                {
                  "name": "username",
                  "type": ""
                },
                {
                  "name": "password",
                  "type": ""
                },
                {
                  "name": "from_address",
                  "type": "str"
                },
                {
                  "name": "to_addresses",
                  "type": ""
                },
                {
                  "name": "use_tls",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 214
            },
            {
              "name": "send",
              "module": "notifications",
              "signature": "def send(self, alert: Alert) -> bool",
              "docstring": "Send alert via email.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 232
            },
            {
              "name": "_format_html",
              "module": "notifications",
              "signature": "def _format_html(self, alert: Alert) -> str",
              "docstring": "Format alert as HTML email.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 277
            },
            {
              "name": "is_available",
              "module": "notifications",
              "signature": "def is_available(self) -> bool",
              "docstring": "Check if SMTP is configured.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 302
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 207
        },
        {
          "name": "NotificationManager",
          "module": "notifications",
          "docstring": "Central notification management (#C33, #R27).\n\nHandles alert routing, throttling, and escalation.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "notifications",
              "signature": "def __init__(self, channels: , throttle_minutes: float, escalation_delay_minutes: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "channels",
                  "type": ""
                },
                {
                  "name": "throttle_minutes",
                  "type": "float"
                },
                {
                  "name": "escalation_delay_minutes",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 314
            },
            {
              "name": "add_channel",
              "module": "notifications",
              "signature": "def add_channel(self, channel: NotificationChannel) -> None",
              "docstring": "Add a notification channel.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "channel",
                  "type": "NotificationChannel"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 336
            },
            {
              "name": "register_escalation_callback",
              "module": "notifications",
              "signature": "def register_escalation_callback(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for escalation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 340
            },
            {
              "name": "send_alert",
              "module": "notifications",
              "signature": "def send_alert(self, severity: AlertSeverity, category: AlertCategory, title: str, message: str, source: str, details: , throttle_key: , requires_acknowledgment: bool)",
              "docstring": "Send an alert through configured channels.\n\nArgs:\n    severity: Alert severity\n    category: Alert category\n    title: Alert title\n    message: Alert message\n    source: Source agent/component\n    details: Additional details\n    throttle_key: Key for throttling similar alerts\n    requires_acknowledgment: Whether alert needs to be acknowledged\n\nReturns:\n    Alert object if sent, None if throttled",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                },
                {
                  "name": "category",
                  "type": "AlertCategory"
                },
                {
                  "name": "title",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "source",
                  "type": "str"
                },
                {
                  "name": "details",
                  "type": ""
                },
                {
                  "name": "throttle_key",
                  "type": ""
                },
                {
                  "name": "requires_acknowledgment",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 347
            },
            {
              "name": "acknowledge_alert",
              "module": "notifications",
              "signature": "def acknowledge_alert(self, alert_id: str, acknowledged_by: str) -> bool",
              "docstring": "Acknowledge an alert.\n\nArgs:\n    alert_id: Alert to acknowledge\n    acknowledged_by: Person/system acknowledging\n\nReturns:\n    True if acknowledged successfully",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_id",
                  "type": "str"
                },
                {
                  "name": "acknowledged_by",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 422
            },
            {
              "name": "get_pending_acknowledgments",
              "module": "notifications",
              "signature": "def get_pending_acknowledgments(self) -> list[Alert]",
              "docstring": "Get alerts pending acknowledgment.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[Alert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 452
            },
            {
              "name": "check_escalations",
              "module": "notifications",
              "signature": "def check_escalations(self) -> list[Alert]",
              "docstring": "Check for alerts requiring escalation.\n\nEscalates alerts that have been pending too long.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[Alert]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 457
            },
            {
              "name": "_should_send",
              "module": "notifications",
              "signature": "def _should_send(self, throttle_key: str, severity: AlertSeverity) -> bool",
              "docstring": "Check if alert should be sent based on throttling.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "throttle_key",
                  "type": "str"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 481
            },
            {
              "name": "_should_send_to_channel",
              "module": "notifications",
              "signature": "def _should_send_to_channel(self, channel: NotificationChannel, alert: Alert) -> bool",
              "docstring": "Check if alert should be sent to specific channel.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "channel",
                  "type": "NotificationChannel"
                },
                {
                  "name": "alert",
                  "type": "Alert"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 494
            },
            {
              "name": "_get_log_level",
              "module": "notifications",
              "signature": "def _get_log_level(self, severity: AlertSeverity) -> int",
              "docstring": "Get logging level for severity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": "AlertSeverity"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 521
            },
            {
              "name": "get_statistics",
              "module": "notifications",
              "signature": "def get_statistics(self) -> dict",
              "docstring": "Get notification statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 531
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 307
        },
        {
          "name": "ComplianceOfficerNotifier",
          "module": "notifications",
          "docstring": "Specialized notifier for compliance officer alerts (#C33).\n\nHandles compliance-specific notification requirements.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "notifications",
              "signature": "def __init__(self, notification_manager: NotificationManager, compliance_officer_email: , compliance_webhook: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "notification_manager",
                  "type": "NotificationManager"
                },
                {
                  "name": "compliance_officer_email",
                  "type": ""
                },
                {
                  "name": "compliance_webhook",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 563
            },
            {
              "name": "notify_violation",
              "module": "notifications",
              "signature": "def notify_violation(self, violation_type: str, description: str, symbol: , trade_id: , details: )",
              "docstring": "Notify compliance officer of a violation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "violation_type",
                  "type": "str"
                },
                {
                  "name": "description",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": ""
                },
                {
                  "name": "trade_id",
                  "type": ""
                },
                {
                  "name": "details",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 573
            },
            {
              "name": "notify_suspicious_activity",
              "module": "notifications",
              "signature": "def notify_suspicious_activity(self, activity_type: str, description: str, details: )",
              "docstring": "Notify of suspicious trading activity (MAR requirement).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "activity_type",
                  "type": "str"
                },
                {
                  "name": "description",
                  "type": "str"
                },
                {
                  "name": "details",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 600
            },
            {
              "name": "notify_regulatory_deadline",
              "module": "notifications",
              "signature": "def notify_regulatory_deadline(self, deadline_type: str, deadline_date: datetime, days_remaining: int)",
              "docstring": "Notify of upcoming regulatory deadline.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "deadline_type",
                  "type": "str"
                },
                {
                  "name": "deadline_date",
                  "type": "datetime"
                },
                {
                  "name": "days_remaining",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 618
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 556
        },
        {
          "name": "RiskLimitBreachNotifier",
          "module": "notifications",
          "docstring": "Specialized notifier for risk limit breaches (#R27).\n\nHandles risk-specific notification requirements.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "notifications",
              "signature": "def __init__(self, notification_manager: NotificationManager)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "notification_manager",
                  "type": "NotificationManager"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 651
            },
            {
              "name": "notify_limit_breach",
              "module": "notifications",
              "signature": "def notify_limit_breach(self, limit_name: str, current_value: float, limit_value: float, symbol: )",
              "docstring": "Notify of a risk limit breach.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit_name",
                  "type": "str"
                },
                {
                  "name": "current_value",
                  "type": "float"
                },
                {
                  "name": "limit_value",
                  "type": "float"
                },
                {
                  "name": "symbol",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 654
            },
            {
              "name": "notify_limit_warning",
              "module": "notifications",
              "signature": "def notify_limit_warning(self, limit_name: str, current_value: float, limit_value: float, warning_threshold: float)",
              "docstring": "Notify of approaching limit (warning level).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit_name",
                  "type": "str"
                },
                {
                  "name": "current_value",
                  "type": "float"
                },
                {
                  "name": "limit_value",
                  "type": "float"
                },
                {
                  "name": "warning_threshold",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 681
            },
            {
              "name": "notify_var_breach",
              "module": "notifications",
              "signature": "def notify_var_breach(self, var_type: str, var_value: float, var_limit: float)",
              "docstring": "Notify of VaR limit breach.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "var_type",
                  "type": "str"
                },
                {
                  "name": "var_value",
                  "type": "float"
                },
                {
                  "name": "var_limit",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 706
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 644
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "smtplib",
        "urllib.request",
        "urllib.error",
        "abc",
        "dataclasses",
        "datetime",
        "email.mime.text",
        "email.mime.multipart",
        "enum",
        "pathlib",
        "typing",
        "collections",
        "threading"
      ],
      "dependencies": [
        "__future__",
        "smtplib",
        "urllib.request",
        "urllib.error",
        "abc",
        "email.mime.text",
        "email.mime.multipart",
        "threading"
      ]
    },
    "core.options_advanced": {
      "name": "options_advanced",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\options_advanced.py",
      "docstring": "Advanced Options Analytics Module\n\nAddresses MEDIUM priority issues:\n- #O13: Option market making support\n- #O14: Option pricing model comparison\n- #O15: Jump diffusion model (Merton)\n- #O16: Stochastic volatility (Heston model)\n\nProvides institutional-grade options pricing and market making capabilities.",
      "classes": [
        {
          "name": "OptionType",
          "module": "options_advanced",
          "docstring": "Option type enumeration.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 33
        },
        {
          "name": "PricingModel",
          "module": "options_advanced",
          "docstring": "Available pricing models.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 39
        },
        {
          "name": "QuoteSide",
          "module": "options_advanced",
          "docstring": "Quote side for market making.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 48
        },
        {
          "name": "OptionContract",
          "module": "options_advanced",
          "docstring": "Represents an option contract.",
          "bases": [],
          "methods": [
            {
              "name": "time_to_expiry",
              "module": "options_advanced",
              "signature": "def time_to_expiry(self) -> float",
              "docstring": "Calculate time to expiry in years.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 66
            }
          ],
          "class_attributes": [
            {
              "name": "underlying",
              "type": "str"
            },
            {
              "name": "strike",
              "type": "float"
            },
            {
              "name": "expiry",
              "type": "datetime"
            },
            {
              "name": "option_type",
              "type": "OptionType"
            },
            {
              "name": "multiplier",
              "type": "float"
            },
            {
              "name": "exercise_style",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 56
        },
        {
          "name": "MarketData",
          "module": "options_advanced",
          "docstring": "Market data for option pricing.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "spot",
              "type": "float"
            },
            {
              "name": "rate",
              "type": "float"
            },
            {
              "name": "dividend_yield",
              "type": "float"
            },
            {
              "name": "volatility",
              "type": "float"
            },
            {
              "name": "vol_surface",
              "type": "Optional[Dict[Tuple[float, float], float]]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 73
        },
        {
          "name": "PricingResult",
          "module": "options_advanced",
          "docstring": "Result of option pricing.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "model",
              "type": "PricingModel"
            },
            {
              "name": "price",
              "type": "float"
            },
            {
              "name": "delta",
              "type": "float"
            },
            {
              "name": "gamma",
              "type": "float"
            },
            {
              "name": "vega",
              "type": "float"
            },
            {
              "name": "theta",
              "type": "float"
            },
            {
              "name": "rho",
              "type": "float"
            },
            {
              "name": "implied_vol",
              "type": "Optional[float]"
            },
            {
              "name": "vanna",
              "type": "float"
            },
            {
              "name": "volga",
              "type": "float"
            },
            {
              "name": "computation_time_ms",
              "type": "float"
            },
            {
              "name": "parameters",
              "type": "Dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 83
        },
        {
          "name": "ModelComparisonResult",
          "module": "options_advanced",
          "docstring": "Comparison of multiple pricing models.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "contract",
              "type": "OptionContract"
            },
            {
              "name": "market_data",
              "type": "MarketData"
            },
            {
              "name": "results",
              "type": "Dict[PricingModel, PricingResult]"
            },
            {
              "name": "market_price",
              "type": "Optional[float]"
            },
            {
              "name": "best_fit_model",
              "type": "Optional[PricingModel]"
            },
            {
              "name": "comparison_metrics",
              "type": "Dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 100
        },
        {
          "name": "Quote",
          "module": "options_advanced",
          "docstring": "Market making quote.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "contract",
              "type": "OptionContract"
            },
            {
              "name": "bid_price",
              "type": "float"
            },
            {
              "name": "ask_price",
              "type": "float"
            },
            {
              "name": "bid_size",
              "type": "int"
            },
            {
              "name": "ask_size",
              "type": "int"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "theo_price",
              "type": "float"
            },
            {
              "name": "edge",
              "type": "float"
            },
            {
              "name": "inventory_adjustment",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 111
        },
        {
          "name": "InventoryPosition",
          "module": "options_advanced",
          "docstring": "Current inventory position for market making.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "contract",
              "type": "OptionContract"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "avg_price",
              "type": "float"
            },
            {
              "name": "delta_exposure",
              "type": "float"
            },
            {
              "name": "gamma_exposure",
              "type": "float"
            },
            {
              "name": "vega_exposure",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 125
        },
        {
          "name": "BasePricingModel",
          "module": "options_advanced",
          "docstring": "Abstract base class for pricing models.",
          "bases": [
            "ABC"
          ],
          "methods": [
            {
              "name": "price",
              "module": "options_advanced",
              "signature": "def price(self, contract: OptionContract, market_data: MarketData) -> PricingResult",
              "docstring": "Price an option contract.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                }
              ],
              "return_type": "PricingResult",
              "raises": [],
              "examples": [],
              "decorators": [
                "abstractmethod"
              ],
              "is_async": false,
              "line_number": 143
            },
            {
              "name": "model_type",
              "module": "options_advanced",
              "signature": "def model_type(self) -> PricingModel",
              "docstring": "Return the model type.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "PricingModel",
              "raises": [],
              "examples": [],
              "decorators": [
                "abstractmethod"
              ],
              "is_async": false,
              "line_number": 153
            },
            {
              "name": "implied_volatility",
              "module": "options_advanced",
              "signature": "def implied_volatility(self, contract: OptionContract, market_data: MarketData, market_price: float, max_iterations: int, tolerance: float) -> float",
              "docstring": "Calculate implied volatility from market price.\n\nUses Brent's method with fallback to Newton-Raphson for robustness.\nHandles edge cases near expiration and extreme market prices.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                },
                {
                  "name": "market_price",
                  "type": "float"
                },
                {
                  "name": "max_iterations",
                  "type": "int"
                },
                {
                  "name": "tolerance",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 157
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 139
        },
        {
          "name": "BlackScholesModel",
          "module": "options_advanced",
          "docstring": "Standard Black-Scholes-Merton pricing model.",
          "bases": [
            "BasePricingModel"
          ],
          "methods": [
            {
              "name": "model_type",
              "module": "options_advanced",
              "signature": "def model_type(self) -> PricingModel",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "PricingModel",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 266
            },
            {
              "name": "price",
              "module": "options_advanced",
              "signature": "def price(self, contract: OptionContract, market_data: MarketData) -> PricingResult",
              "docstring": "Price option using Black-Scholes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                }
              ],
              "return_type": "PricingResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 269
            },
            {
              "name": "_calculate_theta",
              "module": "options_advanced",
              "signature": "def _calculate_theta(self, S: float, K: float, T: float, r: float, q: float, sigma: float, d1: float, d2: float, option_type: OptionType) -> float",
              "docstring": "Calculate theta (time decay).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                },
                {
                  "name": "sigma",
                  "type": "float"
                },
                {
                  "name": "d1",
                  "type": "float"
                },
                {
                  "name": "d2",
                  "type": "float"
                },
                {
                  "name": "option_type",
                  "type": "OptionType"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 387
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 263
        },
        {
          "name": "JumpParameters",
          "module": "options_advanced",
          "docstring": "Parameters for jump diffusion model.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "jump_intensity",
              "type": "float"
            },
            {
              "name": "jump_mean",
              "type": "float"
            },
            {
              "name": "jump_volatility",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 414
        },
        {
          "name": "MertonJumpDiffusionModel",
          "module": "options_advanced",
          "docstring": "Merton (1976) Jump Diffusion Model.\n\nExtends Black-Scholes with compound Poisson jumps to capture\ndiscontinuous price movements (crash risk, earnings jumps, etc.).\n\ndS/S = (mu - lambda*k) dt + sigma dW + (J-1) dN\n\nwhere:\n- N is a Poisson process with intensity lambda\n- J is the jump size (log-normal distributed)\n- k = E[J-1] is the expected percentage jump size",
          "bases": [
            "BasePricingModel"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "options_advanced",
              "signature": "def __init__(self, max_terms: int)",
              "docstring": "Initialize with maximum series expansion terms.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "max_terms",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 436
            },
            {
              "name": "model_type",
              "module": "options_advanced",
              "signature": "def model_type(self) -> PricingModel",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "PricingModel",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 441
            },
            {
              "name": "price",
              "module": "options_advanced",
              "signature": "def price(self, contract: OptionContract, market_data: MarketData, jump_params: Optional[JumpParameters]) -> PricingResult",
              "docstring": "Price option using Merton jump diffusion.\n\nUses series expansion of BS prices weighted by Poisson probabilities.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                },
                {
                  "name": "jump_params",
                  "type": "Optional[JumpParameters]"
                }
              ],
              "return_type": "PricingResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 444
            },
            {
              "name": "calibrate",
              "module": "options_advanced",
              "signature": "def calibrate(self, contracts: List[OptionContract], market_data: MarketData, market_prices: List[float]) -> JumpParameters",
              "docstring": "Calibrate jump parameters to market prices.\n\nMinimizes sum of squared pricing errors.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contracts",
                  "type": "List[OptionContract]"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                },
                {
                  "name": "market_prices",
                  "type": "List[float]"
                }
              ],
              "return_type": "JumpParameters",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 564
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 421
        },
        {
          "name": "HestonParameters",
          "module": "options_advanced",
          "docstring": "Parameters for Heston stochastic volatility model.",
          "bases": [],
          "methods": [
            {
              "name": "feller_condition",
              "module": "options_advanced",
              "signature": "def feller_condition(self) -> bool",
              "docstring": "Check if Feller condition is satisfied (ensures positive variance).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 620
            }
          ],
          "class_attributes": [
            {
              "name": "v0",
              "type": "float"
            },
            {
              "name": "kappa",
              "type": "float"
            },
            {
              "name": "theta",
              "type": "float"
            },
            {
              "name": "sigma",
              "type": "float"
            },
            {
              "name": "rho",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 612
        },
        {
          "name": "HestonModel",
          "module": "options_advanced",
          "docstring": "Heston (1993) Stochastic Volatility Model.\n\ndS = mu*S*dt + sqrt(v)*S*dW1\ndv = kappa*(theta - v)*dt + sigma*sqrt(v)*dW2\ndW1*dW2 = rho*dt\n\nCaptures:\n- Volatility smile/skew\n- Mean reversion of volatility\n- Correlation between returns and volatility (leverage effect)",
          "bases": [
            "BasePricingModel"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "options_advanced",
              "signature": "def __init__(self, integration_points: int)",
              "docstring": "Initialize with number of integration points for characteristic function.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "integration_points",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 639
            },
            {
              "name": "model_type",
              "module": "options_advanced",
              "signature": "def model_type(self) -> PricingModel",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "PricingModel",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 643
            },
            {
              "name": "price",
              "module": "options_advanced",
              "signature": "def price(self, contract: OptionContract, market_data: MarketData, heston_params: Optional[HestonParameters]) -> PricingResult",
              "docstring": "Price option using Heston model via characteristic function.\n\nUses Carr-Madan FFT approach or direct integration.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                },
                {
                  "name": "heston_params",
                  "type": "Optional[HestonParameters]"
                }
              ],
              "return_type": "PricingResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 646
            },
            {
              "name": "_characteristic_function",
              "module": "options_advanced",
              "signature": "def _characteristic_function(self, phi: complex, S: float, T: float, r: float, q: float, params: HestonParameters, j: int) -> complex",
              "docstring": "Heston characteristic function for P1 and P2.\n\nUses the formulation from Gatheral \"The Volatility Surface\".",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "phi",
                  "type": "complex"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                },
                {
                  "name": "params",
                  "type": "HestonParameters"
                },
                {
                  "name": "j",
                  "type": "int"
                }
              ],
              "return_type": "complex",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 727
            },
            {
              "name": "_price_call",
              "module": "options_advanced",
              "signature": "def _price_call(self, S: float, K: float, T: float, r: float, q: float, params: HestonParameters) -> float",
              "docstring": "Price a call option using numerical integration.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                },
                {
                  "name": "params",
                  "type": "HestonParameters"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 802
            },
            {
              "name": "_numerical_delta",
              "module": "options_advanced",
              "signature": "def _numerical_delta(self, S: float, K: float, T: float, r: float, q: float, params: HestonParameters, option_type: OptionType) -> float",
              "docstring": "Calculate delta numerically.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                },
                {
                  "name": "params",
                  "type": "HestonParameters"
                },
                {
                  "name": "option_type",
                  "type": "OptionType"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 854
            },
            {
              "name": "_numerical_gamma",
              "module": "options_advanced",
              "signature": "def _numerical_gamma(self, S: float, K: float, T: float, r: float, q: float, params: HestonParameters, option_type: OptionType) -> float",
              "docstring": "Calculate gamma numerically.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                },
                {
                  "name": "params",
                  "type": "HestonParameters"
                },
                {
                  "name": "option_type",
                  "type": "OptionType"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 870
            },
            {
              "name": "_numerical_vega",
              "module": "options_advanced",
              "signature": "def _numerical_vega(self, S: float, K: float, T: float, r: float, q: float, params: HestonParameters, option_type: OptionType) -> float",
              "docstring": "Calculate vega numerically (w.r.t. v0).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                },
                {
                  "name": "params",
                  "type": "HestonParameters"
                },
                {
                  "name": "option_type",
                  "type": "OptionType"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 883
            },
            {
              "name": "calibrate",
              "module": "options_advanced",
              "signature": "def calibrate(self, contracts: List[OptionContract], market_data: MarketData, market_prices: List[float], initial_params: Optional[HestonParameters]) -> HestonParameters",
              "docstring": "Calibrate Heston parameters to market prices.\n\nUses differential evolution for global optimization.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contracts",
                  "type": "List[OptionContract]"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                },
                {
                  "name": "market_prices",
                  "type": "List[float]"
                },
                {
                  "name": "initial_params",
                  "type": "Optional[HestonParameters]"
                }
              ],
              "return_type": "HestonParameters",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 909
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 625
        },
        {
          "name": "PricingModelComparator",
          "module": "options_advanced",
          "docstring": "Compare multiple pricing models for option valuation.\n\nProvides:\n- Side-by-side model comparison\n- Model selection based on market fit\n- Parameter sensitivity analysis",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "options_advanced",
              "signature": "def __init__(self)",
              "docstring": "Initialize with available models.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 990
            },
            {
              "name": "compare_models",
              "module": "options_advanced",
              "signature": "def compare_models(self, contract: OptionContract, market_data: MarketData, market_price: Optional[float], model_params: Optional[Dict[PricingModel, Any]]) -> ModelComparisonResult",
              "docstring": "Compare all available models for a single contract.\n\nArgs:\n    contract: Option contract to price\n    market_data: Market data for pricing\n    market_price: Optional market price for comparison\n    model_params: Optional model-specific parameters\n\nReturns:\n    ModelComparisonResult with prices from all models",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                },
                {
                  "name": "market_price",
                  "type": "Optional[float]"
                },
                {
                  "name": "model_params",
                  "type": "Optional[Dict[PricingModel, Any]]"
                }
              ],
              "return_type": "ModelComparisonResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 999
            },
            {
              "name": "sensitivity_analysis",
              "module": "options_advanced",
              "signature": "def sensitivity_analysis(self, contract: OptionContract, market_data: MarketData, param_name: str, param_range: np.ndarray, model: PricingModel) -> Dict[str, List[float]]",
              "docstring": "Analyze sensitivity of model output to parameter changes.\n\nArgs:\n    contract: Option contract\n    market_data: Base market data\n    param_name: Parameter to vary (spot, vol, rate, etc.)\n    param_range: Range of parameter values\n    model: Model to use\n\nReturns:\n    Dictionary of parameter values and corresponding prices/Greeks",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                },
                {
                  "name": "param_name",
                  "type": "str"
                },
                {
                  "name": "param_range",
                  "type": "np.ndarray"
                },
                {
                  "name": "model",
                  "type": "PricingModel"
                }
              ],
              "return_type": "Dict[str, List[float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1064
            },
            {
              "name": "generate_vol_surface",
              "module": "options_advanced",
              "signature": "def generate_vol_surface(self, underlying: str, spot: float, rate: float, strikes: List[float], expiries: List[float], market_prices: Dict[Tuple[float, float], float], model: PricingModel) -> Dict[Tuple[float, float], float]",
              "docstring": "Generate implied volatility surface from market prices.\n\nArgs:\n    underlying: Underlying asset\n    spot: Current spot price\n    rate: Risk-free rate\n    strikes: List of strikes\n    expiries: List of expiries (in years)\n    market_prices: Dict of (strike, expiry) -> price\n    model: Model to use for IV calculation\n\nReturns:\n    Dictionary of (strike, expiry) -> implied vol",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "underlying",
                  "type": "str"
                },
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                },
                {
                  "name": "strikes",
                  "type": "List[float]"
                },
                {
                  "name": "expiries",
                  "type": "List[float]"
                },
                {
                  "name": "market_prices",
                  "type": "Dict[Tuple[float, float], float]"
                },
                {
                  "name": "model",
                  "type": "PricingModel"
                }
              ],
              "return_type": "Dict[Tuple[float, float], float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1115
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 980
        },
        {
          "name": "MarketMakingParameters",
          "module": "options_advanced",
          "docstring": "Parameters for market making strategy.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "base_spread_bps",
              "type": "float"
            },
            {
              "name": "inventory_skew_factor",
              "type": "float"
            },
            {
              "name": "max_position",
              "type": "int"
            },
            {
              "name": "min_edge_bps",
              "type": "float"
            },
            {
              "name": "gamma_limit",
              "type": "float"
            },
            {
              "name": "vega_limit",
              "type": "float"
            },
            {
              "name": "quote_size",
              "type": "int"
            },
            {
              "name": "refresh_interval_ms",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1178
        },
        {
          "name": "OptionMarketMaker",
          "module": "options_advanced",
          "docstring": "Option market making engine.\n\nProvides:\n- Two-way quote generation\n- Inventory management\n- Risk-based position limits\n- Dynamic spread adjustment",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "options_advanced",
              "signature": "def __init__(self, pricing_model: BasePricingModel, params: Optional[MarketMakingParameters])",
              "docstring": "Initialize market maker with pricing model and parameters.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pricing_model",
                  "type": "BasePricingModel"
                },
                {
                  "name": "params",
                  "type": "Optional[MarketMakingParameters]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1201
            },
            {
              "name": "generate_quote",
              "module": "options_advanced",
              "signature": "def generate_quote(self, contract: OptionContract, market_data: MarketData, side: QuoteSide) -> Quote",
              "docstring": "Generate market making quote.\n\nArgs:\n    contract: Option contract to quote\n    market_data: Current market data\n    side: Which side to quote\n\nReturns:\n    Quote with bid/ask prices and sizes",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                },
                {
                  "name": "side",
                  "type": "QuoteSide"
                }
              ],
              "return_type": "Quote",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1212
            },
            {
              "name": "_calculate_inventory_adjustment",
              "module": "options_advanced",
              "signature": "def _calculate_inventory_adjustment(self, contract: OptionContract, pricing_result: PricingResult) -> float",
              "docstring": "Calculate price adjustment based on current inventory.\n\nPositive inventory -> lower bid, higher ask (want to sell)\nNegative inventory -> higher bid, lower ask (want to buy)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "pricing_result",
                  "type": "PricingResult"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1274
            },
            {
              "name": "_calculate_vol_spread_adjustment",
              "module": "options_advanced",
              "signature": "def _calculate_vol_spread_adjustment(self, volatility: float) -> float",
              "docstring": "Widen spread in high volatility environments.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "volatility",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1298
            },
            {
              "name": "_calculate_quote_sizes",
              "module": "options_advanced",
              "signature": "def _calculate_quote_sizes(self, contract: OptionContract, pricing_result: PricingResult) -> Tuple[int, int]",
              "docstring": "Calculate bid and ask sizes based on risk limits.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "pricing_result",
                  "type": "PricingResult"
                }
              ],
              "return_type": "Tuple[int, int]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1307
            },
            {
              "name": "update_inventory",
              "module": "options_advanced",
              "signature": "def update_inventory(self, contract: OptionContract, quantity: int, price: float, pricing_result: PricingResult) -> None",
              "docstring": "Update inventory after a trade.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "contract",
                  "type": "OptionContract"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "pricing_result",
                  "type": "PricingResult"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1354
            },
            {
              "name": "get_portfolio_greeks",
              "module": "options_advanced",
              "signature": "def get_portfolio_greeks(self) -> Dict[str, float]",
              "docstring": "Get aggregate portfolio Greeks.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1398
            },
            {
              "name": "calculate_hedge_trades",
              "module": "options_advanced",
              "signature": "def calculate_hedge_trades(self, market_data: MarketData) -> List[Dict[str, Any]]",
              "docstring": "Calculate hedge trades to neutralize Greeks.\n\nReturns list of suggested hedging trades.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "market_data",
                  "type": "MarketData"
                }
              ],
              "return_type": "List[Dict[str, Any]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1407
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1190
        }
      ],
      "functions": [
        {
          "name": "create_pricing_suite",
          "module": "options_advanced",
          "signature": "def create_pricing_suite() -> Dict[str, Any]",
          "docstring": "Create a complete pricing suite with all models.\n\nReturns:\n    Dictionary containing all pricing components",
          "parameters": [],
          "return_type": "Dict[str, Any]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 1451
        }
      ],
      "constants": [],
      "imports": [
        "logging",
        "math",
        "abc",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy",
        "scipy",
        "scipy.special",
        "scipy.stats"
      ],
      "dependencies": [
        "abc",
        "numpy",
        "scipy",
        "scipy.special",
        "scipy.stats"
      ]
    },
    "core.options_backtest": {
      "name": "options_backtest",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\options_backtest.py",
      "docstring": "Options Strategy Backtesting Module\n===================================\n\nAddresses issue #O18: No option strategy backtesting.\n\nFeatures:\n- Options strategy backtesting framework\n- Multi-leg strategy support\n- Greeks evolution tracking\n- Volatility surface modeling\n- Strategy P&L decomposition",
      "classes": [
        {
          "name": "OptionType",
          "module": "options_backtest",
          "docstring": "Option type.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 29
        },
        {
          "name": "OptionStrategy",
          "module": "options_backtest",
          "docstring": "Common option strategies.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 35
        },
        {
          "name": "OptionLeg",
          "module": "options_backtest",
          "docstring": "Single leg of an options position.",
          "bases": [],
          "methods": [
            {
              "name": "is_long",
              "module": "options_backtest",
              "signature": "def is_long(self) -> bool",
              "docstring": "Check if leg is long.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 64
            },
            {
              "name": "notional",
              "module": "options_backtest",
              "signature": "def notional(self) -> float",
              "docstring": "Calculate notional value.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 69
            },
            {
              "name": "days_to_expiry",
              "module": "options_backtest",
              "signature": "def days_to_expiry(self, as_of: datetime) -> int",
              "docstring": "Calculate days to expiry.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "as_of",
                  "type": "datetime"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 73
            }
          ],
          "class_attributes": [
            {
              "name": "option_type",
              "type": "OptionType"
            },
            {
              "name": "strike",
              "type": "float"
            },
            {
              "name": "expiry",
              "type": "datetime"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "premium",
              "type": "float"
            },
            {
              "name": "multiplier",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 54
        },
        {
          "name": "OptionPosition",
          "module": "options_backtest",
          "docstring": "Multi-leg options position.",
          "bases": [],
          "methods": [
            {
              "name": "max_profit",
              "module": "options_backtest",
              "signature": "def max_profit(self)",
              "docstring": "Calculate maximum profit (if defined).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 92
            },
            {
              "name": "max_loss",
              "module": "options_backtest",
              "signature": "def max_loss(self)",
              "docstring": "Calculate maximum loss (if defined).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 98
            },
            {
              "name": "net_premium",
              "module": "options_backtest",
              "signature": "def net_premium(self) -> float",
              "docstring": "Net premium paid/received.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 108
            },
            {
              "name": "is_expired",
              "module": "options_backtest",
              "signature": "def is_expired(self, as_of: datetime) -> bool",
              "docstring": "Check if all legs expired.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "as_of",
                  "type": "datetime"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 115
            }
          ],
          "class_attributes": [
            {
              "name": "position_id",
              "type": "str"
            },
            {
              "name": "underlying",
              "type": "str"
            },
            {
              "name": "strategy_type",
              "type": "OptionStrategy"
            },
            {
              "name": "legs",
              "type": "list[OptionLeg]"
            },
            {
              "name": "entry_date",
              "type": "datetime"
            },
            {
              "name": "entry_underlying_price",
              "type": "float"
            },
            {
              "name": "exit_date",
              "type": ""
            },
            {
              "name": "exit_underlying_price",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 80
        },
        {
          "name": "OptionGreeks",
          "module": "options_backtest",
          "docstring": "Greeks for a position.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "delta",
              "type": "float"
            },
            {
              "name": "gamma",
              "type": "float"
            },
            {
              "name": "theta",
              "type": "float"
            },
            {
              "name": "vega",
              "type": "float"
            },
            {
              "name": "rho",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 121
        },
        {
          "name": "OptionBacktestBar",
          "module": "options_backtest",
          "docstring": "Single bar of options backtest data.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "underlying_price",
              "type": "float"
            },
            {
              "name": "option_prices",
              "type": "dict[tuple[float, datetime, OptionType], float]"
            },
            {
              "name": "implied_vols",
              "type": "dict[tuple[float, datetime, OptionType], float]"
            },
            {
              "name": "risk_free_rate",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 131
        },
        {
          "name": "OptionBacktestResult",
          "module": "options_backtest",
          "docstring": "Result of options strategy backtest.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "options_backtest",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 177
            }
          ],
          "class_attributes": [
            {
              "name": "strategy_type",
              "type": "OptionStrategy"
            },
            {
              "name": "start_date",
              "type": "datetime"
            },
            {
              "name": "end_date",
              "type": "datetime"
            },
            {
              "name": "initial_capital",
              "type": "float"
            },
            {
              "name": "final_value",
              "type": "float"
            },
            {
              "name": "total_return",
              "type": "float"
            },
            {
              "name": "total_trades",
              "type": "int"
            },
            {
              "name": "winning_trades",
              "type": "int"
            },
            {
              "name": "losing_trades",
              "type": "int"
            },
            {
              "name": "win_rate",
              "type": "float"
            },
            {
              "name": "avg_profit",
              "type": "float"
            },
            {
              "name": "avg_loss",
              "type": "float"
            },
            {
              "name": "max_drawdown",
              "type": "float"
            },
            {
              "name": "sharpe_ratio",
              "type": "float"
            },
            {
              "name": "avg_days_held",
              "type": "float"
            },
            {
              "name": "assignments",
              "type": "int"
            },
            {
              "name": "exercises",
              "type": "int"
            },
            {
              "name": "expirations_worthless",
              "type": "int"
            },
            {
              "name": "avg_entry_iv",
              "type": "float"
            },
            {
              "name": "avg_exit_iv",
              "type": "float"
            },
            {
              "name": "theta_collected",
              "type": "float"
            },
            {
              "name": "gamma_pnl",
              "type": "float"
            },
            {
              "name": "vega_pnl",
              "type": "float"
            },
            {
              "name": "delta_pnl",
              "type": "float"
            },
            {
              "name": "total_theta_decay",
              "type": "float"
            },
            {
              "name": "total_iv_pnl",
              "type": "float"
            },
            {
              "name": "equity_curve",
              "type": "list[tuple[datetime, float]]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 141
        },
        {
          "name": "BlackScholes",
          "module": "options_backtest",
          "docstring": "Black-Scholes option pricing for backtesting.",
          "bases": [],
          "methods": [
            {
              "name": "price",
              "module": "options_backtest",
              "signature": "def price(spot: float, strike: float, time_to_expiry: float, volatility: float, rate: float, is_call: bool, dividend_yield: float) -> float",
              "docstring": "Calculate option price using Black-Scholes.",
              "parameters": [
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "strike",
                  "type": "float"
                },
                {
                  "name": "time_to_expiry",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 218
            },
            {
              "name": "delta",
              "module": "options_backtest",
              "signature": "def delta(spot: float, strike: float, time_to_expiry: float, volatility: float, rate: float, is_call: bool, dividend_yield: float) -> float",
              "docstring": "Calculate delta.",
              "parameters": [
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "strike",
                  "type": "float"
                },
                {
                  "name": "time_to_expiry",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 256
            },
            {
              "name": "gamma",
              "module": "options_backtest",
              "signature": "def gamma(spot: float, strike: float, time_to_expiry: float, volatility: float, rate: float, dividend_yield: float) -> float",
              "docstring": "Calculate gamma.",
              "parameters": [
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "strike",
                  "type": "float"
                },
                {
                  "name": "time_to_expiry",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 283
            },
            {
              "name": "theta",
              "module": "options_backtest",
              "signature": "def theta(spot: float, strike: float, time_to_expiry: float, volatility: float, rate: float, is_call: bool, dividend_yield: float) -> float",
              "docstring": "Calculate theta (per day).",
              "parameters": [
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "strike",
                  "type": "float"
                },
                {
                  "name": "time_to_expiry",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 307
            },
            {
              "name": "vega",
              "module": "options_backtest",
              "signature": "def vega(spot: float, strike: float, time_to_expiry: float, volatility: float, rate: float, dividend_yield: float) -> float",
              "docstring": "Calculate vega (per 1% vol move).",
              "parameters": [
                {
                  "name": "spot",
                  "type": "float"
                },
                {
                  "name": "strike",
                  "type": "float"
                },
                {
                  "name": "time_to_expiry",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "rate",
                  "type": "float"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 346
            },
            {
              "name": "_norm_cdf",
              "module": "options_backtest",
              "signature": "def _norm_cdf(x: float) -> float",
              "docstring": "Standard normal CDF approximation.",
              "parameters": [
                {
                  "name": "x",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 372
            },
            {
              "name": "_norm_pdf",
              "module": "options_backtest",
              "signature": "def _norm_pdf(x: float) -> float",
              "docstring": "Standard normal PDF.",
              "parameters": [
                {
                  "name": "x",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 377
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 214
        },
        {
          "name": "OptionStrategyBacktester",
          "module": "options_backtest",
          "docstring": "Options strategy backtesting engine (#O18).\n\nSupports multi-leg strategies with Greeks tracking.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "options_backtest",
              "signature": "def __init__(self, initial_capital: float, risk_free_rate: float, dividend_yield: float)",
              "docstring": "Initialize backtester.\n\nArgs:\n    initial_capital: Starting capital\n    risk_free_rate: Risk-free rate for pricing\n    dividend_yield: Dividend yield for underlying",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "initial_capital",
                  "type": "float"
                },
                {
                  "name": "risk_free_rate",
                  "type": "float"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 389
            },
            {
              "name": "add_position",
              "module": "options_backtest",
              "signature": "def add_position(self, position: OptionPosition, bar: OptionBacktestBar) -> bool",
              "docstring": "Add new position to portfolio.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position",
                  "type": "OptionPosition"
                },
                {
                  "name": "bar",
                  "type": "OptionBacktestBar"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 422
            },
            {
              "name": "close_position",
              "module": "options_backtest",
              "signature": "def close_position(self, position: OptionPosition, bar: OptionBacktestBar, reason: str) -> float",
              "docstring": "Close a position and return P&L.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position",
                  "type": "OptionPosition"
                },
                {
                  "name": "bar",
                  "type": "OptionBacktestBar"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 440
            },
            {
              "name": "run_backtest",
              "module": "options_backtest",
              "signature": "def run_backtest(self, data: list[OptionBacktestBar], entry_signal: Callable[, ], exit_signal: Callable[, bool]) -> OptionBacktestResult",
              "docstring": "Run options strategy backtest.\n\nArgs:\n    data: Historical bar data\n    entry_signal: Function returning position to enter or None\n    exit_signal: Function returning True if should exit\n\nReturns:\n    OptionBacktestResult with metrics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "data",
                  "type": "list[OptionBacktestBar]"
                },
                {
                  "name": "entry_signal",
                  "type": "Callable[, ]"
                },
                {
                  "name": "exit_signal",
                  "type": "Callable[, bool]"
                }
              ],
              "return_type": "OptionBacktestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 469
            },
            {
              "name": "_reset",
              "module": "options_backtest",
              "signature": "def _reset(self) -> None",
              "docstring": "Reset backtest state.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 526
            },
            {
              "name": "_calculate_position_value",
              "module": "options_backtest",
              "signature": "def _calculate_position_value(self, position: OptionPosition, bar: OptionBacktestBar) -> float",
              "docstring": "Calculate current value of position.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position",
                  "type": "OptionPosition"
                },
                {
                  "name": "bar",
                  "type": "OptionBacktestBar"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 540
            },
            {
              "name": "_calculate_position_greeks",
              "module": "options_backtest",
              "signature": "def _calculate_position_greeks(self, position: OptionPosition, bar: OptionBacktestBar) -> OptionGreeks",
              "docstring": "Calculate Greeks for position.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position",
                  "type": "OptionPosition"
                },
                {
                  "name": "bar",
                  "type": "OptionBacktestBar"
                }
              ],
              "return_type": "OptionGreeks",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 569
            },
            {
              "name": "_calculate_portfolio_value",
              "module": "options_backtest",
              "signature": "def _calculate_portfolio_value(self, bar: OptionBacktestBar) -> float",
              "docstring": "Calculate total portfolio value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OptionBacktestBar"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 608
            },
            {
              "name": "_calculate_margin",
              "module": "options_backtest",
              "signature": "def _calculate_margin(self, position: OptionPosition, bar: OptionBacktestBar) -> float",
              "docstring": "Calculate margin requirement for position.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position",
                  "type": "OptionPosition"
                },
                {
                  "name": "bar",
                  "type": "OptionBacktestBar"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 616
            },
            {
              "name": "_handle_expiration",
              "module": "options_backtest",
              "signature": "def _handle_expiration(self, position: OptionPosition, bar: OptionBacktestBar) -> None",
              "docstring": "Handle position expiration.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position",
                  "type": "OptionPosition"
                },
                {
                  "name": "bar",
                  "type": "OptionBacktestBar"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 643
            },
            {
              "name": "_calculate_results",
              "module": "options_backtest",
              "signature": "def _calculate_results(self, start_date: datetime, end_date: datetime) -> OptionBacktestResult",
              "docstring": "Calculate backtest results.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": "datetime"
                },
                {
                  "name": "end_date",
                  "type": "datetime"
                }
              ],
              "return_type": "OptionBacktestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 674
            },
            {
              "name": "_calculate_position_pnl",
              "module": "options_backtest",
              "signature": "def _calculate_position_pnl(self, position: OptionPosition) -> float",
              "docstring": "Calculate P&L for a closed position.\n\nFor a closed position:\n- Entry cost = net_premium (negative for debit, positive for credit)\n- Exit value = intrinsic value at expiration or mark-to-market at close\n\nP&L = exit_value - (-net_premium) = exit_value + net_premium\nFor credit positions (net_premium > 0): profit if option expires worthless\nFor debit positions (net_premium < 0): profit if exit_value > abs(net_premium)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position",
                  "type": "OptionPosition"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 750
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 382
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.order_management": {
      "name": "order_management",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\order_management.py",
      "docstring": "Order Management Module\n=======================\n\nOrder amendment support (Issue #E26).\nBroker error code mapping (Issue #E27).\nOrder rejection reason parsing (Issue #E29).\nFill notification latency tracking (Issue #E28).\n\nFeatures:\n- Order amendment/modification workflow\n- Comprehensive IB error code mapping\n- Rejection reason categorization\n- Latency tracking for fills",
      "classes": [
        {
          "name": "AmendmentType",
          "module": "order_management",
          "docstring": "Type of order amendment.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 30
        },
        {
          "name": "AmendmentStatus",
          "module": "order_management",
          "docstring": "Status of amendment request.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 39
        },
        {
          "name": "RejectionCategory",
          "module": "order_management",
          "docstring": "Categories of order rejection reasons.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 48
        },
        {
          "name": "OrderAmendment",
          "module": "order_management",
          "docstring": "Order amendment request.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "order_management",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 88
            }
          ],
          "class_attributes": [
            {
              "name": "amendment_id",
              "type": "str"
            },
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "amendment_type",
              "type": "AmendmentType"
            },
            {
              "name": "original_price",
              "type": ""
            },
            {
              "name": "original_quantity",
              "type": ""
            },
            {
              "name": "original_tif",
              "type": ""
            },
            {
              "name": "new_price",
              "type": ""
            },
            {
              "name": "new_quantity",
              "type": ""
            },
            {
              "name": "new_tif",
              "type": ""
            },
            {
              "name": "status",
              "type": "AmendmentStatus"
            },
            {
              "name": "submitted_at",
              "type": ""
            },
            {
              "name": "completed_at",
              "type": ""
            },
            {
              "name": "rejection_reason",
              "type": "str"
            },
            {
              "name": "filled_qty_before_amendment",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 63
        },
        {
          "name": "FillLatency",
          "module": "order_management",
          "docstring": "Fill notification latency tracking (#E28).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "order_management",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 121
            }
          ],
          "class_attributes": [
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "fill_id",
              "type": "str"
            },
            {
              "name": "order_submitted_at",
              "type": "datetime"
            },
            {
              "name": "fill_executed_at",
              "type": "datetime"
            },
            {
              "name": "fill_reported_at",
              "type": "datetime"
            },
            {
              "name": "execution_latency_ms",
              "type": "float"
            },
            {
              "name": "reporting_latency_ms",
              "type": "float"
            },
            {
              "name": "venue",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 105
        },
        {
          "name": "RejectionAnalysis",
          "module": "order_management",
          "docstring": "Analysis of order rejection (#E29).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "order_management",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 150
            }
          ],
          "class_attributes": [
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "error_code",
              "type": "int"
            },
            {
              "name": "error_message",
              "type": "str"
            },
            {
              "name": "category",
              "type": "RejectionCategory"
            },
            {
              "name": "is_recoverable",
              "type": "bool"
            },
            {
              "name": "suggested_action",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "venue",
              "type": "str"
            },
            {
              "name": "order_type",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 132
        },
        {
          "name": "IBErrorCodeMapper",
          "module": "order_management",
          "docstring": "Maps Interactive Brokers error codes to categories (#E27).\n\nReference: https://interactivebrokers.github.io/tws-api/message_codes.html",
          "bases": [],
          "methods": [
            {
              "name": "get_error_info",
              "module": "order_management",
              "signature": "def get_error_info(cls, error_code: int) -> tuple[RejectionCategory, bool, str]",
              "docstring": "Get error category, recoverability, and suggested action.\n\nReturns:\n    Tuple of (category, is_recoverable, suggested_action)",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "error_code",
                  "type": "int"
                }
              ],
              "return_type": "tuple[RejectionCategory, bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 267
            },
            {
              "name": "is_fatal_error",
              "module": "order_management",
              "signature": "def is_fatal_error(cls, error_code: int) -> bool",
              "docstring": "Check if error is fatal (non-recoverable).",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "error_code",
                  "type": "int"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 281
            },
            {
              "name": "is_margin_error",
              "module": "order_management",
              "signature": "def is_margin_error(cls, error_code: int) -> bool",
              "docstring": "Check if error is margin-related.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "error_code",
                  "type": "int"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 287
            },
            {
              "name": "is_market_error",
              "module": "order_management",
              "signature": "def is_market_error(cls, error_code: int) -> bool",
              "docstring": "Check if error is market-related (halts, closures).",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "error_code",
                  "type": "int"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 293
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 165
        },
        {
          "name": "OrderAmendmentManager",
          "module": "order_management",
          "docstring": "Manages order amendments/modifications (#E26).\n\nHandles the workflow of modifying existing orders.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "order_management",
              "signature": "def __init__(self, submit_amendment: , cancel_order: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "submit_amendment",
                  "type": ""
                },
                {
                  "name": "cancel_order",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 306
            },
            {
              "name": "update_order_state",
              "module": "order_management",
              "signature": "def update_order_state(self, order_id: str, price: float, quantity: int, status: str, filled_qty: int) -> None",
              "docstring": "Update cached order state.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "status",
                  "type": "str"
                },
                {
                  "name": "filled_qty",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 321
            },
            {
              "name": "can_amend",
              "module": "order_management",
              "signature": "def can_amend(self, order_id: str) -> tuple[bool, str]",
              "docstring": "Check if order can be amended.\n\nReturns:\n    Tuple of (can_amend, reason)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 337
            },
            {
              "name": "create_amendment",
              "module": "order_management",
              "signature": "def create_amendment(self, order_id: str, new_price: , new_quantity: , new_tif: )",
              "docstring": "Create an amendment request.\n\nReturns:\n    OrderAmendment or None if cannot amend",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "new_price",
                  "type": ""
                },
                {
                  "name": "new_quantity",
                  "type": ""
                },
                {
                  "name": "new_tif",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 364
            },
            {
              "name": "submit_amendment",
              "module": "order_management",
              "signature": "def submit_amendment(self, amendment_id: str) -> bool",
              "docstring": "Submit amendment to broker.\n\nReturns:\n    True if submitted successfully",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "amendment_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 415
            },
            {
              "name": "handle_amendment_response",
              "module": "order_management",
              "signature": "def handle_amendment_response(self, order_id: str, accepted: bool, rejection_reason: str) -> None",
              "docstring": "Handle broker response to amendment.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "accepted",
                  "type": "bool"
                },
                {
                  "name": "rejection_reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 452
            },
            {
              "name": "cancel_and_replace",
              "module": "order_management",
              "signature": "def cancel_and_replace(self, order_id: str, new_price: float, new_quantity: int)",
              "docstring": "Cancel order and create replacement (for venues that don't support modify).\n\nReturns:\n    New amendment ID or None",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "new_price",
                  "type": "float"
                },
                {
                  "name": "new_quantity",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 477
            },
            {
              "name": "get_amendment",
              "module": "order_management",
              "signature": "def get_amendment(self, amendment_id: str)",
              "docstring": "Get amendment by ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "amendment_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 505
            },
            {
              "name": "get_amendments_for_order",
              "module": "order_management",
              "signature": "def get_amendments_for_order(self, order_id: str) -> list[OrderAmendment]",
              "docstring": "Get all amendments for an order.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                }
              ],
              "return_type": "list[OrderAmendment]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 509
            },
            {
              "name": "get_pending_amendments",
              "module": "order_management",
              "signature": "def get_pending_amendments(self) -> list[OrderAmendment]",
              "docstring": "Get all pending amendments.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[OrderAmendment]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 513
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 299
        },
        {
          "name": "RejectionAnalyzer",
          "module": "order_management",
          "docstring": "Analyzes order rejections and provides actionable insights (#E29).",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "order_management",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 526
            },
            {
              "name": "analyze_rejection",
              "module": "order_management",
              "signature": "def analyze_rejection(self, order_id: str, error_code: int, error_message: str, symbol: str, venue: str, order_type: str) -> RejectionAnalysis",
              "docstring": "Analyze an order rejection.\n\nReturns:\n    RejectionAnalysis with categorization and suggestions",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "error_code",
                  "type": "int"
                },
                {
                  "name": "error_message",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "venue",
                  "type": "str"
                },
                {
                  "name": "order_type",
                  "type": "str"
                }
              ],
              "return_type": "RejectionAnalysis",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 531
            },
            {
              "name": "_enhance_suggestion",
              "module": "order_management",
              "signature": "def _enhance_suggestion(self, error_code: int, message: str, category: RejectionCategory, base_suggestion: str) -> str",
              "docstring": "Enhance suggestion based on message content.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "error_code",
                  "type": "int"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "category",
                  "type": "RejectionCategory"
                },
                {
                  "name": "base_suggestion",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 576
            },
            {
              "name": "get_rejection_patterns",
              "module": "order_management",
              "signature": "def get_rejection_patterns(self) -> dict",
              "docstring": "Identify patterns in rejections.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 620
            },
            {
              "name": "get_statistics",
              "module": "order_management",
              "signature": "def get_statistics(self) -> dict",
              "docstring": "Get rejection statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 657
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 521
        },
        {
          "name": "FillLatencyTracker",
          "module": "order_management",
          "docstring": "Tracks fill notification latency (#E28).\n\nMonitors time from order submission to fill notification.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "order_management",
              "signature": "def __init__(self, alert_threshold_ms: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "alert_threshold_ms",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 673
            },
            {
              "name": "record_order_submitted",
              "module": "order_management",
              "signature": "def record_order_submitted(self, order_id: str, submitted_at: ) -> None",
              "docstring": "Record when order was submitted.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "submitted_at",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 688
            },
            {
              "name": "record_fill",
              "module": "order_management",
              "signature": "def record_fill(self, order_id: str, fill_id: str, fill_executed_at: datetime, fill_reported_at: , venue: str)",
              "docstring": "Record fill notification and calculate latencies.\n\nReturns:\n    FillLatency with calculated metrics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "fill_id",
                  "type": "str"
                },
                {
                  "name": "fill_executed_at",
                  "type": "datetime"
                },
                {
                  "name": "fill_reported_at",
                  "type": ""
                },
                {
                  "name": "venue",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 696
            },
            {
              "name": "get_venue_statistics",
              "module": "order_management",
              "signature": "def get_venue_statistics(self, venue: str)",
              "docstring": "Get latency statistics for a venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 755
            },
            {
              "name": "get_all_statistics",
              "module": "order_management",
              "signature": "def get_all_statistics(self) -> dict",
              "docstring": "Get latency statistics for all venues.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 795
            },
            {
              "name": "get_recent_alerts",
              "module": "order_management",
              "signature": "def get_recent_alerts(self, limit: int) -> list[dict]",
              "docstring": "Get recent latency alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 802
            },
            {
              "name": "cleanup_old_orders",
              "module": "order_management",
              "signature": "def cleanup_old_orders(self, max_age_hours: int) -> int",
              "docstring": "Clean up old order submission records.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "max_age_hours",
                  "type": "int"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 806
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 666
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "time",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__",
        "time"
      ]
    },
    "core.order_throttling": {
      "name": "order_throttling",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\order_throttling.py",
      "docstring": "Order Throttling Module\n=======================\n\nPer-venue order throttling to prevent excessive order submission (Issue #E25).\n\nFeatures:\n- Per-venue rate limits\n- Sliding window throttling\n- Adaptive throttling based on rejections\n- Burst allowance with recovery\n- Exchange-specific configurations",
      "classes": [
        {
          "name": "ThrottleAction",
          "module": "order_throttling",
          "docstring": "Throttle decision.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 29
        },
        {
          "name": "VenueConfig",
          "module": "order_throttling",
          "docstring": "Rate limit configuration for a venue.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "venue_id",
              "type": "str"
            },
            {
              "name": "max_orders_per_second",
              "type": "float"
            },
            {
              "name": "max_orders_per_minute",
              "type": "float"
            },
            {
              "name": "max_orders_per_hour",
              "type": "float"
            },
            {
              "name": "burst_limit",
              "type": "int"
            },
            {
              "name": "burst_recovery_seconds",
              "type": "float"
            },
            {
              "name": "rejection_backoff_factor",
              "type": "float"
            },
            {
              "name": "min_order_interval_ms",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 37
        },
        {
          "name": "ThrottleState",
          "module": "order_throttling",
          "docstring": "Current throttle state for a venue.",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "order_throttling",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 65
            }
          ],
          "class_attributes": [
            {
              "name": "venue_id",
              "type": "str"
            },
            {
              "name": "orders_last_second",
              "type": "deque"
            },
            {
              "name": "orders_last_minute",
              "type": "deque"
            },
            {
              "name": "orders_last_hour",
              "type": "deque"
            },
            {
              "name": "last_order_time",
              "type": "float"
            },
            {
              "name": "burst_tokens",
              "type": "float"
            },
            {
              "name": "last_burst_refill",
              "type": "float"
            },
            {
              "name": "consecutive_rejections",
              "type": "int"
            },
            {
              "name": "last_rejection_time",
              "type": "float"
            },
            {
              "name": "total_orders",
              "type": "int"
            },
            {
              "name": "total_throttled",
              "type": "int"
            },
            {
              "name": "total_delayed",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 50
        },
        {
          "name": "ThrottleResult",
          "module": "order_throttling",
          "docstring": "Result of throttle check.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "action",
              "type": "ThrottleAction"
            },
            {
              "name": "venue_id",
              "type": "str"
            },
            {
              "name": "delay_ms",
              "type": "float"
            },
            {
              "name": "reason",
              "type": "str"
            },
            {
              "name": "current_rate_per_second",
              "type": "float"
            },
            {
              "name": "limit_per_second",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 71
        },
        {
          "name": "OrderThrottler",
          "module": "order_throttling",
          "docstring": "Per-venue order throttling implementation (#E25).\n\nPrevents excessive order submission to protect against:\n- Exchange rate limit violations\n- Runaway algorithms\n- Unintended order spam",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "order_throttling",
              "signature": "def __init__(self, custom_configs: , global_max_per_second: float, adaptive_throttling: bool)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "custom_configs",
                  "type": ""
                },
                {
                  "name": "global_max_per_second",
                  "type": "float"
                },
                {
                  "name": "adaptive_throttling",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 149
            },
            {
              "name": "get_config",
              "module": "order_throttling",
              "signature": "def get_config(self, venue_id: str) -> VenueConfig",
              "docstring": "Get configuration for venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                }
              ],
              "return_type": "VenueConfig",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 165
            },
            {
              "name": "get_state",
              "module": "order_throttling",
              "signature": "def get_state(self, venue_id: str) -> ThrottleState",
              "docstring": "Get or create state for venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                }
              ],
              "return_type": "ThrottleState",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 169
            },
            {
              "name": "check_throttle",
              "module": "order_throttling",
              "signature": "def check_throttle(self, venue_id: str) -> ThrottleResult",
              "docstring": "Check if order should be throttled for a venue.\n\nReturns ThrottleResult with action (ALLOW, DELAY, or REJECT).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                }
              ],
              "return_type": "ThrottleResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 175
            },
            {
              "name": "record_order",
              "module": "order_throttling",
              "signature": "def record_order(self, venue_id: str) -> None",
              "docstring": "Record that an order was submitted.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 259
            },
            {
              "name": "record_rejection",
              "module": "order_throttling",
              "signature": "def record_rejection(self, venue_id: str, reason: str) -> None",
              "docstring": "Record that an order was rejected by the venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 278
            },
            {
              "name": "record_success",
              "module": "order_throttling",
              "signature": "def record_success(self, venue_id: str) -> None",
              "docstring": "Record that an order was accepted by the venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 290
            },
            {
              "name": "_clean_old_entries",
              "module": "order_throttling",
              "signature": "def _clean_old_entries(self, state: ThrottleState, now: float) -> None",
              "docstring": "Remove entries older than their window.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "ThrottleState"
                },
                {
                  "name": "now",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 298
            },
            {
              "name": "_check_global_limit",
              "module": "order_throttling",
              "signature": "def _check_global_limit(self, now: float) -> ThrottleResult",
              "docstring": "Check global rate limit across all venues.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "now",
                  "type": "float"
                }
              ],
              "return_type": "ThrottleResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 312
            },
            {
              "name": "_get_effective_limits",
              "module": "order_throttling",
              "signature": "def _get_effective_limits(self, config: VenueConfig, state: ThrottleState) -> dict[str, float]",
              "docstring": "Get effective limits considering adaptive backoff.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "VenueConfig"
                },
                {
                  "name": "state",
                  "type": "ThrottleState"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 331
            },
            {
              "name": "_refill_burst_tokens",
              "module": "order_throttling",
              "signature": "def _refill_burst_tokens(self, state: ThrottleState, config: VenueConfig, now: float) -> None",
              "docstring": "Refill burst tokens based on time elapsed.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "state",
                  "type": "ThrottleState"
                },
                {
                  "name": "config",
                  "type": "VenueConfig"
                },
                {
                  "name": "now",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 359
            },
            {
              "name": "get_venue_stats",
              "module": "order_throttling",
              "signature": "def get_venue_stats(self, venue_id: str) -> dict",
              "docstring": "Get throttle statistics for a venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 375
            },
            {
              "name": "get_all_stats",
              "module": "order_throttling",
              "signature": "def get_all_stats(self) -> dict[str, dict]",
              "docstring": "Get statistics for all venues.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 408
            },
            {
              "name": "reset_venue",
              "module": "order_throttling",
              "signature": "def reset_venue(self, venue_id: str) -> None",
              "docstring": "Reset throttle state for a venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 412
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 81
        },
        {
          "name": "ThrottledOrderExecutor",
          "module": "order_throttling",
          "docstring": "Wrapper that applies throttling before order execution.\n\nUse this to wrap your order submission logic.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "order_throttling",
              "signature": "def __init__(self, throttler: OrderThrottler, max_delay_ms: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "throttler",
                  "type": "OrderThrottler"
                },
                {
                  "name": "max_delay_ms",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 427
            },
            {
              "name": "execute_with_throttle",
              "module": "order_throttling",
              "signature": "async def execute_with_throttle(self, venue_id: str, order_func)",
              "docstring": "Execute order function with throttling.\n\nArgs:\n    venue_id: Target venue\n    order_func: Async function to execute order\n    *args, **kwargs: Arguments for order_func\n\nReturns:\n    Result of order_func\n\nRaises:\n    ThrottleRejectedException if order is rejected",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_id",
                  "type": "str"
                },
                {
                  "name": "order_func"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 435
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 420
        },
        {
          "name": "ThrottleRejectedException",
          "module": "order_throttling",
          "docstring": "Exception raised when order is rejected due to throttling.",
          "bases": [
            "Exception"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 490
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "time",
        "collections",
        "dataclasses",
        "datetime",
        "enum",
        "threading",
        "typing",
        "asyncio"
      ],
      "dependencies": [
        "__future__",
        "time",
        "threading"
      ]
    },
    "core.performance_profiling": {
      "name": "performance_profiling",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\performance_profiling.py",
      "docstring": "Performance Profiling Module\n============================\n\nAddresses issues:\n- #S15: No performance profiling hooks\n- #S17: No load testing framework\n\nFeatures:\n- Function-level profiling with minimal overhead\n- Critical path identification\n- Memory profiling\n- Load testing framework\n- Performance regression detection",
      "classes": [
        {
          "name": "ProfileMetrics",
          "module": "performance_profiling",
          "docstring": "Metrics for a profiled function.",
          "bases": [],
          "methods": [
            {
              "name": "record",
              "module": "performance_profiling",
              "signature": "def record(self, duration_ms: float, is_error: bool) -> None",
              "docstring": "Record a call duration.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "duration_ms",
                  "type": "float"
                },
                {
                  "name": "is_error",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 62
            },
            {
              "name": "to_dict",
              "module": "performance_profiling",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 88
            }
          ],
          "class_attributes": [
            {
              "name": "function_name",
              "type": "str"
            },
            {
              "name": "call_count",
              "type": "int"
            },
            {
              "name": "total_time_ms",
              "type": "float"
            },
            {
              "name": "min_time_ms",
              "type": "float"
            },
            {
              "name": "max_time_ms",
              "type": "float"
            },
            {
              "name": "avg_time_ms",
              "type": "float"
            },
            {
              "name": "p50_time_ms",
              "type": "float"
            },
            {
              "name": "p95_time_ms",
              "type": "float"
            },
            {
              "name": "p99_time_ms",
              "type": "float"
            },
            {
              "name": "std_dev_ms",
              "type": "float"
            },
            {
              "name": "last_call_time",
              "type": ""
            },
            {
              "name": "errors",
              "type": "int"
            },
            {
              "name": "_times",
              "type": "list[float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 46
        },
        {
          "name": "PerformanceProfiler",
          "module": "performance_profiling",
          "docstring": "Performance profiling system (#S15).\n\nLow-overhead profiling for production use.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "performance_profiling",
              "signature": "def __init__(self, enabled: bool, slow_threshold_ms: float, log_slow_calls: bool)",
              "docstring": "Initialize profiler.\n\nArgs:\n    enabled: Enable profiling\n    slow_threshold_ms: Threshold for slow call logging\n    log_slow_calls: Log calls exceeding threshold",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "enabled",
                  "type": "bool"
                },
                {
                  "name": "slow_threshold_ms",
                  "type": "float"
                },
                {
                  "name": "log_slow_calls",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 113
            },
            {
              "name": "profile",
              "module": "performance_profiling",
              "signature": "def profile(self, name: , log_slow: , slow_threshold_ms: )",
              "docstring": "Decorator to profile a function.\n\nArgs:\n    name: Custom name (default: function name)\n    log_slow: Override slow logging setting\n    slow_threshold_ms: Override slow threshold\n\nExample:\n    @profiler.profile()\n    def calculate_var():\n        ...",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": ""
                },
                {
                  "name": "log_slow",
                  "type": ""
                },
                {
                  "name": "slow_threshold_ms",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 135
            },
            {
              "name": "measure",
              "module": "performance_profiling",
              "signature": "def measure(self, name: str)",
              "docstring": "Context manager for profiling code blocks.\n\nExample:\n    with profiler.measure(\"data_processing\"):\n        process_data()",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "contextmanager"
              ],
              "is_async": false,
              "line_number": 186
            },
            {
              "name": "_record",
              "module": "performance_profiling",
              "signature": "def _record(self, name: str, duration_ms: float, is_error: bool) -> None",
              "docstring": "Record a measurement.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "duration_ms",
                  "type": "float"
                },
                {
                  "name": "is_error",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 210
            },
            {
              "name": "get_metrics",
              "module": "performance_profiling",
              "signature": "def get_metrics(self, name: str)",
              "docstring": "Get metrics for a specific function.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 217
            },
            {
              "name": "get_all_metrics",
              "module": "performance_profiling",
              "signature": "def get_all_metrics(self) -> dict[str, dict]",
              "docstring": "Get all profiling metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 222
            },
            {
              "name": "get_slowest_functions",
              "module": "performance_profiling",
              "signature": "def get_slowest_functions(self, n: int, by: str) -> list[dict]",
              "docstring": "Get slowest functions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n",
                  "type": "int"
                },
                {
                  "name": "by",
                  "type": "str"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 227
            },
            {
              "name": "get_most_called",
              "module": "performance_profiling",
              "signature": "def get_most_called(self, n: int) -> list[dict]",
              "docstring": "Get most frequently called functions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 254
            },
            {
              "name": "reset",
              "module": "performance_profiling",
              "signature": "def reset(self) -> None",
              "docstring": "Reset all metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 264
            },
            {
              "name": "get_summary",
              "module": "performance_profiling",
              "signature": "def get_summary(self) -> dict",
              "docstring": "Get profiling summary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 270
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 106
        },
        {
          "name": "MemoryProfiler",
          "module": "performance_profiling",
          "docstring": "Memory profiling utilities.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "performance_profiling",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 289
            },
            {
              "name": "start_tracking",
              "module": "performance_profiling",
              "signature": "def start_tracking(self) -> None",
              "docstring": "Start memory tracking.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 293
            },
            {
              "name": "stop_tracking",
              "module": "performance_profiling",
              "signature": "def stop_tracking(self)",
              "docstring": "Stop tracking and return snapshot.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 299
            },
            {
              "name": "take_snapshot",
              "module": "performance_profiling",
              "signature": "def take_snapshot(self) -> None",
              "docstring": "Take a memory snapshot.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 308
            },
            {
              "name": "get_top_allocations",
              "module": "performance_profiling",
              "signature": "def get_top_allocations(self, n: int) -> list[dict]",
              "docstring": "Get top memory allocations.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 314
            },
            {
              "name": "get_current_memory_mb",
              "module": "performance_profiling",
              "signature": "def get_current_memory_mb() -> float",
              "docstring": "Get current process memory usage.",
              "parameters": [],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 332
            },
            {
              "name": "measure_memory",
              "module": "performance_profiling",
              "signature": "def measure_memory(self, label: str)",
              "docstring": "Context manager to measure memory delta.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "label",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "contextmanager"
              ],
              "is_async": false,
              "line_number": 338
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 286
        },
        {
          "name": "LoadTestResult",
          "module": "performance_profiling",
          "docstring": "Result of a load test run.",
          "bases": [],
          "methods": [
            {
              "name": "success_rate",
              "module": "performance_profiling",
              "signature": "def success_rate(self) -> float",
              "docstring": "Success rate as percentage.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 374
            },
            {
              "name": "to_dict",
              "module": "performance_profiling",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 380
            }
          ],
          "class_attributes": [
            {
              "name": "test_name",
              "type": "str"
            },
            {
              "name": "duration_seconds",
              "type": "float"
            },
            {
              "name": "total_requests",
              "type": "int"
            },
            {
              "name": "successful_requests",
              "type": "int"
            },
            {
              "name": "failed_requests",
              "type": "int"
            },
            {
              "name": "requests_per_second",
              "type": "float"
            },
            {
              "name": "avg_latency_ms",
              "type": "float"
            },
            {
              "name": "p50_latency_ms",
              "type": "float"
            },
            {
              "name": "p95_latency_ms",
              "type": "float"
            },
            {
              "name": "p99_latency_ms",
              "type": "float"
            },
            {
              "name": "max_latency_ms",
              "type": "float"
            },
            {
              "name": "min_latency_ms",
              "type": "float"
            },
            {
              "name": "errors",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 357
        },
        {
          "name": "LoadTester",
          "module": "performance_profiling",
          "docstring": "Load testing framework (#S17).\n\nSupports:\n- Concurrent request simulation\n- Ramp-up patterns\n- Performance baseline comparison",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "performance_profiling",
              "signature": "def __init__(self, max_workers: int)",
              "docstring": "Initialize load tester.\n\nArgs:\n    max_workers: Maximum concurrent workers",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "max_workers",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 412
            },
            {
              "name": "run_load_test",
              "module": "performance_profiling",
              "signature": "def run_load_test(self, test_name: str, func: Callable[, Any], num_requests: int, concurrent_users: int, ramp_up_seconds: float, think_time_ms: float) -> LoadTestResult",
              "docstring": "Run a load test.\n\nArgs:\n    test_name: Name of the test\n    func: Function to test\n    num_requests: Total number of requests\n    concurrent_users: Number of concurrent users\n    ramp_up_seconds: Time to ramp up to full concurrency\n    think_time_ms: Delay between requests per user\n\nReturns:\n    LoadTestResult with metrics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "test_name",
                  "type": "str"
                },
                {
                  "name": "func",
                  "type": "Callable[, Any]"
                },
                {
                  "name": "num_requests",
                  "type": "int"
                },
                {
                  "name": "concurrent_users",
                  "type": "int"
                },
                {
                  "name": "ramp_up_seconds",
                  "type": "float"
                },
                {
                  "name": "think_time_ms",
                  "type": "float"
                }
              ],
              "return_type": "LoadTestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 422
            },
            {
              "name": "run_stress_test",
              "module": "performance_profiling",
              "signature": "def run_stress_test(self, test_name: str, func: Callable[, Any], duration_seconds: float, start_users: int, max_users: int, step_users: int, step_duration_seconds: float) -> list[LoadTestResult]",
              "docstring": "Run a stress test with increasing load.\n\nReturns results for each step.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "test_name",
                  "type": "str"
                },
                {
                  "name": "func",
                  "type": "Callable[, Any]"
                },
                {
                  "name": "duration_seconds",
                  "type": "float"
                },
                {
                  "name": "start_users",
                  "type": "int"
                },
                {
                  "name": "max_users",
                  "type": "int"
                },
                {
                  "name": "step_users",
                  "type": "int"
                },
                {
                  "name": "step_duration_seconds",
                  "type": "float"
                }
              ],
              "return_type": "list[LoadTestResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 525
            },
            {
              "name": "compare_with_baseline",
              "module": "performance_profiling",
              "signature": "def compare_with_baseline(self, current: LoadTestResult, baseline: LoadTestResult, latency_threshold_pct: float, throughput_threshold_pct: float) -> dict",
              "docstring": "Compare test result with baseline.\n\nReturns comparison analysis.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current",
                  "type": "LoadTestResult"
                },
                {
                  "name": "baseline",
                  "type": "LoadTestResult"
                },
                {
                  "name": "latency_threshold_pct",
                  "type": "float"
                },
                {
                  "name": "throughput_threshold_pct",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 566
            },
            {
              "name": "get_all_results",
              "module": "performance_profiling",
              "signature": "def get_all_results(self) -> list[dict]",
              "docstring": "Get all test results.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 604
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 402
        }
      ],
      "functions": [
        {
          "name": "get_profiler",
          "module": "performance_profiling",
          "signature": "def get_profiler() -> PerformanceProfiler",
          "docstring": "Get global profiler instance.",
          "parameters": [],
          "return_type": "PerformanceProfiler",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 613
        },
        {
          "name": "profiled",
          "module": "performance_profiling",
          "signature": "def profiled(name: , slow_threshold_ms: )",
          "docstring": "Decorator using global profiler.",
          "parameters": [
            {
              "name": "name",
              "type": ""
            },
            {
              "name": "slow_threshold_ms",
              "type": ""
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 621
        }
      ],
      "constants": [
        {
          "name": "T",
          "line": 38
        }
      ],
      "imports": [
        "__future__",
        "asyncio",
        "functools",
        "gc",
        "logging",
        "statistics",
        "sys",
        "threading",
        "time",
        "tracemalloc",
        "collections",
        "concurrent.futures",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "contextlib",
        "sys"
      ],
      "dependencies": [
        "__future__",
        "gc",
        "threading",
        "time",
        "tracemalloc",
        "concurrent.futures",
        "contextlib"
      ]
    },
    "core.portfolio_construction": {
      "name": "portfolio_construction",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\portfolio_construction.py",
      "docstring": "Portfolio Construction Module\n=============================\n\nTarget portfolio construction (Issue #P14).\nTrade list generation (Issue #P15).\nPortfolio comparison tools (Issue #P18).\n\nFeatures:\n- Target weight calculation\n- Trade list with rebalancing\n- Portfolio comparison metrics\n- Transaction cost optimization",
      "classes": [
        {
          "name": "RebalanceMethod",
          "module": "portfolio_construction",
          "docstring": "Rebalancing methodology.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 28
        },
        {
          "name": "TradeReason",
          "module": "portfolio_construction",
          "docstring": "Reason for generating a trade.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 36
        },
        {
          "name": "TargetPosition",
          "module": "portfolio_construction",
          "docstring": "Target position in a portfolio.",
          "bases": [],
          "methods": [
            {
              "name": "weight_difference",
              "module": "portfolio_construction",
              "signature": "def weight_difference(self) -> float",
              "docstring": "Difference from target.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 68
            },
            {
              "name": "is_overweight",
              "module": "portfolio_construction",
              "signature": "def is_overweight(self) -> bool",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 73
            },
            {
              "name": "is_underweight",
              "module": "portfolio_construction",
              "signature": "def is_underweight(self) -> bool",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 77
            },
            {
              "name": "to_dict",
              "module": "portfolio_construction",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 80
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "target_weight",
              "type": "float"
            },
            {
              "name": "target_shares",
              "type": "int"
            },
            {
              "name": "target_value",
              "type": "float"
            },
            {
              "name": "min_weight",
              "type": "float"
            },
            {
              "name": "max_weight",
              "type": "float"
            },
            {
              "name": "current_weight",
              "type": "float"
            },
            {
              "name": "current_shares",
              "type": "int"
            },
            {
              "name": "current_value",
              "type": "float"
            },
            {
              "name": "sector",
              "type": "str"
            },
            {
              "name": "asset_class",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 47
        },
        {
          "name": "Trade",
          "module": "portfolio_construction",
          "docstring": "Individual trade in a trade list.",
          "bases": [],
          "methods": [
            {
              "name": "notional",
              "module": "portfolio_construction",
              "signature": "def notional(self) -> float",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 125
            },
            {
              "name": "to_dict",
              "module": "portfolio_construction",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 128
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "estimated_price",
              "type": "float"
            },
            {
              "name": "reason",
              "type": "TradeReason"
            },
            {
              "name": "urgency",
              "type": "str"
            },
            {
              "name": "estimated_commission",
              "type": "float"
            },
            {
              "name": "estimated_impact",
              "type": "float"
            },
            {
              "name": "total_cost",
              "type": "float"
            },
            {
              "name": "estimated_gain_loss",
              "type": "float"
            },
            {
              "name": "is_short_term",
              "type": "bool"
            },
            {
              "name": "estimated_tax",
              "type": "float"
            },
            {
              "name": "order_type",
              "type": "str"
            },
            {
              "name": "limit_price",
              "type": ""
            },
            {
              "name": "priority",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 96
        },
        {
          "name": "TradeList",
          "module": "portfolio_construction",
          "docstring": "Complete trade list for rebalancing.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "portfolio_construction",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 167
            }
          ],
          "class_attributes": [
            {
              "name": "trades",
              "type": "list[Trade]"
            },
            {
              "name": "generated_at",
              "type": "datetime"
            },
            {
              "name": "total_buys",
              "type": "int"
            },
            {
              "name": "total_sells",
              "type": "int"
            },
            {
              "name": "total_buy_value",
              "type": "float"
            },
            {
              "name": "total_sell_value",
              "type": "float"
            },
            {
              "name": "net_cash_flow",
              "type": "float"
            },
            {
              "name": "total_commission",
              "type": "float"
            },
            {
              "name": "total_impact",
              "type": "float"
            },
            {
              "name": "total_estimated_tax",
              "type": "float"
            },
            {
              "name": "rebalance_method",
              "type": "RebalanceMethod"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 147
        },
        {
          "name": "PortfolioComparison",
          "module": "portfolio_construction",
          "docstring": "Comparison between two portfolios (#P18).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "portfolio_construction",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 212
            }
          ],
          "class_attributes": [
            {
              "name": "portfolio1_name",
              "type": "str"
            },
            {
              "name": "portfolio2_name",
              "type": "str"
            },
            {
              "name": "comparison_date",
              "type": "datetime"
            },
            {
              "name": "positions_only_in_1",
              "type": "list[str]"
            },
            {
              "name": "positions_only_in_2",
              "type": "list[str]"
            },
            {
              "name": "common_positions",
              "type": "list[str]"
            },
            {
              "name": "weight_differences",
              "type": "dict[str, float]"
            },
            {
              "name": "max_weight_diff",
              "type": "float"
            },
            {
              "name": "avg_weight_diff",
              "type": "float"
            },
            {
              "name": "var_diff",
              "type": ""
            },
            {
              "name": "volatility_diff",
              "type": ""
            },
            {
              "name": "beta_diff",
              "type": ""
            },
            {
              "name": "sector_diffs",
              "type": "dict[str, float]"
            },
            {
              "name": "similarity_score",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 185
        },
        {
          "name": "TargetPortfolioBuilder",
          "module": "portfolio_construction",
          "docstring": "Builds target portfolios (#P14).\n\nSupports multiple construction methodologies.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_construction",
              "signature": "def __init__(self, min_position_weight: float, max_position_weight: float, round_lots: bool, lot_size: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "min_position_weight",
                  "type": "float"
                },
                {
                  "name": "max_position_weight",
                  "type": "float"
                },
                {
                  "name": "round_lots",
                  "type": "bool"
                },
                {
                  "name": "lot_size",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 235
            },
            {
              "name": "set_price",
              "module": "portfolio_construction",
              "signature": "def set_price(self, symbol: str, price: float) -> None",
              "docstring": "Set price for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 256
            },
            {
              "name": "set_holding",
              "module": "portfolio_construction",
              "signature": "def set_holding(self, symbol: str, quantity: int) -> None",
              "docstring": "Set current holding.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 260
            },
            {
              "name": "set_sector",
              "module": "portfolio_construction",
              "signature": "def set_sector(self, symbol: str, sector: str) -> None",
              "docstring": "Set sector for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "sector",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 264
            },
            {
              "name": "build_equal_weight",
              "module": "portfolio_construction",
              "signature": "def build_equal_weight(self, symbols: list[str], portfolio_value: float) -> list[TargetPosition]",
              "docstring": "Build equal-weight portfolio.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "list[TargetPosition]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 268
            },
            {
              "name": "build_market_cap_weight",
              "module": "portfolio_construction",
              "signature": "def build_market_cap_weight(self, symbols_with_mcap: dict[str, float], portfolio_value: float) -> list[TargetPosition]",
              "docstring": "Build market-cap weighted portfolio.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols_with_mcap",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "list[TargetPosition]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 306
            },
            {
              "name": "build_custom_weight",
              "module": "portfolio_construction",
              "signature": "def build_custom_weight(self, target_weights: dict[str, float], portfolio_value: float) -> list[TargetPosition]",
              "docstring": "Build portfolio with custom weights.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "target_weights",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "list[TargetPosition]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 348
            },
            {
              "name": "build_risk_parity",
              "module": "portfolio_construction",
              "signature": "def build_risk_parity(self, symbols_with_vol: dict[str, float], portfolio_value: float) -> list[TargetPosition]",
              "docstring": "Build risk parity portfolio (equal risk contribution).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols_with_vol",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "list[TargetPosition]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 401
            },
            {
              "name": "_calculate_shares",
              "module": "portfolio_construction",
              "signature": "def _calculate_shares(self, target_value: float, price: float) -> int",
              "docstring": "Calculate target shares with optional rounding.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "target_value",
                  "type": "float"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 447
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 228
        },
        {
          "name": "TradeListGenerator",
          "module": "portfolio_construction",
          "docstring": "Generates trade lists from target portfolios (#P15).\n\nSupports multiple rebalancing methods.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_construction",
              "signature": "def __init__(self, commission_per_share: float, commission_min: float, impact_rate: float, short_term_tax_rate: float, long_term_tax_rate: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "commission_per_share",
                  "type": "float"
                },
                {
                  "name": "commission_min",
                  "type": "float"
                },
                {
                  "name": "impact_rate",
                  "type": "float"
                },
                {
                  "name": "short_term_tax_rate",
                  "type": "float"
                },
                {
                  "name": "long_term_tax_rate",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 467
            },
            {
              "name": "set_cost_basis",
              "module": "portfolio_construction",
              "signature": "def set_cost_basis(self, symbol: str, cost_per_share: float, is_short_term: bool) -> None",
              "docstring": "Set cost basis for tax calculations.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "cost_per_share",
                  "type": "float"
                },
                {
                  "name": "is_short_term",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 485
            },
            {
              "name": "generate_full_rebalance",
              "module": "portfolio_construction",
              "signature": "def generate_full_rebalance(self, targets: list[TargetPosition], available_cash: float) -> TradeList",
              "docstring": "Generate trade list for full rebalance.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "targets",
                  "type": "list[TargetPosition]"
                },
                {
                  "name": "available_cash",
                  "type": "float"
                }
              ],
              "return_type": "TradeList",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 490
            },
            {
              "name": "generate_threshold_rebalance",
              "module": "portfolio_construction",
              "signature": "def generate_threshold_rebalance(self, targets: list[TargetPosition], threshold: float) -> TradeList",
              "docstring": "Generate trades only for positions outside threshold.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "targets",
                  "type": "list[TargetPosition]"
                },
                {
                  "name": "threshold",
                  "type": "float"
                }
              ],
              "return_type": "TradeList",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 519
            },
            {
              "name": "generate_tax_aware_rebalance",
              "module": "portfolio_construction",
              "signature": "def generate_tax_aware_rebalance(self, targets: list[TargetPosition], max_tax: float) -> TradeList",
              "docstring": "Generate trades minimizing tax impact.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "targets",
                  "type": "list[TargetPosition]"
                },
                {
                  "name": "max_tax",
                  "type": "float"
                }
              ],
              "return_type": "TradeList",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 557
            },
            {
              "name": "_create_trade",
              "module": "portfolio_construction",
              "signature": "def _create_trade(self, symbol: str, side: str, quantity: int, price: float, reason: TradeReason, urgency: str) -> Trade",
              "docstring": "Create a trade with cost estimates.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "reason",
                  "type": "TradeReason"
                },
                {
                  "name": "urgency",
                  "type": "str"
                }
              ],
              "return_type": "Trade",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 640
            },
            {
              "name": "_finalize_trade_list",
              "module": "portfolio_construction",
              "signature": "def _finalize_trade_list(self, trades: list[Trade], method: RebalanceMethod) -> TradeList",
              "docstring": "Finalize trade list with summary calculations.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trades",
                  "type": "list[Trade]"
                },
                {
                  "name": "method",
                  "type": "RebalanceMethod"
                }
              ],
              "return_type": "TradeList",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 672
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 460
        },
        {
          "name": "PortfolioComparator",
          "module": "portfolio_construction",
          "docstring": "Compares portfolios (#P18).\n\nProvides detailed comparison metrics.",
          "bases": [],
          "methods": [
            {
              "name": "compare",
              "module": "portfolio_construction",
              "signature": "def compare(self, portfolio1: dict[str, float], portfolio2: dict[str, float], name1: str, name2: str, sectors: ) -> PortfolioComparison",
              "docstring": "Compare two portfolios by weight.\n\nArgs:\n    portfolio1: First portfolio weights\n    portfolio2: Second portfolio weights\n    name1: Name for first portfolio\n    name2: Name for second portfolio\n    sectors: Optional sector assignments\n\nReturns:\n    PortfolioComparison with detailed metrics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio1",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio2",
                  "type": "dict[str, float]"
                },
                {
                  "name": "name1",
                  "type": "str"
                },
                {
                  "name": "name2",
                  "type": "str"
                },
                {
                  "name": "sectors",
                  "type": ""
                }
              ],
              "return_type": "PortfolioComparison",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 706
            },
            {
              "name": "track_drift",
              "module": "portfolio_construction",
              "signature": "def track_drift(self, original: dict[str, float], current: dict[str, float], name: str) -> dict",
              "docstring": "Track portfolio drift from original weights.\n\nReturns drift metrics and rebalance recommendations.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "original",
                  "type": "dict[str, float]"
                },
                {
                  "name": "current",
                  "type": "dict[str, float]"
                },
                {
                  "name": "name",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 783
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 699
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.portfolio_export": {
      "name": "portfolio_export",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\portfolio_export.py",
      "docstring": "Portfolio Export Module\n=======================\n\nAddresses issues:\n- #P20: Portfolio metrics caching suboptimal\n- #P21: No portfolio export formats (IBKR, etc.)\n\nFeatures:\n- Export portfolio to IBKR flex query format\n- CSV/Excel export with multiple templates\n- FIX protocol format\n- Portfolio metrics caching with intelligent invalidation",
      "classes": [
        {
          "name": "ExportFormat",
          "module": "portfolio_export",
          "docstring": "Portfolio export formats.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 35
        },
        {
          "name": "PortfolioPosition",
          "module": "portfolio_export",
          "docstring": "Position for export.",
          "bases": [],
          "methods": [
            {
              "name": "pnl_pct",
              "module": "portfolio_export",
              "signature": "def pnl_pct(self) -> float",
              "docstring": "P&L as percentage.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 63
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "avg_cost",
              "type": "float"
            },
            {
              "name": "market_price",
              "type": "float"
            },
            {
              "name": "market_value",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "realized_pnl",
              "type": "float"
            },
            {
              "name": "asset_class",
              "type": "str"
            },
            {
              "name": "currency",
              "type": "str"
            },
            {
              "name": "exchange",
              "type": ""
            },
            {
              "name": "conid",
              "type": ""
            },
            {
              "name": "account",
              "type": "str"
            },
            {
              "name": "sector",
              "type": "str"
            },
            {
              "name": "last_updated",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 45
        },
        {
          "name": "PortfolioSummary",
          "module": "portfolio_export",
          "docstring": "Portfolio summary for export.",
          "bases": [],
          "methods": [
            {
              "name": "position_count",
              "module": "portfolio_export",
              "signature": "def position_count(self) -> int",
              "docstring": "Number of positions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 88
            },
            {
              "name": "total_unrealized_pnl",
              "module": "portfolio_export",
              "signature": "def total_unrealized_pnl(self) -> float",
              "docstring": "Total unrealized P&L.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 93
            }
          ],
          "class_attributes": [
            {
              "name": "account_id",
              "type": "str"
            },
            {
              "name": "as_of_date",
              "type": "datetime"
            },
            {
              "name": "net_liquidation",
              "type": "float"
            },
            {
              "name": "gross_position_value",
              "type": "float"
            },
            {
              "name": "cash",
              "type": "float"
            },
            {
              "name": "buying_power",
              "type": "float"
            },
            {
              "name": "excess_liquidity",
              "type": "float"
            },
            {
              "name": "maintenance_margin",
              "type": "float"
            },
            {
              "name": "available_funds",
              "type": "float"
            },
            {
              "name": "currency",
              "type": "str"
            },
            {
              "name": "positions",
              "type": "list[PortfolioPosition]"
            },
            {
              "name": "metadata",
              "type": "dict"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 72
        },
        {
          "name": "IBKRFlexExporter",
          "module": "portfolio_export",
          "docstring": "Export to IBKR Flex Query format (#P21).\n\nGenerates XML compatible with IBKR's reporting tools.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_export",
              "signature": "def __init__(self, account_id: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 105
            },
            {
              "name": "export_positions",
              "module": "portfolio_export",
              "signature": "def export_positions(self, positions: list[PortfolioPosition], as_of_date: ) -> str",
              "docstring": "Export positions to IBKR Flex XML format.\n\nArgs:\n    positions: List of positions\n    as_of_date: Report date\n\nReturns:\n    XML string",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "list[PortfolioPosition]"
                },
                {
                  "name": "as_of_date",
                  "type": ""
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 108
            },
            {
              "name": "export_account_info",
              "module": "portfolio_export",
              "signature": "def export_account_info(self, summary: PortfolioSummary) -> str",
              "docstring": "Export account information to IBKR format.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "summary",
                  "type": "PortfolioSummary"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 172
            },
            {
              "name": "_map_asset_class",
              "module": "portfolio_export",
              "signature": "def _map_asset_class(self, asset_class: str) -> str",
              "docstring": "Map asset class to IBKR category.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "asset_class",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 201
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 98
        },
        {
          "name": "CSVPortfolioExporter",
          "module": "portfolio_export",
          "docstring": "Export portfolio to CSV formats (#P21).\n\nSupports multiple templates for different use cases.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_export",
              "signature": "def __init__(self, delimiter: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "delimiter",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 222
            },
            {
              "name": "export_positions",
              "module": "portfolio_export",
              "signature": "def export_positions(self, positions: list[PortfolioPosition], template: str) -> str",
              "docstring": "Export positions to CSV.\n\nTemplates:\n- standard: Basic position info\n- detailed: Full position data\n- pnl: P&L focused\n- reconciliation: For broker reconciliation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "list[PortfolioPosition]"
                },
                {
                  "name": "template",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 225
            },
            {
              "name": "export_summary",
              "module": "portfolio_export",
              "signature": "def export_summary(self, summary: PortfolioSummary) -> str",
              "docstring": "Export portfolio summary to CSV.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "summary",
                  "type": "PortfolioSummary"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 327
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 215
        },
        {
          "name": "FIXPortfolioExporter",
          "module": "portfolio_export",
          "docstring": "Export portfolio in FIX protocol format (#P21).\n\nGenerates FIX-style messages for position reporting.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_export",
              "signature": "def __init__(self, sender_comp_id: str, target_comp_id: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "sender_comp_id",
                  "type": "str"
                },
                {
                  "name": "target_comp_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 357
            },
            {
              "name": "export_position_report",
              "module": "portfolio_export",
              "signature": "def export_position_report(self, position: PortfolioPosition) -> str",
              "docstring": "Generate FIX Position Report (AP) message.\n\nArgs:\n    position: Position to export\n\nReturns:\n    FIX message string",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position",
                  "type": "PortfolioPosition"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 362
            },
            {
              "name": "_map_product",
              "module": "portfolio_export",
              "signature": "def _map_product(self, asset_class: str) -> str",
              "docstring": "Map asset class to FIX product code.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "asset_class",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 416
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 350
        },
        {
          "name": "CachedPortfolioMetrics",
          "module": "portfolio_export",
          "docstring": "Cached portfolio metrics.",
          "bases": [],
          "methods": [
            {
              "name": "age_seconds",
              "module": "portfolio_export",
              "signature": "def age_seconds(self) -> float",
              "docstring": "Age of cache in seconds.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 449
            }
          ],
          "class_attributes": [
            {
              "name": "nav",
              "type": "float"
            },
            {
              "name": "total_pnl",
              "type": "float"
            },
            {
              "name": "total_pnl_pct",
              "type": "float"
            },
            {
              "name": "gross_exposure",
              "type": "float"
            },
            {
              "name": "net_exposure",
              "type": "float"
            },
            {
              "name": "long_exposure",
              "type": "float"
            },
            {
              "name": "short_exposure",
              "type": "float"
            },
            {
              "name": "cash",
              "type": "float"
            },
            {
              "name": "leverage",
              "type": "float"
            },
            {
              "name": "position_count",
              "type": "int"
            },
            {
              "name": "sector_weights",
              "type": "dict[str, float]"
            },
            {
              "name": "computed_at",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 433
        },
        {
          "name": "PortfolioMetricsCache",
          "module": "portfolio_export",
          "docstring": "Intelligent caching for portfolio metrics (#P20).\n\nFeatures:\n- Position-change aware invalidation\n- Tiered TTL based on metric volatility\n- Memory-efficient storage\n- Thread-safe access",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_export",
              "signature": "def __init__(self, default_ttl: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "default_ttl",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 474
            },
            {
              "name": "get",
              "module": "portfolio_export",
              "signature": "def get(self, key: str)",
              "docstring": "Get cached value if valid.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 485
            },
            {
              "name": "set",
              "module": "portfolio_export",
              "signature": "def set(self, key: str, value: Any, ttl: , metric_type: ) -> None",
              "docstring": "Store value in cache.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "Any"
                },
                {
                  "name": "ttl",
                  "type": ""
                },
                {
                  "name": "metric_type",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 503
            },
            {
              "name": "invalidate",
              "module": "portfolio_export",
              "signature": "def invalidate(self, key: str) -> bool",
              "docstring": "Invalidate specific key.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 520
            },
            {
              "name": "invalidate_pattern",
              "module": "portfolio_export",
              "signature": "def invalidate_pattern(self, pattern: str) -> int",
              "docstring": "Invalidate keys matching pattern prefix.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pattern",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 528
            },
            {
              "name": "on_position_change",
              "module": "portfolio_export",
              "signature": "def on_position_change(self) -> None",
              "docstring": "Handle position change - invalidate relevant caches.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 536
            },
            {
              "name": "on_price_update",
              "module": "portfolio_export",
              "signature": "def on_price_update(self, symbols: list[str]) -> None",
              "docstring": "Handle price update - selective invalidation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 547
            },
            {
              "name": "get_or_compute",
              "module": "portfolio_export",
              "signature": "def get_or_compute(self, key: str, compute_fn: Callable[, Any], ttl: , metric_type: ) -> Any",
              "docstring": "Get from cache or compute with double-check pattern.\n\nUses double-check locking to prevent deadlock while avoiding\nduplicate computation by multiple threads.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "compute_fn",
                  "type": "Callable[, Any]"
                },
                {
                  "name": "ttl",
                  "type": ""
                },
                {
                  "name": "metric_type",
                  "type": ""
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 558
            },
            {
              "name": "get_stats",
              "module": "portfolio_export",
              "signature": "def get_stats(self) -> dict",
              "docstring": "Get cache statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 599
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 454
        },
        {
          "name": "PortfolioExporter",
          "module": "portfolio_export",
          "docstring": "High-level portfolio export manager.\n\nSupports multiple formats with caching.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_export",
              "signature": "def __init__(self, account_id: str, output_dir: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_id",
                  "type": "str"
                },
                {
                  "name": "output_dir",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 619
            },
            {
              "name": "export",
              "module": "portfolio_export",
              "signature": "def export(self, positions: list[PortfolioPosition], format: ExportFormat, filename: , template: str) -> str",
              "docstring": "Export portfolio to file.\n\nReturns:\n    Path to exported file",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "list[PortfolioPosition]"
                },
                {
                  "name": "format",
                  "type": "ExportFormat"
                },
                {
                  "name": "filename",
                  "type": ""
                },
                {
                  "name": "template",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 636
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 612
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "csv",
        "json",
        "logging",
        "time",
        "threading",
        "dataclasses",
        "datetime",
        "enum",
        "io",
        "pathlib",
        "typing",
        "collections",
        "xml.etree.ElementTree"
      ],
      "dependencies": [
        "__future__",
        "csv",
        "time",
        "threading",
        "io",
        "xml.etree.ElementTree"
      ]
    },
    "core.portfolio_snapshots": {
      "name": "portfolio_snapshots",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\portfolio_snapshots.py",
      "docstring": "Historical Portfolio Snapshots Module\n=====================================\n\nStore and retrieve historical portfolio snapshots (Issue #P17).\n\nFeatures:\n- Periodic portfolio state capture\n- Position history tracking\n- P&L history with attribution\n- Snapshot comparison tools\n- Export to various formats",
      "classes": [
        {
          "name": "SnapshotType",
          "module": "portfolio_snapshots",
          "docstring": "Type of portfolio snapshot.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 29
        },
        {
          "name": "PositionSnapshot",
          "module": "portfolio_snapshots",
          "docstring": "Snapshot of a single position.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "avg_cost",
              "type": "float"
            },
            {
              "name": "market_price",
              "type": "float"
            },
            {
              "name": "market_value",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "realized_pnl",
              "type": "float"
            },
            {
              "name": "weight_pct",
              "type": "float"
            },
            {
              "name": "sector",
              "type": "str"
            },
            {
              "name": "asset_class",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 40
        },
        {
          "name": "PortfolioSnapshot",
          "module": "portfolio_snapshots",
          "docstring": "Complete portfolio snapshot at a point in time.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "portfolio_snapshots",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 93
            },
            {
              "name": "from_dict",
              "module": "portfolio_snapshots",
              "signature": "def from_dict(cls, data: dict) -> PortfolioSnapshot",
              "docstring": "Create from dictionary.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "data",
                  "type": "dict"
                }
              ],
              "return_type": "PortfolioSnapshot",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 101
            },
            {
              "name": "get_position",
              "module": "portfolio_snapshots",
              "signature": "def get_position(self, symbol: str)",
              "docstring": "Get position by symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 108
            },
            {
              "name": "get_sector_exposure",
              "module": "portfolio_snapshots",
              "signature": "def get_sector_exposure(self) -> dict[str, float]",
              "docstring": "Get exposure by sector.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 115
            }
          ],
          "class_attributes": [
            {
              "name": "snapshot_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "snapshot_type",
              "type": "SnapshotType"
            },
            {
              "name": "net_liquidation",
              "type": "float"
            },
            {
              "name": "gross_exposure",
              "type": "float"
            },
            {
              "name": "net_exposure",
              "type": "float"
            },
            {
              "name": "cash",
              "type": "float"
            },
            {
              "name": "daily_pnl",
              "type": "float"
            },
            {
              "name": "mtd_pnl",
              "type": "float"
            },
            {
              "name": "ytd_pnl",
              "type": "float"
            },
            {
              "name": "inception_pnl",
              "type": "float"
            },
            {
              "name": "var_95",
              "type": "float"
            },
            {
              "name": "var_99",
              "type": "float"
            },
            {
              "name": "expected_shortfall",
              "type": "float"
            },
            {
              "name": "current_drawdown",
              "type": "float"
            },
            {
              "name": "max_drawdown",
              "type": "float"
            },
            {
              "name": "portfolio_delta",
              "type": "float"
            },
            {
              "name": "portfolio_gamma",
              "type": "float"
            },
            {
              "name": "portfolio_vega",
              "type": "float"
            },
            {
              "name": "portfolio_theta",
              "type": "float"
            },
            {
              "name": "positions",
              "type": "list[PositionSnapshot]"
            },
            {
              "name": "trigger_reason",
              "type": "str"
            },
            {
              "name": "notes",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 55
        },
        {
          "name": "PortfolioSnapshotStore",
          "module": "portfolio_snapshots",
          "docstring": "Persistent storage for portfolio snapshots (#P17).\n\nUses SQLite for efficient querying and storage.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_snapshots",
              "signature": "def __init__(self, db_path: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "db_path",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 131
            },
            {
              "name": "_init_db",
              "module": "portfolio_snapshots",
              "signature": "def _init_db(self) -> None",
              "docstring": "Initialize database schema.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 136
            },
            {
              "name": "save_snapshot",
              "module": "portfolio_snapshots",
              "signature": "def save_snapshot(self, snapshot: PortfolioSnapshot) -> None",
              "docstring": "Save a portfolio snapshot.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "snapshot",
                  "type": "PortfolioSnapshot"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            },
            {
              "name": "get_snapshot",
              "module": "portfolio_snapshots",
              "signature": "def get_snapshot(self, snapshot_id: str)",
              "docstring": "Get a specific snapshot by ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "snapshot_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 266
            },
            {
              "name": "get_snapshots",
              "module": "portfolio_snapshots",
              "signature": "def get_snapshots(self, start_date: , end_date: , snapshot_type: , limit: int) -> list[PortfolioSnapshot]",
              "docstring": "Query snapshots with filters.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                },
                {
                  "name": "snapshot_type",
                  "type": ""
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[PortfolioSnapshot]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 287
            },
            {
              "name": "get_latest_snapshot",
              "module": "portfolio_snapshots",
              "signature": "def get_latest_snapshot(self, snapshot_type: )",
              "docstring": "Get the most recent snapshot.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "snapshot_type",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 328
            },
            {
              "name": "get_eod_snapshots",
              "module": "portfolio_snapshots",
              "signature": "def get_eod_snapshots(self, days: int) -> list[PortfolioSnapshot]",
              "docstring": "Get end-of-day snapshots for the last N days.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "list[PortfolioSnapshot]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 336
            },
            {
              "name": "_row_to_snapshot",
              "module": "portfolio_snapshots",
              "signature": "def _row_to_snapshot(self, row: sqlite3.Row, position_rows: list) -> PortfolioSnapshot",
              "docstring": "Convert database rows to PortfolioSnapshot.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "row",
                  "type": "sqlite3.Row"
                },
                {
                  "name": "position_rows",
                  "type": "list"
                }
              ],
              "return_type": "PortfolioSnapshot",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 348
            },
            {
              "name": "delete_old_snapshots",
              "module": "portfolio_snapshots",
              "signature": "def delete_old_snapshots(self, retention_days: int, keep_eod: bool) -> int",
              "docstring": "Delete old snapshots while respecting retention policy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "retention_days",
                  "type": "int"
                },
                {
                  "name": "keep_eod",
                  "type": "bool"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 392
            },
            {
              "name": "export_to_json",
              "module": "portfolio_snapshots",
              "signature": "def export_to_json(self, filepath: str, start_date: , end_date: ) -> int",
              "docstring": "Export snapshots to JSON file.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filepath",
                  "type": "str"
                },
                {
                  "name": "start_date",
                  "type": ""
                },
                {
                  "name": "end_date",
                  "type": ""
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 424
            },
            {
              "name": "get_statistics",
              "module": "portfolio_snapshots",
              "signature": "def get_statistics(self) -> dict",
              "docstring": "Get storage statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 441
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 124
        },
        {
          "name": "PortfolioSnapshotManager",
          "module": "portfolio_snapshots",
          "docstring": "High-level manager for portfolio snapshots (#P17).\n\nHandles automatic snapshot scheduling and comparison.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "portfolio_snapshots",
              "signature": "def __init__(self, store: , intraday_interval_minutes: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "store",
                  "type": ""
                },
                {
                  "name": "intraday_interval_minutes",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 479
            },
            {
              "name": "_generate_snapshot_id",
              "module": "portfolio_snapshots",
              "signature": "def _generate_snapshot_id(self, snapshot_type: SnapshotType) -> str",
              "docstring": "Generate unique snapshot ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "snapshot_type",
                  "type": "SnapshotType"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 489
            },
            {
              "name": "should_take_intraday_snapshot",
              "module": "portfolio_snapshots",
              "signature": "def should_take_intraday_snapshot(self) -> bool",
              "docstring": "Check if it's time for an intraday snapshot.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 495
            },
            {
              "name": "create_snapshot",
              "module": "portfolio_snapshots",
              "signature": "def create_snapshot(self, snapshot_type: SnapshotType, risk_state: Any, positions: dict[str, Any], trigger_reason: str, notes: str) -> PortfolioSnapshot",
              "docstring": "Create a new portfolio snapshot from current state.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "snapshot_type",
                  "type": "SnapshotType"
                },
                {
                  "name": "risk_state",
                  "type": "Any"
                },
                {
                  "name": "positions",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "trigger_reason",
                  "type": "str"
                },
                {
                  "name": "notes",
                  "type": "str"
                }
              ],
              "return_type": "PortfolioSnapshot",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 503
            },
            {
              "name": "compare_snapshots",
              "module": "portfolio_snapshots",
              "signature": "def compare_snapshots(self, snapshot1: PortfolioSnapshot, snapshot2: PortfolioSnapshot) -> dict",
              "docstring": "Compare two snapshots and return differences (#P18 partial).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "snapshot1",
                  "type": "PortfolioSnapshot"
                },
                {
                  "name": "snapshot2",
                  "type": "PortfolioSnapshot"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 577
            },
            {
              "name": "get_performance_history",
              "module": "portfolio_snapshots",
              "signature": "def get_performance_history(self, days: int) -> list[dict]",
              "docstring": "Get daily performance history.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 651
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 472
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "sqlite3",
        "dataclasses",
        "datetime",
        "pathlib",
        "typing",
        "enum"
      ],
      "dependencies": [
        "__future__",
        "sqlite3"
      ]
    },
    "core.position_netting": {
      "name": "position_netting",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\position_netting.py",
      "docstring": "Position Netting\n================\n\nAggregates and nets positions across multiple strategies to provide\na consolidated view of portfolio exposure.\n\nRequired for:\n- Accurate risk calculation\n- Margin optimization\n- Cross-strategy position limits\n- Portfolio-level exposure reporting",
      "classes": [
        {
          "name": "PositionSide",
          "module": "position_netting",
          "docstring": "Position direction.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 29
        },
        {
          "name": "StrategyPosition",
          "module": "position_netting",
          "docstring": "Position held by a specific strategy.",
          "bases": [],
          "methods": [
            {
              "name": "side",
              "module": "position_netting",
              "signature": "def side(self) -> PositionSide",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "PositionSide",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 48
            }
          ],
          "class_attributes": [
            {
              "name": "strategy",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "avg_price",
              "type": "float"
            },
            {
              "name": "market_value",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 37
        },
        {
          "name": "NetPosition",
          "module": "position_netting",
          "docstring": "Net position aggregated across all strategies.\n\nProvides consolidated view of exposure regardless of which\nstrategy originated the position.",
          "bases": [],
          "methods": [
            {
              "name": "side",
              "module": "position_netting",
              "signature": "def side(self) -> PositionSide",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "PositionSide",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 74
            },
            {
              "name": "gross_quantity",
              "module": "position_netting",
              "signature": "def gross_quantity(self) -> int",
              "docstring": "Total absolute quantity across strategies (ignores netting).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 82
            },
            {
              "name": "netting_benefit",
              "module": "position_netting",
              "signature": "def netting_benefit(self) -> int",
              "docstring": "Quantity reduced through netting (gross - net).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "to_dict",
              "module": "position_netting",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 91
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "net_quantity",
              "type": "int"
            },
            {
              "name": "avg_entry_price",
              "type": "float"
            },
            {
              "name": "market_value",
              "type": "float"
            },
            {
              "name": "unrealized_pnl",
              "type": "float"
            },
            {
              "name": "contributing_strategies",
              "type": "list[str]"
            },
            {
              "name": "strategy_breakdown",
              "type": "dict[str, int]"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 57
        },
        {
          "name": "PositionNetter",
          "module": "position_netting",
          "docstring": "Aggregates positions across strategies and provides net exposure.\n\nFeatures:\n- Net position calculation\n- Gross vs net exposure\n- Strategy attribution\n- P&L attribution\n- Position limit checking on net basis",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "position_netting",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize position netter.\n\nArgs:\n    config: Configuration with:\n        - use_fifo: Use FIFO for P&L (default: True)\n        - track_history: Track position history (default: True)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 118
            },
            {
              "name": "update_position",
              "module": "position_netting",
              "signature": "def update_position(self, strategy: str, symbol: str, quantity: int, avg_price: float) -> None",
              "docstring": "Update position for a strategy.\n\nArgs:\n    strategy: Strategy name\n    symbol: Instrument symbol\n    quantity: Position quantity (positive=long, negative=short, 0=flat)\n    avg_price: Average entry price",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "avg_price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 145
            },
            {
              "name": "update_market_price",
              "module": "position_netting",
              "signature": "def update_market_price(self, symbol: str, price: float) -> None",
              "docstring": "Update market price for P&L calculation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            },
            {
              "name": "_recalculate_pnl",
              "module": "position_netting",
              "signature": "def _recalculate_pnl(self, symbol: str) -> None",
              "docstring": "Recalculate unrealized P&L for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 207
            },
            {
              "name": "get_net_position",
              "module": "position_netting",
              "signature": "def get_net_position(self, symbol: str)",
              "docstring": "Get net position for a symbol across all strategies.\n\nArgs:\n    symbol: Instrument symbol\n\nReturns:\n    NetPosition or None if no positions",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 223
            },
            {
              "name": "get_all_net_positions",
              "module": "position_netting",
              "signature": "def get_all_net_positions(self) -> dict[str, NetPosition]",
              "docstring": "Get net positions for all symbols.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, NetPosition]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 271
            },
            {
              "name": "get_strategy_positions",
              "module": "position_netting",
              "signature": "def get_strategy_positions(self, strategy: str) -> dict[str, StrategyPosition]",
              "docstring": "Get all positions for a specific strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "dict[str, StrategyPosition]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 280
            },
            {
              "name": "get_gross_exposure",
              "module": "position_netting",
              "signature": "def get_gross_exposure(self) -> float",
              "docstring": "Get total gross exposure (sum of absolute position values).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 288
            },
            {
              "name": "get_net_exposure",
              "module": "position_netting",
              "signature": "def get_net_exposure(self) -> float",
              "docstring": "Get total net exposure (net long - net short).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 296
            },
            {
              "name": "get_long_exposure",
              "module": "position_netting",
              "signature": "def get_long_exposure(self) -> float",
              "docstring": "Get total long exposure.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 309
            },
            {
              "name": "get_short_exposure",
              "module": "position_netting",
              "signature": "def get_short_exposure(self) -> float",
              "docstring": "Get total short exposure (as positive number).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 318
            },
            {
              "name": "get_total_unrealized_pnl",
              "module": "position_netting",
              "signature": "def get_total_unrealized_pnl(self) -> float",
              "docstring": "Get total unrealized P&L across all positions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 327
            },
            {
              "name": "check_position_limit",
              "module": "position_netting",
              "signature": "def check_position_limit(self, symbol: str, new_quantity: int, strategy: str, max_net_position: int) -> tuple[bool, str]",
              "docstring": "Check if adding a position would exceed limits on net basis.\n\nArgs:\n    symbol: Instrument symbol\n    new_quantity: Proposed new quantity for this strategy\n    strategy: Strategy name\n    max_net_position: Maximum allowed net position\n\nReturns:\n    Tuple of (allowed, reason)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "new_quantity",
                  "type": "int"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "max_net_position",
                  "type": "int"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 335
            },
            {
              "name": "get_netting_summary",
              "module": "position_netting",
              "signature": "def get_netting_summary(self) -> dict[str, Any]",
              "docstring": "Get summary of netting benefits.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 372
            },
            {
              "name": "get_status",
              "module": "position_netting",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get netter status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 399
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 106
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.contract_specs"
      ],
      "dependencies": [
        "__future__",
        "core.contract_specs"
      ]
    },
    "core.position_sizing": {
      "name": "position_sizing",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\position_sizing.py",
      "docstring": "Position Sizing Module\n======================\n\nAdvanced position sizing using Kelly Criterion and related methods.\nProvides optimal position sizing with risk management constraints.",
      "classes": [
        {
          "name": "SizingMethod",
          "module": "position_sizing",
          "docstring": "Position sizing methodology.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 23
        },
        {
          "name": "PositionSizeResult",
          "module": "position_sizing",
          "docstring": "Result of position sizing calculation.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "position_sizing",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 50
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "method",
              "type": "SizingMethod"
            },
            {
              "name": "raw_fraction",
              "type": "float"
            },
            {
              "name": "adjusted_fraction",
              "type": "float"
            },
            {
              "name": "position_size_pct",
              "type": "float"
            },
            {
              "name": "position_value",
              "type": "float"
            },
            {
              "name": "contracts",
              "type": ""
            },
            {
              "name": "rationale",
              "type": "str"
            },
            {
              "name": "adjustments",
              "type": "list[str]"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 37
        },
        {
          "name": "StrategyStats",
          "module": "position_sizing",
          "docstring": "Statistics for a trading strategy (used in Kelly calculation).\n\nIMPORTANT: avg_win and avg_loss must be RETURNS (percentages as decimals),\nNOT dollar P&L values. For example:\n- avg_win = 0.02 means 2% average winning trade\n- avg_loss = 0.01 means 1% average losing trade\n\nIf you have dollar P&L, divide by position size to get returns.",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "position_sizing",
              "signature": "def __post_init__(self)",
              "docstring": "Validate inputs are in expected ranges.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 85
            },
            {
              "name": "edge",
              "module": "position_sizing",
              "signature": "def edge(self) -> float",
              "docstring": "Calculate edge (expected return per trade).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 106
            },
            {
              "name": "kelly_fraction",
              "module": "position_sizing",
              "signature": "def kelly_fraction(self) -> float",
              "docstring": "Calculate full Kelly fraction.\n\nKelly formula: f* = (bp - q) / b\nwhere:\n    b = avg_win / avg_loss (win/loss ratio)\n    p = win_rate\n    q = 1 - p (loss rate)\n\nReturns the optimal fraction of capital to risk.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 111
            },
            {
              "name": "from_dollar_pnl",
              "module": "position_sizing",
              "signature": "def from_dollar_pnl(cls, wins: list[float], losses: list[float], position_sizes: list[float], volatility: float) -> StrategyStats",
              "docstring": "Create StrategyStats from dollar P&L values.\n\nConverts dollar P&L to returns for proper Kelly calculation.\n\nArgs:\n    wins: List of winning trade P&L in dollars\n    losses: List of losing trade P&L in dollars (positive numbers)\n    position_sizes: List of position sizes for each trade\n    volatility: Strategy volatility (default 15%)\n\nReturns:\n    StrategyStats with properly calculated returns",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "wins",
                  "type": "list[float]"
                },
                {
                  "name": "losses",
                  "type": "list[float]"
                },
                {
                  "name": "position_sizes",
                  "type": "list[float]"
                },
                {
                  "name": "volatility",
                  "type": "float"
                }
              ],
              "return_type": "StrategyStats",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 135
            }
          ],
          "class_attributes": [
            {
              "name": "win_rate",
              "type": "float"
            },
            {
              "name": "avg_win",
              "type": "float"
            },
            {
              "name": "avg_loss",
              "type": "float"
            },
            {
              "name": "volatility",
              "type": "float"
            },
            {
              "name": "sharpe_ratio",
              "type": "float"
            },
            {
              "name": "n_trades",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 67
        },
        {
          "name": "PositionSizer",
          "module": "position_sizing",
          "docstring": "Advanced position sizing calculator.\n\nFeatures:\n- Kelly Criterion with variants\n- Volatility targeting\n- Correlation-adjusted sizing\n- Risk limit constraints",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "position_sizing",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize position sizer.\n\nArgs:\n    config: Configuration with:\n        - method: Default sizing method (default: \"kelly\")\n        - use_half_kelly: Use half Kelly (default: True)\n        - max_position_pct: Maximum position size (default: 10%)\n        - min_position_pct: Minimum position size (default: 1%)\n        - vol_target: Target volatility (default: 15%)\n        - correlation_discount: Discount for correlated positions (default: True)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 197
            },
            {
              "name": "update_strategy_stats",
              "module": "position_sizing",
              "signature": "def update_strategy_stats(self, strategy: str, stats: StrategyStats) -> None",
              "docstring": "Update statistics for a strategy.\n\nArgs:\n    strategy: Strategy name\n    stats: Strategy statistics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "stats",
                  "type": "StrategyStats"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 229
            },
            {
              "name": "update_correlations",
              "module": "position_sizing",
              "signature": "def update_correlations(self, correlations: dict[tuple[str, str], float]) -> None",
              "docstring": "Update correlation data.\n\nArgs:\n    correlations: Dictionary of (symbol1, symbol2) -> correlation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "correlations",
                  "type": "dict[tuple[str, str], float]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 240
            },
            {
              "name": "calculate_kelly_size",
              "module": "position_sizing",
              "signature": "def calculate_kelly_size(self, strategy: str, portfolio_value: float, kelly_variant: SizingMethod) -> PositionSizeResult",
              "docstring": "Calculate position size using Kelly Criterion.\n\nArgs:\n    strategy: Strategy name\n    portfolio_value: Total portfolio value\n    kelly_variant: Kelly variant to use\n\nReturns:\n    PositionSizeResult with calculated size",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "kelly_variant",
                  "type": "SizingMethod"
                }
              ],
              "return_type": "PositionSizeResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 249
            },
            {
              "name": "calculate_vol_target_size",
              "module": "position_sizing",
              "signature": "def calculate_vol_target_size(self, symbol: str, portfolio_value: float, asset_volatility: float, target_vol: ) -> PositionSizeResult",
              "docstring": "Calculate position size using volatility targeting.\n\nPosition size = (target_vol / asset_vol) * portfolio_value\n\nArgs:\n    symbol: Asset symbol\n    portfolio_value: Total portfolio value\n    asset_volatility: Asset's annualized volatility\n    target_vol: Target portfolio volatility (default: config value)\n\nReturns:\n    PositionSizeResult with calculated size",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "asset_volatility",
                  "type": "float"
                },
                {
                  "name": "target_vol",
                  "type": ""
                }
              ],
              "return_type": "PositionSizeResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 319
            },
            {
              "name": "calculate_correlation_adjusted_size",
              "module": "position_sizing",
              "signature": "def calculate_correlation_adjusted_size(self, symbol: str, base_size_pct: float, existing_positions: dict[str, float], portfolio_value: float) -> PositionSizeResult",
              "docstring": "Adjust position size based on correlation with existing positions.\n\nReduces size if highly correlated with existing holdings.\n\nArgs:\n    symbol: Symbol to size\n    base_size_pct: Base position size before adjustment\n    existing_positions: Current positions (symbol -> value)\n    portfolio_value: Total portfolio value\n\nReturns:\n    PositionSizeResult with correlation-adjusted size",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "base_size_pct",
                  "type": "float"
                },
                {
                  "name": "existing_positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "PositionSizeResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 383
            },
            {
              "name": "calculate_optimal_size",
              "module": "position_sizing",
              "signature": "def calculate_optimal_size(self, symbol: str, strategy: str, portfolio_value: float, asset_volatility: , existing_positions: , method: ) -> PositionSizeResult",
              "docstring": "Calculate optimal position size using configured method.\n\nThis is the main entry point that combines all sizing logic.\n\nArgs:\n    symbol: Asset symbol\n    strategy: Strategy name\n    portfolio_value: Total portfolio value\n    asset_volatility: Asset volatility (for vol targeting)\n    existing_positions: Current positions (for correlation adjustment)\n    method: Override default method\n\nReturns:\n    PositionSizeResult with optimal size",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "asset_volatility",
                  "type": ""
                },
                {
                  "name": "existing_positions",
                  "type": ""
                },
                {
                  "name": "method",
                  "type": ""
                }
              ],
              "return_type": "PositionSizeResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 463
            },
            {
              "name": "calculate_contracts",
              "module": "position_sizing",
              "signature": "def calculate_contracts(self, position_value: float, price: float, multiplier: float) -> int",
              "docstring": "Calculate number of contracts for a given position value.\n\nArgs:\n    position_value: Target position value\n    price: Current price\n    multiplier: Contract multiplier\n\nReturns:\n    Number of contracts (rounded down)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position_value",
                  "type": "float"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "multiplier",
                  "type": "float"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 543
            },
            {
              "name": "get_strategy_stats",
              "module": "position_sizing",
              "signature": "def get_strategy_stats(self, strategy: str)",
              "docstring": "Get stored statistics for a strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 568
            },
            {
              "name": "get_all_stats",
              "module": "position_sizing",
              "signature": "def get_all_stats(self) -> dict[str, StrategyStats]",
              "docstring": "Get all strategy statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, StrategyStats]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 572
            },
            {
              "name": "get_optimal_portfolio_weights",
              "module": "position_sizing",
              "signature": "def get_optimal_portfolio_weights(self, strategies: list[str], portfolio_value: float) -> dict[str, float]",
              "docstring": "Calculate optimal weights for multiple strategies.\n\nUses normalized Kelly fractions.\n\nArgs:\n    strategies: List of strategy names\n    portfolio_value: Total portfolio value\n\nReturns:\n    Dictionary of strategy to weight (0-1)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategies",
                  "type": "list[str]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 576
            },
            {
              "name": "get_status",
              "module": "position_sizing",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get sizer status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 612
            },
            {
              "name": "optimize_portfolio_mean_variance",
              "module": "position_sizing",
              "signature": "def optimize_portfolio_mean_variance(self, symbols: list[str], expected_returns: dict[str, float], covariance_matrix: np.ndarray, portfolio_value: float, target_return: , risk_free_rate: float) -> dict[str, PositionSizeResult]",
              "docstring": "Mean-variance portfolio optimization (Markowitz) (#P5).\n\nFinds the optimal portfolio weights that maximize the Sharpe ratio\n(or minimize variance for a target return).\n\nUses quadratic programming to solve:\n- Max: (w'\u03bc - rf) / sqrt(w'\u03a3w)  [max Sharpe]\n- Or: Min: w'\u03a3w  s.t. w'\u03bc = target  [min var for target return]\n\nArgs:\n    symbols: List of asset symbols\n    expected_returns: Expected returns by symbol (annual)\n    covariance_matrix: Covariance matrix (NxN numpy array)\n    portfolio_value: Total portfolio value\n    target_return: Target portfolio return (None = max Sharpe)\n    risk_free_rate: Risk-free rate for Sharpe calculation\n\nReturns:\n    Dictionary of symbol to PositionSizeResult with optimal weights",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                },
                {
                  "name": "expected_returns",
                  "type": "dict[str, float]"
                },
                {
                  "name": "covariance_matrix",
                  "type": "np.ndarray"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "target_return",
                  "type": ""
                },
                {
                  "name": "risk_free_rate",
                  "type": "float"
                }
              ],
              "return_type": "dict[str, PositionSizeResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 630
            },
            {
              "name": "_solve_max_sharpe",
              "module": "position_sizing",
              "signature": "def _solve_max_sharpe(self, mu: np.ndarray, cov: np.ndarray, rf: float) -> np.ndarray",
              "docstring": "Solve for maximum Sharpe ratio portfolio.\n\nUses the analytical solution for the tangency portfolio:\nw = (\u03a3^-1)(\u03bc - rf) / 1'(\u03a3^-1)(\u03bc - rf)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "mu",
                  "type": "np.ndarray"
                },
                {
                  "name": "cov",
                  "type": "np.ndarray"
                },
                {
                  "name": "rf",
                  "type": "float"
                }
              ],
              "return_type": "np.ndarray",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 717
            },
            {
              "name": "_solve_min_variance",
              "module": "position_sizing",
              "signature": "def _solve_min_variance(self, mu: np.ndarray, cov: np.ndarray, target_return: float) -> np.ndarray",
              "docstring": "Solve for minimum variance portfolio with target return.\n\nUses Lagrange multipliers for constrained optimization.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "mu",
                  "type": "np.ndarray"
                },
                {
                  "name": "cov",
                  "type": "np.ndarray"
                },
                {
                  "name": "target_return",
                  "type": "float"
                }
              ],
              "return_type": "np.ndarray",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 753
            },
            {
              "name": "optimize_portfolio_risk_parity",
              "module": "position_sizing",
              "signature": "def optimize_portfolio_risk_parity(self, symbols: list[str], covariance_matrix: np.ndarray, portfolio_value: float, risk_budgets: ) -> dict[str, PositionSizeResult]",
              "docstring": "Risk parity portfolio optimization (#P5).\n\nAllocates positions so each contributes equally to portfolio risk.\nRisk contribution_i = w_i * (\u03a3w)_i / \u03c3_p\n\nIf risk_budgets provided, allocates according to those proportions\ninstead of equal risk.\n\nArgs:\n    symbols: List of asset symbols\n    covariance_matrix: Covariance matrix (NxN numpy array)\n    portfolio_value: Total portfolio value\n    risk_budgets: Optional risk budget allocation (sums to 1)\n\nReturns:\n    Dictionary of symbol to PositionSizeResult",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                },
                {
                  "name": "covariance_matrix",
                  "type": "np.ndarray"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "risk_budgets",
                  "type": ""
                }
              ],
              "return_type": "dict[str, PositionSizeResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 791
            },
            {
              "name": "_solve_risk_parity",
              "module": "position_sizing",
              "signature": "def _solve_risk_parity(self, cov: np.ndarray, budgets: np.ndarray, max_iter: int, tol: float) -> np.ndarray",
              "docstring": "Solve risk parity optimization using cyclical coordinate descent.\n\nThis is the Spinu (2013) algorithm for risk budgeting.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "cov",
                  "type": "np.ndarray"
                },
                {
                  "name": "budgets",
                  "type": "np.ndarray"
                },
                {
                  "name": "max_iter",
                  "type": "int"
                },
                {
                  "name": "tol",
                  "type": "float"
                }
              ],
              "return_type": "np.ndarray",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 862
            },
            {
              "name": "optimize_portfolio_min_variance",
              "module": "position_sizing",
              "signature": "def optimize_portfolio_min_variance(self, symbols: list[str], covariance_matrix: np.ndarray, portfolio_value: float) -> dict[str, PositionSizeResult]",
              "docstring": "Minimum variance portfolio optimization (#P5).\n\nFinds the portfolio with lowest possible variance (risk).\nUseful for defensive positioning.\n\nArgs:\n    symbols: List of asset symbols\n    covariance_matrix: Covariance matrix (NxN numpy array)\n    portfolio_value: Total portfolio value\n\nReturns:\n    Dictionary of symbol to PositionSizeResult",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                },
                {
                  "name": "covariance_matrix",
                  "type": "np.ndarray"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "dict[str, PositionSizeResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 904
            },
            {
              "name": "_apply_weight_constraints",
              "module": "position_sizing",
              "signature": "def _apply_weight_constraints(self, weights: np.ndarray) -> np.ndarray",
              "docstring": "Apply position size constraints to weights.\n\n- Ensures non-negative (long-only)\n- Ensures each position is within min/max limits\n- Normalizes to sum to 1 (or less if constraints bind)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "weights",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "np.ndarray",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 965
            },
            {
              "name": "get_efficient_frontier",
              "module": "position_sizing",
              "signature": "def get_efficient_frontier(self, symbols: list[str], expected_returns: dict[str, float], covariance_matrix: np.ndarray, n_points: int, risk_free_rate: float) -> list[dict]",
              "docstring": "Calculate the efficient frontier (#P5).\n\nReturns a series of optimal portfolios from minimum variance\nto maximum return.\n\nArgs:\n    symbols: List of asset symbols\n    expected_returns: Expected returns by symbol\n    covariance_matrix: Covariance matrix\n    n_points: Number of points on the frontier\n    risk_free_rate: Risk-free rate\n\nReturns:\n    List of dicts with return, risk, sharpe, weights for each point",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                },
                {
                  "name": "expected_returns",
                  "type": "dict[str, float]"
                },
                {
                  "name": "covariance_matrix",
                  "type": "np.ndarray"
                },
                {
                  "name": "n_points",
                  "type": "int"
                },
                {
                  "name": "risk_free_rate",
                  "type": "float"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 995
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 186
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy",
        "logging",
        "logging"
      ],
      "dependencies": [
        "__future__",
        "numpy"
      ]
    },
    "core.regime_detector": {
      "name": "regime_detector",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\regime_detector.py",
      "docstring": "Regime Detection Module\n=======================\n\nMarket regime detection for strategy switching (Issue #Q9).\n\nFeatures:\n- Volatility regime detection (low/normal/high/crisis)\n- Trend regime identification (trending/mean-reverting/ranging)\n- Correlation regime shifts\n- Hidden Markov Model-based regime estimation\n- VIX-based regime classification\n- Multi-factor regime scoring",
      "classes": [
        {
          "name": "VolatilityRegime",
          "module": "regime_detector",
          "docstring": "Volatility regime classification.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 30
        },
        {
          "name": "TrendRegime",
          "module": "regime_detector",
          "docstring": "Trend regime classification.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 38
        },
        {
          "name": "MarketRegime",
          "module": "regime_detector",
          "docstring": "Overall market regime.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 47
        },
        {
          "name": "CorrelationRegime",
          "module": "regime_detector",
          "docstring": "Correlation regime classification.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 55
        },
        {
          "name": "RegimeState",
          "module": "regime_detector",
          "docstring": "Current regime state.",
          "bases": [],
          "methods": [
            {
              "name": "is_favorable_for_momentum",
              "module": "regime_detector",
              "signature": "def is_favorable_for_momentum(self) -> bool",
              "docstring": "Check if regime favors momentum strategies.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 76
            },
            {
              "name": "is_favorable_for_mean_reversion",
              "module": "regime_detector",
              "signature": "def is_favorable_for_mean_reversion(self) -> bool",
              "docstring": "Check if regime favors mean reversion strategies.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 83
            },
            {
              "name": "is_risk_off",
              "module": "regime_detector",
              "signature": "def is_risk_off(self) -> bool",
              "docstring": "Check if market is in risk-off mode.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 90
            },
            {
              "name": "to_dict",
              "module": "regime_detector",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 94
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "volatility_regime",
              "type": "VolatilityRegime"
            },
            {
              "name": "trend_regime",
              "type": "TrendRegime"
            },
            {
              "name": "correlation_regime",
              "type": "CorrelationRegime"
            },
            {
              "name": "market_regime",
              "type": "MarketRegime"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "metrics",
              "type": "dict"
            },
            {
              "name": "regime_duration_days",
              "type": "int"
            },
            {
              "name": "previous_regime",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 64
        },
        {
          "name": "RegimeTransition",
          "module": "regime_detector",
          "docstring": "Record of regime transition.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "from_regime",
              "type": "MarketRegime"
            },
            {
              "name": "to_regime",
              "type": "MarketRegime"
            },
            {
              "name": "trigger",
              "type": "str"
            },
            {
              "name": "metrics_snapshot",
              "type": "dict"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 109
        },
        {
          "name": "RegimeDetector",
          "module": "regime_detector",
          "docstring": "Multi-factor regime detection engine.\n\nCombines volatility, trend, and correlation signals\nto identify the current market regime.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regime_detector",
              "signature": "def __init__(self, volatility_lookback: int, trend_lookback: int, correlation_lookback: int, regime_persistence: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "volatility_lookback",
                  "type": "int"
                },
                {
                  "name": "trend_lookback",
                  "type": "int"
                },
                {
                  "name": "correlation_lookback",
                  "type": "int"
                },
                {
                  "name": "regime_persistence",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 126
            },
            {
              "name": "update_price",
              "module": "regime_detector",
              "signature": "def update_price(self, symbol: str, price: float, timestamp: datetime) -> None",
              "docstring": "Update price history for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "timestamp",
                  "type": "datetime"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 166
            },
            {
              "name": "update_vix",
              "module": "regime_detector",
              "signature": "def update_vix(self, vix_value: float) -> None",
              "docstring": "Update VIX history.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "vix_value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 180
            },
            {
              "name": "detect_regime",
              "module": "regime_detector",
              "signature": "def detect_regime(self) -> RegimeState",
              "docstring": "Detect current market regime.\n\nReturns updated RegimeState.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "RegimeState",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 184
            },
            {
              "name": "_detect_volatility_regime",
              "module": "regime_detector",
              "signature": "def _detect_volatility_regime(self) -> tuple[VolatilityRegime, dict]",
              "docstring": "Detect volatility regime.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[VolatilityRegime, dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 221
            },
            {
              "name": "_detect_trend_regime",
              "module": "regime_detector",
              "signature": "def _detect_trend_regime(self) -> tuple[TrendRegime, dict]",
              "docstring": "Detect trend regime using ADX-like calculation.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[TrendRegime, dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 263
            },
            {
              "name": "_detect_correlation_regime",
              "module": "regime_detector",
              "signature": "def _detect_correlation_regime(self) -> tuple[CorrelationRegime, dict]",
              "docstring": "Detect correlation regime.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[CorrelationRegime, dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 331
            },
            {
              "name": "_correlation",
              "module": "regime_detector",
              "signature": "def _correlation(self, x: list[float], y: list[float])",
              "docstring": "Calculate Pearson correlation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "x",
                  "type": "list[float]"
                },
                {
                  "name": "y",
                  "type": "list[float]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 374
            },
            {
              "name": "_combine_regimes",
              "module": "regime_detector",
              "signature": "def _combine_regimes(self, vol_regime: VolatilityRegime, trend_regime: TrendRegime, corr_regime: CorrelationRegime) -> MarketRegime",
              "docstring": "Combine individual regimes into overall market regime.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "vol_regime",
                  "type": "VolatilityRegime"
                },
                {
                  "name": "trend_regime",
                  "type": "TrendRegime"
                },
                {
                  "name": "corr_regime",
                  "type": "CorrelationRegime"
                }
              ],
              "return_type": "MarketRegime",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 392
            },
            {
              "name": "_calculate_confidence",
              "module": "regime_detector",
              "signature": "def _calculate_confidence(self, vol_regime: VolatilityRegime, trend_regime: TrendRegime, corr_regime: CorrelationRegime) -> float",
              "docstring": "Calculate confidence in regime classification.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "vol_regime",
                  "type": "VolatilityRegime"
                },
                {
                  "name": "trend_regime",
                  "type": "TrendRegime"
                },
                {
                  "name": "corr_regime",
                  "type": "CorrelationRegime"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 429
            },
            {
              "name": "_apply_persistence_filter",
              "module": "regime_detector",
              "signature": "def _apply_persistence_filter(self, new_regime: RegimeState) -> RegimeState",
              "docstring": "Apply persistence filter to avoid regime flip-flopping.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "new_regime",
                  "type": "RegimeState"
                }
              ],
              "return_type": "RegimeState",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 465
            },
            {
              "name": "get_transitions",
              "module": "regime_detector",
              "signature": "def get_transitions(self, limit: int) -> list[RegimeTransition]",
              "docstring": "Get recent regime transitions.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[RegimeTransition]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 519
            },
            {
              "name": "get_strategy_weights",
              "module": "regime_detector",
              "signature": "def get_strategy_weights(self, strategies: list[str]) -> dict[str, float]",
              "docstring": "Get recommended strategy weights based on current regime.\n\nArgs:\n    strategies: List of strategy names\n\nReturns:\n    Dictionary of strategy -> weight (0-1)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategies",
                  "type": "list[str]"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 523
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 118
        },
        {
          "name": "HMMRegimeModel",
          "module": "regime_detector",
          "docstring": "Hidden Markov Model for regime detection.\n\nSimplified implementation without external dependencies.",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "regime_detector",
              "signature": "def __post_init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 604
            },
            {
              "name": "forward_algorithm",
              "module": "regime_detector",
              "signature": "def forward_algorithm(self, observations: list[float]) -> list[list[float]]",
              "docstring": "Run forward algorithm to get state probabilities.\n\nReturns matrix of state probabilities for each time step.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "observations",
                  "type": "list[float]"
                }
              ],
              "return_type": "list[list[float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 625
            },
            {
              "name": "_emission_prob",
              "module": "regime_detector",
              "signature": "def _emission_prob(self, observation: float, state: int) -> float",
              "docstring": "Calculate emission probability (Gaussian).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "observation",
                  "type": "float"
                },
                {
                  "name": "state",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 659
            },
            {
              "name": "predict_state",
              "module": "regime_detector",
              "signature": "def predict_state(self, observations: list[float]) -> int",
              "docstring": "Predict most likely current state.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "observations",
                  "type": "list[float]"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 670
            },
            {
              "name": "get_state_probabilities",
              "module": "regime_detector",
              "signature": "def get_state_probabilities(self, observations: list[float]) -> list[float]",
              "docstring": "Get current state probabilities.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "observations",
                  "type": "list[float]"
                }
              ],
              "return_type": "list[float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 680
            }
          ],
          "class_attributes": [
            {
              "name": "n_states",
              "type": "int"
            },
            {
              "name": "transition_matrix",
              "type": "list[list[float]]"
            },
            {
              "name": "emission_means",
              "type": "list[float]"
            },
            {
              "name": "emission_stds",
              "type": "list[float]"
            },
            {
              "name": "state_probs",
              "type": "list[float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 591
        },
        {
          "name": "RegimeAwareStrategyAllocator",
          "module": "regime_detector",
          "docstring": "Allocates capital to strategies based on regime.\n\nProvides a unified interface for regime-based allocation.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regime_detector",
              "signature": "def __init__(self, detector: RegimeDetector, strategy_configs: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "detector",
                  "type": "RegimeDetector"
                },
                {
                  "name": "strategy_configs",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 696
            },
            {
              "name": "get_allocation",
              "module": "regime_detector",
              "signature": "def get_allocation(self, strategies: dict[str, str], total_capital: float, base_weights: ) -> dict[str, float]",
              "docstring": "Get regime-adjusted capital allocation.\n\nArgs:\n    strategies: Map of strategy name to type\n    total_capital: Total capital to allocate\n    base_weights: Optional base weights (before regime adjustment)\n\nReturns:\n    Dictionary of strategy -> allocated capital",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategies",
                  "type": "dict[str, str]"
                },
                {
                  "name": "total_capital",
                  "type": "float"
                },
                {
                  "name": "base_weights",
                  "type": ""
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 726
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 689
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.regulatory_calendar": {
      "name": "regulatory_calendar",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\regulatory_calendar.py",
      "docstring": "Regulatory Calendar Module\n==========================\n\nRegulatory reporting calendar maintenance (Issue #C34).\nCompliance training records tracking (Issue #C40).\nGift and entertainment logging (Issue #C39).\n\nFeatures:\n- EU/AMF regulatory deadline tracking\n- Automated reminder generation\n- Compliance training management\n- Gift/entertainment log with thresholds",
      "classes": [
        {
          "name": "ReportType",
          "module": "regulatory_calendar",
          "docstring": "Types of regulatory reports.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 27
        },
        {
          "name": "ReportFrequency",
          "module": "regulatory_calendar",
          "docstring": "Report submission frequency.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 58
        },
        {
          "name": "TrainingStatus",
          "module": "regulatory_calendar",
          "docstring": "Training completion status.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 70
        },
        {
          "name": "RegulatoryDeadline",
          "module": "regulatory_calendar",
          "docstring": "Regulatory reporting deadline.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_calendar",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 104
            }
          ],
          "class_attributes": [
            {
              "name": "report_type",
              "type": "ReportType"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "frequency",
              "type": "ReportFrequency"
            },
            {
              "name": "deadline_rule",
              "type": "str"
            },
            {
              "name": "deadline_time",
              "type": "str"
            },
            {
              "name": "timezone",
              "type": "str"
            },
            {
              "name": "regulation",
              "type": "str"
            },
            {
              "name": "regulator",
              "type": "str"
            },
            {
              "name": "warning_days",
              "type": "int"
            },
            {
              "name": "critical_days",
              "type": "int"
            },
            {
              "name": "submission_portal",
              "type": "str"
            },
            {
              "name": "submission_format",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 80
        },
        {
          "name": "ScheduledReport",
          "module": "regulatory_calendar",
          "docstring": "Instance of a scheduled report.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_calendar",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 137
            }
          ],
          "class_attributes": [
            {
              "name": "report_id",
              "type": "str"
            },
            {
              "name": "report_type",
              "type": "ReportType"
            },
            {
              "name": "period_start",
              "type": "date"
            },
            {
              "name": "period_end",
              "type": "date"
            },
            {
              "name": "deadline",
              "type": "datetime"
            },
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "submitted_at",
              "type": ""
            },
            {
              "name": "confirmation_number",
              "type": "str"
            },
            {
              "name": "warning_sent",
              "type": "bool"
            },
            {
              "name": "critical_sent",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 120
        },
        {
          "name": "ComplianceTraining",
          "module": "regulatory_calendar",
          "docstring": "Compliance training record (#C40).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_calendar",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 166
            }
          ],
          "class_attributes": [
            {
              "name": "training_id",
              "type": "str"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "category",
              "type": "str"
            },
            {
              "name": "mandatory",
              "type": "bool"
            },
            {
              "name": "validity_months",
              "type": "int"
            },
            {
              "name": "target_audience",
              "type": "list[str]"
            },
            {
              "name": "regulation",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 151
        },
        {
          "name": "TrainingRecord",
          "module": "regulatory_calendar",
          "docstring": "Individual training completion record.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_calendar",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            }
          ],
          "class_attributes": [
            {
              "name": "record_id",
              "type": "str"
            },
            {
              "name": "training_id",
              "type": "str"
            },
            {
              "name": "employee_id",
              "type": "str"
            },
            {
              "name": "employee_name",
              "type": "str"
            },
            {
              "name": "assigned_date",
              "type": "date"
            },
            {
              "name": "due_date",
              "type": "date"
            },
            {
              "name": "completed_date",
              "type": ""
            },
            {
              "name": "score",
              "type": ""
            },
            {
              "name": "passed",
              "type": "bool"
            },
            {
              "name": "status",
              "type": "TrainingStatus"
            },
            {
              "name": "expires_date",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 180
        },
        {
          "name": "GiftEntertainmentEntry",
          "module": "regulatory_calendar",
          "docstring": "Gift and entertainment log entry (#C39).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_calendar",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 244
            }
          ],
          "class_attributes": [
            {
              "name": "entry_id",
              "type": "str"
            },
            {
              "name": "entry_type",
              "type": "str"
            },
            {
              "name": "employee_id",
              "type": "str"
            },
            {
              "name": "employee_name",
              "type": "str"
            },
            {
              "name": "counterparty_name",
              "type": "str"
            },
            {
              "name": "counterparty_company",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "value_eur",
              "type": "float"
            },
            {
              "name": "event_date",
              "type": "date"
            },
            {
              "name": "location",
              "type": "str"
            },
            {
              "name": "requires_approval",
              "type": "bool"
            },
            {
              "name": "approved",
              "type": "bool"
            },
            {
              "name": "approved_by",
              "type": "str"
            },
            {
              "name": "approval_date",
              "type": ""
            },
            {
              "name": "logged_at",
              "type": "datetime"
            },
            {
              "name": "notes",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 217
        },
        {
          "name": "RegulatoryCalendar",
          "module": "regulatory_calendar",
          "docstring": "Manages regulatory reporting deadlines (#C34).\n\nTracks all EU/AMF regulatory reporting requirements.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_calendar",
              "signature": "def __init__(self, notification_callback: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "notification_callback",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 361
            },
            {
              "name": "add_custom_deadline",
              "module": "regulatory_calendar",
              "signature": "def add_custom_deadline(self, deadline: RegulatoryDeadline) -> None",
              "docstring": "Add a custom regulatory deadline.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "deadline",
                  "type": "RegulatoryDeadline"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 379
            },
            {
              "name": "schedule_report",
              "module": "regulatory_calendar",
              "signature": "def schedule_report(self, report_type: ReportType, period_start: date, period_end: date, deadline: datetime) -> ScheduledReport",
              "docstring": "Schedule a specific report instance.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_type",
                  "type": "ReportType"
                },
                {
                  "name": "period_start",
                  "type": "date"
                },
                {
                  "name": "period_end",
                  "type": "date"
                },
                {
                  "name": "deadline",
                  "type": "datetime"
                }
              ],
              "return_type": "ScheduledReport",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 383
            },
            {
              "name": "generate_schedule",
              "module": "regulatory_calendar",
              "signature": "def generate_schedule(self, start_date: date, end_date: date) -> list[ScheduledReport]",
              "docstring": "Generate schedule for all reports in date range.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": "date"
                },
                {
                  "name": "end_date",
                  "type": "date"
                }
              ],
              "return_type": "list[ScheduledReport]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 405
            },
            {
              "name": "check_upcoming_deadlines",
              "module": "regulatory_calendar",
              "signature": "def check_upcoming_deadlines(self, days_ahead: int) -> list[dict]",
              "docstring": "Check for upcoming deadlines and generate alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days_ahead",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 496
            },
            {
              "name": "mark_submitted",
              "module": "regulatory_calendar",
              "signature": "def mark_submitted(self, report_id: str, confirmation_number: str) -> bool",
              "docstring": "Mark a report as submitted.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_id",
                  "type": "str"
                },
                {
                  "name": "confirmation_number",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 564
            },
            {
              "name": "get_calendar_view",
              "module": "regulatory_calendar",
              "signature": "def get_calendar_view(self, month: int, year: int) -> dict",
              "docstring": "Get calendar view of deadlines for a month.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "month",
                  "type": "int"
                },
                {
                  "name": "year",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 590
            },
            {
              "name": "get_compliance_status",
              "module": "regulatory_calendar",
              "signature": "def get_compliance_status(self) -> dict",
              "docstring": "Get overall compliance status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 619
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 262
        },
        {
          "name": "ComplianceTrainingManager",
          "module": "regulatory_calendar",
          "docstring": "Manages compliance training records (#C40).\n\nTracks mandatory training completion and expiry.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_calendar",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 691
            },
            {
              "name": "add_training",
              "module": "regulatory_calendar",
              "signature": "def add_training(self, training: ComplianceTraining) -> None",
              "docstring": "Add a training course.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "training",
                  "type": "ComplianceTraining"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 698
            },
            {
              "name": "assign_training",
              "module": "regulatory_calendar",
              "signature": "def assign_training(self, training_id: str, employee_id: str, employee_name: str, due_date: date)",
              "docstring": "Assign training to an employee.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "training_id",
                  "type": "str"
                },
                {
                  "name": "employee_id",
                  "type": "str"
                },
                {
                  "name": "employee_name",
                  "type": "str"
                },
                {
                  "name": "due_date",
                  "type": "date"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 702
            },
            {
              "name": "complete_training",
              "module": "regulatory_calendar",
              "signature": "def complete_training(self, record_id: str, score: , passed: bool) -> bool",
              "docstring": "Record training completion.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record_id",
                  "type": "str"
                },
                {
                  "name": "score",
                  "type": ""
                },
                {
                  "name": "passed",
                  "type": "bool"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 729
            },
            {
              "name": "check_overdue",
              "module": "regulatory_calendar",
              "signature": "def check_overdue(self) -> list[TrainingRecord]",
              "docstring": "Find overdue training assignments.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[TrainingRecord]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 757
            },
            {
              "name": "get_employee_status",
              "module": "regulatory_calendar",
              "signature": "def get_employee_status(self, employee_id: str) -> dict",
              "docstring": "Get training status for an employee.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "employee_id",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 774
            },
            {
              "name": "get_overall_compliance",
              "module": "regulatory_calendar",
              "signature": "def get_overall_compliance(self) -> dict",
              "docstring": "Get overall training compliance metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 798
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 636
        },
        {
          "name": "GiftEntertainmentLog",
          "module": "regulatory_calendar",
          "docstring": "Gift and entertainment logging (#C39).\n\nTracks gifts/entertainment with approval workflows.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_calendar",
              "signature": "def __init__(self, approval_threshold_eur: float, annual_limit_eur: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "approval_threshold_eur",
                  "type": "float"
                },
                {
                  "name": "annual_limit_eur",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 822
            },
            {
              "name": "log_entry",
              "module": "regulatory_calendar",
              "signature": "def log_entry(self, entry_type: str, employee_id: str, employee_name: str, counterparty_name: str, counterparty_company: str, description: str, value_eur: float, event_date: date, location: str) -> GiftEntertainmentEntry",
              "docstring": "Log a gift/entertainment entry.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "entry_type",
                  "type": "str"
                },
                {
                  "name": "employee_id",
                  "type": "str"
                },
                {
                  "name": "employee_name",
                  "type": "str"
                },
                {
                  "name": "counterparty_name",
                  "type": "str"
                },
                {
                  "name": "counterparty_company",
                  "type": "str"
                },
                {
                  "name": "description",
                  "type": "str"
                },
                {
                  "name": "value_eur",
                  "type": "float"
                },
                {
                  "name": "event_date",
                  "type": "date"
                },
                {
                  "name": "location",
                  "type": "str"
                }
              ],
              "return_type": "GiftEntertainmentEntry",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 833
            },
            {
              "name": "approve_entry",
              "module": "regulatory_calendar",
              "signature": "def approve_entry(self, entry_id: str, approved_by: str) -> bool",
              "docstring": "Approve a gift/entertainment entry.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "entry_id",
                  "type": "str"
                },
                {
                  "name": "approved_by",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 878
            },
            {
              "name": "get_employee_annual_total",
              "module": "regulatory_calendar",
              "signature": "def get_employee_annual_total(self, employee_id: str, year: int) -> float",
              "docstring": "Get total G&E value for employee in a year.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "employee_id",
                  "type": "str"
                },
                {
                  "name": "year",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 895
            },
            {
              "name": "get_pending_approvals",
              "module": "regulatory_calendar",
              "signature": "def get_pending_approvals(self) -> list[GiftEntertainmentEntry]",
              "docstring": "Get entries pending approval.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[GiftEntertainmentEntry]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 906
            },
            {
              "name": "get_summary",
              "module": "regulatory_calendar",
              "signature": "def get_summary(self, year: ) -> dict",
              "docstring": "Get G&E summary.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "year",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 913
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 815
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.regulatory_compliance": {
      "name": "regulatory_compliance",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\regulatory_compliance.py",
      "docstring": "Regulatory Compliance Module\n============================\n\nImplements EU/MiFID II/MAR compliance requirements.\n\nIssues addressed:\n- #C5: RTS 25 Order record keeping\n- #C6: RTS 6 Algo trading kill switch\n- #C7: MAR Art 16 Market abuse thresholds\n- #C8: RTS 27 Best execution reporting\n- #C9: RTS 28 Venue analysis\n- #C10: EMIR Trade repository\n- #C11: SFTR Securities financing\n- #C12: MiFIR Art 26 Transaction reference\n- #C13: RTS 24 Order ID format\n- #C14-C17: Market abuse detection tuning\n- #C18: RTS 6 Pre-trade risk controls\n- #C19: Per-venue position limits\n- #C20: Short selling locate\n- #C21: Dark pool reporting\n- #C22: Systematic internaliser\n- #C23: TCA format\n- #C24: Order execution policy\n- #C25: Client categorization\n- #C26: Cross-border reporting\n- #C27: Clock synchronization\n- #C28: Audit log rotation\n- #C29: GDPR data handling\n- #C30: Access control logs\n- #C31: Change management\n- #C32: Disaster recovery",
      "classes": [
        {
          "name": "RTS25OrderRecord",
          "module": "regulatory_compliance",
          "docstring": "Complete order record per MiFID II RTS 25 (#C5).\n\nContains all 65 required fields for order record keeping.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_compliance",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary for storage/transmission.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 119
            },
            {
              "name": "validate_required_fields",
              "module": "regulatory_compliance",
              "signature": "def validate_required_fields(cls, record: dict) -> list[str]",
              "docstring": "Validate all required RTS 25 fields are present.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "record",
                  "type": "dict"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 172
            }
          ],
          "class_attributes": [
            {
              "name": "order_id",
              "type": "str"
            },
            {
              "name": "client_order_id",
              "type": "str"
            },
            {
              "name": "trading_venue_order_id",
              "type": ""
            },
            {
              "name": "order_submission_timestamp",
              "type": "datetime"
            },
            {
              "name": "sequence_number",
              "type": "int"
            },
            {
              "name": "segment_mic",
              "type": "str"
            },
            {
              "name": "trading_capacity",
              "type": "str"
            },
            {
              "name": "client_id",
              "type": "str"
            },
            {
              "name": "client_lei",
              "type": ""
            },
            {
              "name": "decision_maker_id",
              "type": ""
            },
            {
              "name": "execution_within_firm",
              "type": "str"
            },
            {
              "name": "investment_decision_maker",
              "type": ""
            },
            {
              "name": "country_of_branch",
              "type": "str"
            },
            {
              "name": "instrument_id",
              "type": "str"
            },
            {
              "name": "instrument_full_name",
              "type": "str"
            },
            {
              "name": "instrument_classification",
              "type": "str"
            },
            {
              "name": "notional_currency",
              "type": "str"
            },
            {
              "name": "price_currency",
              "type": "str"
            },
            {
              "name": "underlying_isin",
              "type": ""
            },
            {
              "name": "order_side",
              "type": "str"
            },
            {
              "name": "order_type",
              "type": "str"
            },
            {
              "name": "limit_price",
              "type": ""
            },
            {
              "name": "stop_price",
              "type": ""
            },
            {
              "name": "quantity",
              "type": "float"
            },
            {
              "name": "quantity_currency",
              "type": "str"
            },
            {
              "name": "initial_quantity",
              "type": "float"
            },
            {
              "name": "remaining_quantity",
              "type": "float"
            },
            {
              "name": "executed_quantity",
              "type": "float"
            },
            {
              "name": "time_in_force",
              "type": "str"
            },
            {
              "name": "order_restriction",
              "type": ""
            },
            {
              "name": "validity_period_start",
              "type": ""
            },
            {
              "name": "validity_period_end",
              "type": ""
            },
            {
              "name": "order_origination",
              "type": "str"
            },
            {
              "name": "algo_id",
              "type": ""
            },
            {
              "name": "waiver_indicator",
              "type": ""
            },
            {
              "name": "routing_strategy",
              "type": "str"
            },
            {
              "name": "trading_venue_transaction_id",
              "type": ""
            },
            {
              "name": "order_status",
              "type": "str"
            },
            {
              "name": "modification_timestamp",
              "type": ""
            },
            {
              "name": "modification_reason",
              "type": ""
            },
            {
              "name": "cancellation_timestamp",
              "type": ""
            },
            {
              "name": "cancellation_reason",
              "type": ""
            },
            {
              "name": "rejection_timestamp",
              "type": ""
            },
            {
              "name": "rejection_reason",
              "type": ""
            },
            {
              "name": "short_selling_indicator",
              "type": ""
            },
            {
              "name": "otc_post_trade_indicator",
              "type": ""
            },
            {
              "name": "free_text",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 54
        },
        {
          "name": "RTS25RecordKeeper",
          "module": "regulatory_compliance",
          "docstring": "RTS 25 compliant order record keeper (#C5).\n\nMaintains complete order records with all required fields.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, firm_id: str, country_code: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "firm_id",
                  "type": "str"
                },
                {
                  "name": "country_code",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 190
            },
            {
              "name": "create_order_record",
              "module": "regulatory_compliance",
              "signature": "def create_order_record(self, order_id: str, client_id: str, instrument_isin: str, instrument_name: str, side: str, order_type: str, quantity: float, limit_price: , algo_id: , client_lei: ) -> RTS25OrderRecord",
              "docstring": "Create a new RTS 25 compliant order record (#C5).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "client_id",
                  "type": "str"
                },
                {
                  "name": "instrument_isin",
                  "type": "str"
                },
                {
                  "name": "instrument_name",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "order_type",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "float"
                },
                {
                  "name": "limit_price",
                  "type": ""
                },
                {
                  "name": "algo_id",
                  "type": ""
                },
                {
                  "name": "client_lei",
                  "type": ""
                }
              ],
              "return_type": "RTS25OrderRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 196
            },
            {
              "name": "_map_order_type",
              "module": "regulatory_compliance",
              "signature": "def _map_order_type(self, order_type: str) -> str",
              "docstring": "Map order type to RTS 25 code.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_type",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 264
            },
            {
              "name": "update_order_status",
              "module": "regulatory_compliance",
              "signature": "def update_order_status(self, order_id: str, new_status: str, executed_qty: float, reason: ) -> None",
              "docstring": "Update order status with timestamp (#C5).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                },
                {
                  "name": "new_status",
                  "type": "str"
                },
                {
                  "name": "executed_qty",
                  "type": "float"
                },
                {
                  "name": "reason",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 276
            },
            {
              "name": "get_record",
              "module": "regulatory_compliance",
              "signature": "def get_record(self, order_id: str)",
              "docstring": "Get order record.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 303
            },
            {
              "name": "export_records",
              "module": "regulatory_compliance",
              "signature": "def export_records(self, start_date: datetime, end_date: datetime) -> list[dict]",
              "docstring": "Export records for regulatory reporting.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "start_date",
                  "type": "datetime"
                },
                {
                  "name": "end_date",
                  "type": "datetime"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 307
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 183
        },
        {
          "name": "KillSwitchEventType",
          "module": "regulatory_compliance",
          "docstring": "Types of kill switch events (#C6).",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 319
        },
        {
          "name": "KillSwitchAuditRecord",
          "module": "regulatory_compliance",
          "docstring": "Audit record for kill switch events (#C6).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "event_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "event_type",
              "type": "KillSwitchEventType"
            },
            {
              "name": "triggered_by",
              "type": "str"
            },
            {
              "name": "reason",
              "type": "str"
            },
            {
              "name": "affected_algos",
              "type": "list[str]"
            },
            {
              "name": "affected_orders",
              "type": "list[str]"
            },
            {
              "name": "orders_cancelled",
              "type": "int"
            },
            {
              "name": "cancellation_latency_ms",
              "type": "float"
            },
            {
              "name": "success",
              "type": "bool"
            },
            {
              "name": "failure_reason",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 329
        },
        {
          "name": "KillSwitchAuditor",
          "module": "regulatory_compliance",
          "docstring": "RTS 6 compliant kill switch audit trail (#C6).\n\nTracks all kill switch activations with required detail.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 351
            },
            {
              "name": "record_activation",
              "module": "regulatory_compliance",
              "signature": "def record_activation(self, triggered_by: str, reason: str, affected_algos: list[str], affected_orders: list[str], cancellation_latency_ms: float, success: bool, failure_reason: ) -> KillSwitchAuditRecord",
              "docstring": "Record kill switch activation (#C6).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "triggered_by",
                  "type": "str"
                },
                {
                  "name": "reason",
                  "type": "str"
                },
                {
                  "name": "affected_algos",
                  "type": "list[str]"
                },
                {
                  "name": "affected_orders",
                  "type": "list[str]"
                },
                {
                  "name": "cancellation_latency_ms",
                  "type": "float"
                },
                {
                  "name": "success",
                  "type": "bool"
                },
                {
                  "name": "failure_reason",
                  "type": ""
                }
              ],
              "return_type": "KillSwitchAuditRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 356
            },
            {
              "name": "record_test",
              "module": "regulatory_compliance",
              "signature": "def record_test(self, triggered_by: str, test_orders: list[str], latency_ms: float, success: bool) -> KillSwitchAuditRecord",
              "docstring": "Record kill switch test (#C6).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "triggered_by",
                  "type": "str"
                },
                {
                  "name": "test_orders",
                  "type": "list[str]"
                },
                {
                  "name": "latency_ms",
                  "type": "float"
                },
                {
                  "name": "success",
                  "type": "bool"
                }
              ],
              "return_type": "KillSwitchAuditRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 388
            },
            {
              "name": "is_test_overdue",
              "module": "regulatory_compliance",
              "signature": "def is_test_overdue(self) -> bool",
              "docstring": "Check if kill switch test is overdue.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 413
            },
            {
              "name": "get_audit_trail",
              "module": "regulatory_compliance",
              "signature": "def get_audit_trail(self, days: int) -> list[dict]",
              "docstring": "Get audit trail for reporting.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 420
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 344
        },
        {
          "name": "MarketAbuseThresholds",
          "module": "regulatory_compliance",
          "docstring": "Configurable market abuse detection thresholds (#C7, #C14-C17).\n\nCalibrated for retail trading volumes.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "wash_trade_time_window_seconds",
              "type": "float"
            },
            {
              "name": "wash_trade_price_tolerance_pct",
              "type": "float"
            },
            {
              "name": "wash_trade_min_matches",
              "type": "int"
            },
            {
              "name": "spoofing_window_seconds",
              "type": "float"
            },
            {
              "name": "spoofing_order_cancel_ratio",
              "type": "float"
            },
            {
              "name": "spoofing_min_orders",
              "type": "int"
            },
            {
              "name": "spoofing_price_move_bps",
              "type": "float"
            },
            {
              "name": "layering_price_levels",
              "type": "int"
            },
            {
              "name": "layering_size_ratio",
              "type": "float"
            },
            {
              "name": "layering_window_seconds",
              "type": "float"
            },
            {
              "name": "quote_stuffing_threshold_per_second",
              "type": "int"
            },
            {
              "name": "quote_stuffing_cancel_ratio",
              "type": "float"
            },
            {
              "name": "quote_stuffing_window_seconds",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 444
        },
        {
          "name": "MarketAbuseDetector",
          "module": "regulatory_compliance",
          "docstring": "MAR Art 16 compliant market abuse detection (#C7).\n\nConfigurable thresholds for different trading profiles.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, thresholds: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "thresholds",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 479
            },
            {
              "name": "configure_thresholds",
              "module": "regulatory_compliance",
              "signature": "def configure_thresholds(self, thresholds: MarketAbuseThresholds) -> None",
              "docstring": "Update detection thresholds (#C7).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "thresholds",
                  "type": "MarketAbuseThresholds"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 484
            },
            {
              "name": "record_order",
              "module": "regulatory_compliance",
              "signature": "def record_order(self, order: dict) -> None",
              "docstring": "Record order for analysis.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "order",
                  "type": "dict"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 489
            },
            {
              "name": "detect_wash_trading",
              "module": "regulatory_compliance",
              "signature": "def detect_wash_trading(self, client_id: str) -> list[dict]",
              "docstring": "Detect potential wash trading (#C14).\n\nWash trading: buying and selling same security to create\nmisleading appearance of activity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "client_id",
                  "type": "str"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 498
            },
            {
              "name": "detect_spoofing",
              "module": "regulatory_compliance",
              "signature": "def detect_spoofing(self, client_id: str) -> list[dict]",
              "docstring": "Detect potential spoofing (#C15).\n\nSpoofing: placing orders with intent to cancel before execution\nto manipulate prices.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "client_id",
                  "type": "str"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 543
            },
            {
              "name": "detect_layering",
              "module": "regulatory_compliance",
              "signature": "def detect_layering(self, client_id: str, symbol: str) -> list[dict]",
              "docstring": "Detect potential layering (#C16).\n\nLayering: placing multiple orders at different price levels\nwith intent to cancel.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "client_id",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 588
            },
            {
              "name": "detect_quote_stuffing",
              "module": "regulatory_compliance",
              "signature": "def detect_quote_stuffing(self, client_id: str) -> list[dict]",
              "docstring": "Detect potential quote stuffing (#C17).\n\nQuote stuffing: submitting and cancelling large numbers of orders\nto slow down other participants.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "client_id",
                  "type": "str"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 630
            },
            {
              "name": "get_alerts",
              "module": "regulatory_compliance",
              "signature": "def get_alerts(self, severity: ) -> list[dict]",
              "docstring": "Get detected alerts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "severity",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 663
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 472
        },
        {
          "name": "RTS27Report",
          "module": "regulatory_compliance",
          "docstring": "RTS 27 Best Execution Report (#C8).\n\nPublished quarterly by execution venues.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "venue_mic",
              "type": "str"
            },
            {
              "name": "reporting_period",
              "type": "str"
            },
            {
              "name": "instrument_class",
              "type": "str"
            },
            {
              "name": "avg_execution_speed_ms",
              "type": "float"
            },
            {
              "name": "likelihood_of_execution_pct",
              "type": "float"
            },
            {
              "name": "avg_transaction_size",
              "type": "float"
            },
            {
              "name": "avg_spread_bps",
              "type": "float"
            },
            {
              "name": "price_improvement_frequency_pct",
              "type": "float"
            },
            {
              "name": "avg_price_improvement_bps",
              "type": "float"
            },
            {
              "name": "explicit_costs_bps",
              "type": "float"
            },
            {
              "name": "implicit_costs_bps",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 675
        },
        {
          "name": "RTS28Report",
          "module": "regulatory_compliance",
          "docstring": "RTS 28 Venue Analysis Report (#C9).\n\nPublished annually by investment firms.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "firm_lei",
              "type": "str"
            },
            {
              "name": "reporting_year",
              "type": "int"
            },
            {
              "name": "instrument_class",
              "type": "str"
            },
            {
              "name": "top_venues",
              "type": "list[dict]"
            },
            {
              "name": "passive_vs_aggressive_ratio",
              "type": "float"
            },
            {
              "name": "routing_decision_factors",
              "type": "list[str]"
            },
            {
              "name": "conflicts_of_interest",
              "type": ""
            },
            {
              "name": "venue_changes",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 701
        },
        {
          "name": "BestExecutionReporter",
          "module": "regulatory_compliance",
          "docstring": "RTS 27/28 Best Execution Reporter (#C8, #C9).\n\nGenerates compliant execution reports.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, firm_lei: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "firm_lei",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 730
            },
            {
              "name": "record_execution",
              "module": "regulatory_compliance",
              "signature": "def record_execution(self, venue_mic: str, instrument_class: str, execution_time_ms: float, size: float, price: float, side: str, spread_at_execution_bps: float, price_improvement_bps: float) -> None",
              "docstring": "Record an execution for reporting.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_mic",
                  "type": "str"
                },
                {
                  "name": "instrument_class",
                  "type": "str"
                },
                {
                  "name": "execution_time_ms",
                  "type": "float"
                },
                {
                  "name": "size",
                  "type": "float"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "spread_at_execution_bps",
                  "type": "float"
                },
                {
                  "name": "price_improvement_bps",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 735
            },
            {
              "name": "generate_rts28_report",
              "module": "regulatory_compliance",
              "signature": "def generate_rts28_report(self, year: int) -> RTS28Report",
              "docstring": "Generate RTS 28 annual report (#C9).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "year",
                  "type": "int"
                }
              ],
              "return_type": "RTS28Report",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 772
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 723
        },
        {
          "name": "EMIRTradeReport",
          "module": "regulatory_compliance",
          "docstring": "EMIR trade report for derivatives (#C10).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "uti",
              "type": "str"
            },
            {
              "name": "report_timestamp",
              "type": "datetime"
            },
            {
              "name": "action_type",
              "type": "str"
            },
            {
              "name": "reporting_counterparty_lei",
              "type": "str"
            },
            {
              "name": "other_counterparty_lei",
              "type": ""
            },
            {
              "name": "counterparty_side",
              "type": "str"
            },
            {
              "name": "trade_date",
              "type": "datetime"
            },
            {
              "name": "maturity_date",
              "type": ""
            },
            {
              "name": "notional_amount",
              "type": "float"
            },
            {
              "name": "notional_currency",
              "type": "str"
            },
            {
              "name": "product_classification",
              "type": "str"
            },
            {
              "name": "underlying_identification",
              "type": ""
            },
            {
              "name": "valuation_amount",
              "type": ""
            },
            {
              "name": "valuation_currency",
              "type": ""
            },
            {
              "name": "valuation_timestamp",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 824
        },
        {
          "name": "EMIRReporter",
          "module": "regulatory_compliance",
          "docstring": "EMIR Trade Repository Reporter (#C10).\n\nReports derivative trades to trade repository.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, firm_lei: str, trade_repository_url: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "firm_lei",
                  "type": "str"
                },
                {
                  "name": "trade_repository_url",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 858
            },
            {
              "name": "generate_uti",
              "module": "regulatory_compliance",
              "signature": "def generate_uti(self, trade_id: str) -> str",
              "docstring": "Generate Unique Transaction Identifier.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trade_id",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 864
            },
            {
              "name": "create_report",
              "module": "regulatory_compliance",
              "signature": "def create_report(self, trade_id: str, other_party_lei: , side: str, trade_date: datetime, notional: float, currency: str, product_type: str, maturity_date: ) -> EMIRTradeReport",
              "docstring": "Create EMIR trade report (#C10).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trade_id",
                  "type": "str"
                },
                {
                  "name": "other_party_lei",
                  "type": ""
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "trade_date",
                  "type": "datetime"
                },
                {
                  "name": "notional",
                  "type": "float"
                },
                {
                  "name": "currency",
                  "type": "str"
                },
                {
                  "name": "product_type",
                  "type": "str"
                },
                {
                  "name": "maturity_date",
                  "type": ""
                }
              ],
              "return_type": "EMIRTradeReport",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 872
            },
            {
              "name": "submit_reports",
              "module": "regulatory_compliance",
              "signature": "def submit_reports(self) -> dict",
              "docstring": "Submit pending reports to trade repository.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 905
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 851
        },
        {
          "name": "TransactionReferenceGenerator",
          "module": "regulatory_compliance",
          "docstring": "MiFIR Art 26 Transaction Reference Generator (#C12).\n\nGenerates compliant transaction reference numbers.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, firm_id: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "firm_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 929
            },
            {
              "name": "generate_transaction_ref",
              "module": "regulatory_compliance",
              "signature": "def generate_transaction_ref(self) -> str",
              "docstring": "Generate MiFIR compliant transaction reference (#C12).\n\nFormat: FIRM-YYYYMMDD-NNNNNNNN",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 934
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 922
        },
        {
          "name": "RTS24OrderIDGenerator",
          "module": "regulatory_compliance",
          "docstring": "RTS 24 Order ID Generator (#C13).\n\nGenerates compliant order identifiers.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, venue_mic: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_mic",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 957
            },
            {
              "name": "generate_order_id",
              "module": "regulatory_compliance",
              "signature": "def generate_order_id(self) -> str",
              "docstring": "Generate RTS 24 compliant order ID (#C13).\n\nFormat: MIC-TIMESTAMP-SEQUENCE",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 961
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 950
        },
        {
          "name": "PreTradeRiskLimits",
          "module": "regulatory_compliance",
          "docstring": "Pre-trade risk control limits per RTS 6 (#C18).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "max_order_value",
              "type": "float"
            },
            {
              "name": "max_order_quantity",
              "type": "int"
            },
            {
              "name": "max_position_value",
              "type": "float"
            },
            {
              "name": "max_daily_volume",
              "type": "float"
            },
            {
              "name": "max_message_rate_per_second",
              "type": "int"
            },
            {
              "name": "price_collar_pct",
              "type": "float"
            },
            {
              "name": "notional_limit_per_instrument",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 977
        },
        {
          "name": "PreTradeRiskController",
          "module": "regulatory_compliance",
          "docstring": "RTS 6 Pre-Trade Risk Controls (#C18).\n\nValidates orders before submission.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, limits: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limits",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 995
            },
            {
              "name": "validate_order",
              "module": "regulatory_compliance",
              "signature": "def validate_order(self, symbol: str, side: str, quantity: int, price: float, reference_price: ) -> tuple[bool, list[str]]",
              "docstring": "Validate order against pre-trade limits (#C18).\n\nReturns:\n    (is_valid, list of rejection reasons)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "reference_price",
                  "type": ""
                }
              ],
              "return_type": "tuple[bool, list[str]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1001
            },
            {
              "name": "_check_message_rate",
              "module": "regulatory_compliance",
              "signature": "def _check_message_rate(self) -> None",
              "docstring": "Clean up old messages from rate counter.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1057
            },
            {
              "name": "update_position",
              "module": "regulatory_compliance",
              "signature": "def update_position(self, symbol: str, value: float) -> None",
              "docstring": "Update position tracking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1062
            },
            {
              "name": "reset_daily_limits",
              "module": "regulatory_compliance",
              "signature": "def reset_daily_limits(self) -> None",
              "docstring": "Reset daily limits (call at start of day).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1066
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 988
        },
        {
          "name": "VenuePositionLimits",
          "module": "regulatory_compliance",
          "docstring": "Per-venue position limits (#C19).\n\nTracks positions by venue as required by regulations.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1082
            },
            {
              "name": "set_limit",
              "module": "regulatory_compliance",
              "signature": "def set_limit(self, venue_mic: str, symbol: str, max_position: float) -> None",
              "docstring": "Set position limit for symbol at venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_mic",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "max_position",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1086
            },
            {
              "name": "update_position",
              "module": "regulatory_compliance",
              "signature": "def update_position(self, venue_mic: str, symbol: str, position: float) -> None",
              "docstring": "Update position at venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_mic",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "position",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1092
            },
            {
              "name": "check_limit",
              "module": "regulatory_compliance",
              "signature": "def check_limit(self, venue_mic: str, symbol: str, additional: float) -> tuple[bool, ]",
              "docstring": "Check if position would exceed venue limit (#C19).\n\nReturns:\n    (within_limit, error_message)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_mic",
                  "type": "str"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "additional",
                  "type": "float"
                }
              ],
              "return_type": "tuple[bool, ]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1098
            },
            {
              "name": "get_venue_utilization",
              "module": "regulatory_compliance",
              "signature": "def get_venue_utilization(self, venue_mic: str) -> dict[str, float]",
              "docstring": "Get position utilization by symbol at venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_mic",
                  "type": "str"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1117
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1075
        },
        {
          "name": "LocateRecord",
          "module": "regulatory_compliance",
          "docstring": "Short selling locate record (#C20).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "locate_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "source",
              "type": "str"
            },
            {
              "name": "expiry",
              "type": "datetime"
            },
            {
              "name": "used_quantity",
              "type": "int"
            },
            {
              "name": "status",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1133
        },
        {
          "name": "ShortSellingLocator",
          "module": "regulatory_compliance",
          "docstring": "Short selling locate requirements (#C20).\n\nTracks locates for short selling compliance.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1152
            },
            {
              "name": "request_locate",
              "module": "regulatory_compliance",
              "signature": "def request_locate(self, symbol: str, quantity: int, source: str, validity_hours: int) -> LocateRecord",
              "docstring": "Request a locate for short selling (#C20).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "source",
                  "type": "str"
                },
                {
                  "name": "validity_hours",
                  "type": "int"
                }
              ],
              "return_type": "LocateRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1156
            },
            {
              "name": "use_locate",
              "module": "regulatory_compliance",
              "signature": "def use_locate(self, symbol: str, quantity: int) -> tuple[bool, ]",
              "docstring": "Use locate for short sale (#C20).\n\nReturns:\n    (success, error_message)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                }
              ],
              "return_type": "tuple[bool, ]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1182
            },
            {
              "name": "get_available_locates",
              "module": "regulatory_compliance",
              "signature": "def get_available_locates(self, symbol: str) -> int",
              "docstring": "Get available locate quantity for symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1217
            },
            {
              "name": "expire_locates",
              "module": "regulatory_compliance",
              "signature": "def expire_locates(self) -> int",
              "docstring": "Expire old locates.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1228
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1145
        },
        {
          "name": "ClientCategory",
          "module": "regulatory_compliance",
          "docstring": "MiFID II client categories (#C25).",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1246
        },
        {
          "name": "ClientRecord",
          "module": "regulatory_compliance",
          "docstring": "Client categorization record (#C25).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "client_id",
              "type": "str"
            },
            {
              "name": "category",
              "type": "ClientCategory"
            },
            {
              "name": "lei",
              "type": ""
            },
            {
              "name": "categorization_date",
              "type": "datetime"
            },
            {
              "name": "last_review_date",
              "type": "datetime"
            },
            {
              "name": "opt_up_requested",
              "type": "bool"
            },
            {
              "name": "opt_down_requested",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1254
        },
        {
          "name": "ClientCategorizer",
          "module": "regulatory_compliance",
          "docstring": "MiFID II Client Categorization (#C25).\n\nTracks client categories and opt-up/opt-down requests.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1272
            },
            {
              "name": "categorize_client",
              "module": "regulatory_compliance",
              "signature": "def categorize_client(self, client_id: str, category: ClientCategory, lei: ) -> ClientRecord",
              "docstring": "Categorize a client (#C25).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "client_id",
                  "type": "str"
                },
                {
                  "name": "category",
                  "type": "ClientCategory"
                },
                {
                  "name": "lei",
                  "type": ""
                }
              ],
              "return_type": "ClientRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1275
            },
            {
              "name": "request_opt_up",
              "module": "regulatory_compliance",
              "signature": "def request_opt_up(self, client_id: str) -> bool",
              "docstring": "Request opt-up from retail to professional.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "client_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1294
            },
            {
              "name": "approve_opt_up",
              "module": "regulatory_compliance",
              "signature": "def approve_opt_up(self, client_id: str) -> bool",
              "docstring": "Approve opt-up request.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "client_id",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1307
            },
            {
              "name": "get_client_category",
              "module": "regulatory_compliance",
              "signature": "def get_client_category(self, client_id: str)",
              "docstring": "Get client's current category.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "client_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1318
            },
            {
              "name": "get_clients_by_category",
              "module": "regulatory_compliance",
              "signature": "def get_clients_by_category(self, category: ClientCategory) -> list[str]",
              "docstring": "Get all clients in a category.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "category",
                  "type": "ClientCategory"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1323
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1265
        },
        {
          "name": "ClockSynchronizer",
          "module": "regulatory_compliance",
          "docstring": "RTS 25 Clock Synchronization (#C27).\n\nEnsures system clocks meet regulatory requirements.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, activity_type: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "activity_type",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1350
            },
            {
              "name": "record_sync",
              "module": "regulatory_compliance",
              "signature": "def record_sync(self, source: str, drift_microseconds: float) -> None",
              "docstring": "Record clock synchronization event (#C27).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "source",
                  "type": "str"
                },
                {
                  "name": "drift_microseconds",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1359
            },
            {
              "name": "is_compliant",
              "module": "regulatory_compliance",
              "signature": "def is_compliant(self) -> tuple[bool, ]",
              "docstring": "Check if clock synchronization is compliant (#C27).\n\nReturns:\n    (is_compliant, reason_if_not)",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "tuple[bool, ]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1368
            },
            {
              "name": "get_sync_report",
              "module": "regulatory_compliance",
              "signature": "def get_sync_report(self) -> dict",
              "docstring": "Get clock synchronization report.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1393
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1335
        },
        {
          "name": "AuditLogRotator",
          "module": "regulatory_compliance",
          "docstring": "Audit log rotation policy (#C28).\n\nManages log rotation while maintaining compliance requirements.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, log_dir: str, retention_days: int, rotation_size_mb: int, compression: bool)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "log_dir",
                  "type": "str"
                },
                {
                  "name": "retention_days",
                  "type": "int"
                },
                {
                  "name": "rotation_size_mb",
                  "type": "int"
                },
                {
                  "name": "compression",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1421
            },
            {
              "name": "rotate_if_needed",
              "module": "regulatory_compliance",
              "signature": "def rotate_if_needed(self, current_log_path: str)",
              "docstring": "Rotate log file if size threshold exceeded (#C28).\n\nReturns:\n    Path to rotated file or None",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_log_path",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1434
            },
            {
              "name": "purge_old_logs",
              "module": "regulatory_compliance",
              "signature": "def purge_old_logs(self) -> int",
              "docstring": "Purge logs older than retention period (#C28).\n\nReturns:\n    Number of files purged",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1465
            },
            {
              "name": "get_rotation_policy",
              "module": "regulatory_compliance",
              "signature": "def get_rotation_policy(self) -> dict",
              "docstring": "Get current rotation policy.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1481
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1414
        },
        {
          "name": "AccessEventType",
          "module": "regulatory_compliance",
          "docstring": "Types of access events (#C30).",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1497
        },
        {
          "name": "AccessLogEntry",
          "module": "regulatory_compliance",
          "docstring": "Access control log entry (#C30).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "event_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "event_type",
              "type": "AccessEventType"
            },
            {
              "name": "user_id",
              "type": "str"
            },
            {
              "name": "ip_address",
              "type": "str"
            },
            {
              "name": "resource",
              "type": ""
            },
            {
              "name": "action",
              "type": "str"
            },
            {
              "name": "success",
              "type": "bool"
            },
            {
              "name": "details",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1509
        },
        {
          "name": "AccessControlLogger",
          "module": "regulatory_compliance",
          "docstring": "Access control logging (#C30).\n\nLogs all access events for compliance.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1529
            },
            {
              "name": "log_access",
              "module": "regulatory_compliance",
              "signature": "def log_access(self, event_type: AccessEventType, user_id: str, ip_address: str, action: str, success: bool, resource: , details: ) -> AccessLogEntry",
              "docstring": "Log an access event (#C30).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event_type",
                  "type": "AccessEventType"
                },
                {
                  "name": "user_id",
                  "type": "str"
                },
                {
                  "name": "ip_address",
                  "type": "str"
                },
                {
                  "name": "action",
                  "type": "str"
                },
                {
                  "name": "success",
                  "type": "bool"
                },
                {
                  "name": "resource",
                  "type": ""
                },
                {
                  "name": "details",
                  "type": ""
                }
              ],
              "return_type": "AccessLogEntry",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1533
            },
            {
              "name": "get_user_activity",
              "module": "regulatory_compliance",
              "signature": "def get_user_activity(self, user_id: str, days: int) -> list[dict]",
              "docstring": "Get activity log for a user.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "user_id",
                  "type": "str"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1568
            },
            {
              "name": "get_failed_logins",
              "module": "regulatory_compliance",
              "signature": "def get_failed_logins(self, hours: int) -> list[dict]",
              "docstring": "Get failed login attempts.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hours",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1585
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1522
        },
        {
          "name": "ChangeRecord",
          "module": "regulatory_compliance",
          "docstring": "Change management record (#C31).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "change_id",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "change_type",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "requested_by",
              "type": "str"
            },
            {
              "name": "approved_by",
              "type": ""
            },
            {
              "name": "implemented_by",
              "type": "str"
            },
            {
              "name": "affected_systems",
              "type": "list[str]"
            },
            {
              "name": "rollback_plan",
              "type": ""
            },
            {
              "name": "status",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1606
        },
        {
          "name": "ChangeManagementAuditor",
          "module": "regulatory_compliance",
          "docstring": "Change management audit trail (#C31).\n\nTracks all system changes for compliance.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1627
            },
            {
              "name": "record_change",
              "module": "regulatory_compliance",
              "signature": "def record_change(self, change_type: str, description: str, requested_by: str, implemented_by: str, affected_systems: list[str], approved_by: , rollback_plan: ) -> ChangeRecord",
              "docstring": "Record a system change (#C31).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "change_type",
                  "type": "str"
                },
                {
                  "name": "description",
                  "type": "str"
                },
                {
                  "name": "requested_by",
                  "type": "str"
                },
                {
                  "name": "implemented_by",
                  "type": "str"
                },
                {
                  "name": "affected_systems",
                  "type": "list[str]"
                },
                {
                  "name": "approved_by",
                  "type": ""
                },
                {
                  "name": "rollback_plan",
                  "type": ""
                }
              ],
              "return_type": "ChangeRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1631
            },
            {
              "name": "get_recent_changes",
              "module": "regulatory_compliance",
              "signature": "def get_recent_changes(self, days: int) -> list[dict]",
              "docstring": "Get recent changes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1661
            },
            {
              "name": "get_changes_by_system",
              "module": "regulatory_compliance",
              "signature": "def get_changes_by_system(self, system: str) -> list[dict]",
              "docstring": "Get changes affecting a specific system.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "system",
                  "type": "str"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1680
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1620
        },
        {
          "name": "DRTestRecord",
          "module": "regulatory_compliance",
          "docstring": "Disaster recovery test record (#C32).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "test_id",
              "type": "str"
            },
            {
              "name": "test_date",
              "type": "datetime"
            },
            {
              "name": "test_type",
              "type": "str"
            },
            {
              "name": "scenario",
              "type": "str"
            },
            {
              "name": "rto_target_minutes",
              "type": "int"
            },
            {
              "name": "rto_actual_minutes",
              "type": ""
            },
            {
              "name": "rpo_target_minutes",
              "type": "int"
            },
            {
              "name": "rpo_actual_minutes",
              "type": ""
            },
            {
              "name": "success",
              "type": "bool"
            },
            {
              "name": "issues_found",
              "type": "list[str]"
            },
            {
              "name": "remediation_actions",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 1698
        },
        {
          "name": "DisasterRecoveryDocumentor",
          "module": "regulatory_compliance",
          "docstring": "Disaster recovery documentation (#C32).\n\nAutomated DR documentation and test tracking.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, rto_minutes: int, rpo_minutes: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "rto_minutes",
                  "type": "int"
                },
                {
                  "name": "rpo_minutes",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1720
            },
            {
              "name": "record_dr_test",
              "module": "regulatory_compliance",
              "signature": "def record_dr_test(self, test_type: str, scenario: str, rto_actual: , rpo_actual: , success: bool, issues: list[str], remediation: list[str]) -> DRTestRecord",
              "docstring": "Record a DR test (#C32).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "test_type",
                  "type": "str"
                },
                {
                  "name": "scenario",
                  "type": "str"
                },
                {
                  "name": "rto_actual",
                  "type": ""
                },
                {
                  "name": "rpo_actual",
                  "type": ""
                },
                {
                  "name": "success",
                  "type": "bool"
                },
                {
                  "name": "issues",
                  "type": "list[str]"
                },
                {
                  "name": "remediation",
                  "type": "list[str]"
                }
              ],
              "return_type": "DRTestRecord",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1730
            },
            {
              "name": "generate_dr_report",
              "module": "regulatory_compliance",
              "signature": "def generate_dr_report(self) -> dict",
              "docstring": "Generate DR documentation report (#C32).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1760
            },
            {
              "name": "_calculate_next_test_due",
              "module": "regulatory_compliance",
              "signature": "def _calculate_next_test_due(self)",
              "docstring": "Calculate when next DR test is due.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1785
            },
            {
              "name": "is_test_overdue",
              "module": "regulatory_compliance",
              "signature": "def is_test_overdue(self) -> bool",
              "docstring": "Check if DR test is overdue.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1799
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1713
        },
        {
          "name": "RegulatoryComplianceManager",
          "module": "regulatory_compliance",
          "docstring": "Unified regulatory compliance manager.\n\nProvides single interface to all compliance modules.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_compliance",
              "signature": "def __init__(self, firm_lei: str, country_code: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "firm_lei",
                  "type": "str"
                },
                {
                  "name": "country_code",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1820
            },
            {
              "name": "get_compliance_status",
              "module": "regulatory_compliance",
              "signature": "def get_compliance_status(self) -> dict",
              "docstring": "Get overall compliance status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1842
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 1813
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "os",
        "uuid",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__",
        "hashlib",
        "uuid"
      ]
    },
    "core.regulatory_monitoring": {
      "name": "regulatory_monitoring",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\regulatory_monitoring.py",
      "docstring": "Regulatory Change Monitoring and Compliance Report Templates.\n\nThis module provides automated monitoring of regulatory changes and\nstandardized templates for compliance reporting.\n\nAddresses:\n- #C42 - Regulatory change monitoring not automated\n- #C43 - Compliance report templates outdated",
      "classes": [
        {
          "name": "RegulatorType",
          "module": "regulatory_monitoring",
          "docstring": "Types of financial regulators.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 24
        },
        {
          "name": "RegulatoryDomain",
          "module": "regulatory_monitoring",
          "docstring": "Regulatory domains/categories.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 35
        },
        {
          "name": "ChangeImpact",
          "module": "regulatory_monitoring",
          "docstring": "Impact level of regulatory changes.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 49
        },
        {
          "name": "ChangeStatus",
          "module": "regulatory_monitoring",
          "docstring": "Status of regulatory change tracking.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 58
        },
        {
          "name": "RegulatoryChange",
          "module": "regulatory_monitoring",
          "docstring": "Represents a regulatory change or update.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_monitoring",
              "signature": "def to_dict(self) -> Dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 90
            },
            {
              "name": "days_until_effective",
              "module": "regulatory_monitoring",
              "signature": "def days_until_effective(self) -> int",
              "docstring": "Calculate days until effective date.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 112
            },
            {
              "name": "is_overdue",
              "module": "regulatory_monitoring",
              "signature": "def is_overdue(self) -> bool",
              "docstring": "Check if implementation is overdue.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 117
            }
          ],
          "class_attributes": [
            {
              "name": "change_id",
              "type": "str"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "regulator",
              "type": "RegulatorType"
            },
            {
              "name": "domain",
              "type": "RegulatoryDomain"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "effective_date",
              "type": "datetime"
            },
            {
              "name": "publication_date",
              "type": "datetime"
            },
            {
              "name": "impact",
              "type": "ChangeImpact"
            },
            {
              "name": "status",
              "type": "ChangeStatus"
            },
            {
              "name": "source_url",
              "type": "str"
            },
            {
              "name": "affected_modules",
              "type": "List[str]"
            },
            {
              "name": "implementation_notes",
              "type": "str"
            },
            {
              "name": "assigned_to",
              "type": "str"
            },
            {
              "name": "review_deadline",
              "type": "Optional[datetime]"
            },
            {
              "name": "implementation_deadline",
              "type": "Optional[datetime]"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "updated_at",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 70
        },
        {
          "name": "RegulatoryFeed",
          "module": "regulatory_monitoring",
          "docstring": "Configuration for a regulatory feed source.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "feed_id",
              "type": "str"
            },
            {
              "name": "regulator",
              "type": "RegulatorType"
            },
            {
              "name": "feed_url",
              "type": "str"
            },
            {
              "name": "feed_type",
              "type": "str"
            },
            {
              "name": "check_interval_hours",
              "type": "int"
            },
            {
              "name": "last_checked",
              "type": "Optional[datetime]"
            },
            {
              "name": "enabled",
              "type": "bool"
            },
            {
              "name": "auth_required",
              "type": "bool"
            },
            {
              "name": "auth_config",
              "type": "Dict[str, str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 127
        },
        {
          "name": "RegulatoryChangeMonitor",
          "module": "regulatory_monitoring",
          "docstring": "Monitors regulatory changes from various sources.\n\nProvides automated tracking and alerting for regulatory updates\nthat may affect trading operations.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_monitoring",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 148
            },
            {
              "name": "_setup_default_feeds",
              "module": "regulatory_monitoring",
              "signature": "def _setup_default_feeds(self)",
              "docstring": "Configure default regulatory feed sources.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 155
            },
            {
              "name": "add_feed",
              "module": "regulatory_monitoring",
              "signature": "def add_feed(self, feed: RegulatoryFeed)",
              "docstring": "Add a regulatory feed source.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "feed",
                  "type": "RegulatoryFeed"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 183
            },
            {
              "name": "subscribe",
              "module": "regulatory_monitoring",
              "signature": "def subscribe(self, domain: RegulatoryDomain, callback: Callable[, None])",
              "docstring": "Subscribe to changes in a regulatory domain.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "domain",
                  "type": "RegulatoryDomain"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 188
            },
            {
              "name": "_generate_change_id",
              "module": "regulatory_monitoring",
              "signature": "def _generate_change_id(self, title: str, regulator: str, date: datetime) -> str",
              "docstring": "Generate unique change ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "title",
                  "type": "str"
                },
                {
                  "name": "regulator",
                  "type": "str"
                },
                {
                  "name": "date",
                  "type": "datetime"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 194
            },
            {
              "name": "_classify_domain",
              "module": "regulatory_monitoring",
              "signature": "def _classify_domain(self, title: str, description: str) -> RegulatoryDomain",
              "docstring": "Classify regulatory change into a domain based on content.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "title",
                  "type": "str"
                },
                {
                  "name": "description",
                  "type": "str"
                }
              ],
              "return_type": "RegulatoryDomain",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            },
            {
              "name": "_assess_impact",
              "module": "regulatory_monitoring",
              "signature": "def _assess_impact(self, change: RegulatoryChange) -> ChangeImpact",
              "docstring": "Assess the impact level of a regulatory change.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "change",
                  "type": "RegulatoryChange"
                }
              ],
              "return_type": "ChangeImpact",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 223
            },
            {
              "name": "register_change",
              "module": "regulatory_monitoring",
              "signature": "def register_change(self, change: RegulatoryChange) -> bool",
              "docstring": "Register a new regulatory change.\n\nReturns True if this is a new change, False if duplicate.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "change",
                  "type": "RegulatoryChange"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 242
            },
            {
              "name": "update_status",
              "module": "regulatory_monitoring",
              "signature": "def update_status(self, change_id: str, status: ChangeStatus, notes: str)",
              "docstring": "Update the status of a regulatory change.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "change_id",
                  "type": "str"
                },
                {
                  "name": "status",
                  "type": "ChangeStatus"
                },
                {
                  "name": "notes",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 288
            },
            {
              "name": "get_pending_changes",
              "module": "regulatory_monitoring",
              "signature": "def get_pending_changes(self, impact_filter: Optional[ChangeImpact], domain_filter: Optional[RegulatoryDomain]) -> List[RegulatoryChange]",
              "docstring": "Get list of pending regulatory changes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "impact_filter",
                  "type": "Optional[ChangeImpact]"
                },
                {
                  "name": "domain_filter",
                  "type": "Optional[RegulatoryDomain]"
                }
              ],
              "return_type": "List[RegulatoryChange]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 303
            },
            {
              "name": "get_overdue_changes",
              "module": "regulatory_monitoring",
              "signature": "def get_overdue_changes(self) -> List[RegulatoryChange]",
              "docstring": "Get list of overdue regulatory changes.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "List[RegulatoryChange]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 325
            },
            {
              "name": "get_change_summary",
              "module": "regulatory_monitoring",
              "signature": "def get_change_summary(self) -> Dict[str, Any]",
              "docstring": "Get summary of all tracked regulatory changes.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 329
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 140
        },
        {
          "name": "ReportFormat",
          "module": "regulatory_monitoring",
          "docstring": "Report output formats.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 358
        },
        {
          "name": "ReportSection",
          "module": "regulatory_monitoring",
          "docstring": "Section within a compliance report.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_monitoring",
              "signature": "def to_dict(self) -> Dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 376
            }
          ],
          "class_attributes": [
            {
              "name": "section_id",
              "type": "str"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "content",
              "type": "str"
            },
            {
              "name": "data",
              "type": "Dict[str, Any]"
            },
            {
              "name": "subsections",
              "type": "List[ReportSection]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 368
        },
        {
          "name": "ComplianceReportTemplate",
          "module": "regulatory_monitoring",
          "docstring": "Template for compliance reports.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "regulatory_monitoring",
              "signature": "def to_dict(self) -> Dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 402
            }
          ],
          "class_attributes": [
            {
              "name": "template_id",
              "type": "str"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "regulation",
              "type": "str"
            },
            {
              "name": "report_type",
              "type": "str"
            },
            {
              "name": "frequency",
              "type": "str"
            },
            {
              "name": "sections",
              "type": "List[str]"
            },
            {
              "name": "required_data",
              "type": "List[str]"
            },
            {
              "name": "output_formats",
              "type": "List[ReportFormat]"
            },
            {
              "name": "version",
              "type": "str"
            },
            {
              "name": "last_updated",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 388
        },
        {
          "name": "ComplianceReportGenerator",
          "module": "regulatory_monitoring",
          "docstring": "Generates compliance reports using standardized templates.\n\nProvides templates for various EU regulatory requirements including\nMiFID II, EMIR, MAR, and internal compliance reporting.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_monitoring",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 427
            },
            {
              "name": "_setup_default_templates",
              "module": "regulatory_monitoring",
              "signature": "def _setup_default_templates(self)",
              "docstring": "Set up default compliance report templates.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 431
            },
            {
              "name": "get_template",
              "module": "regulatory_monitoring",
              "signature": "def get_template(self, template_id: str) -> Optional[ComplianceReportTemplate]",
              "docstring": "Get a report template by ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "template_id",
                  "type": "str"
                }
              ],
              "return_type": "Optional[ComplianceReportTemplate]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 634
            },
            {
              "name": "list_templates",
              "module": "regulatory_monitoring",
              "signature": "def list_templates(self, regulation_filter: Optional[str], frequency_filter: Optional[str]) -> List[ComplianceReportTemplate]",
              "docstring": "List available report templates.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "regulation_filter",
                  "type": "Optional[str]"
                },
                {
                  "name": "frequency_filter",
                  "type": "Optional[str]"
                }
              ],
              "return_type": "List[ComplianceReportTemplate]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 638
            },
            {
              "name": "generate_report",
              "module": "regulatory_monitoring",
              "signature": "def generate_report(self, template_id: str, data: Dict[str, Any], output_format: ReportFormat, report_date: Optional[datetime]) -> Dict[str, Any]",
              "docstring": "Generate a compliance report from a template.\n\nArgs:\n    template_id: ID of the template to use\n    data: Data to populate the report\n    output_format: Desired output format\n    report_date: Date for the report (defaults to today)\n\nReturns:\n    Generated report content",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "template_id",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                },
                {
                  "name": "output_format",
                  "type": "ReportFormat"
                },
                {
                  "name": "report_date",
                  "type": "Optional[datetime]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 652
            },
            {
              "name": "_build_section",
              "module": "regulatory_monitoring",
              "signature": "def _build_section(self, section_name: str, data: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Build a report section with available data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section_name",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 711
            },
            {
              "name": "_build_executive_summary",
              "module": "regulatory_monitoring",
              "signature": "def _build_executive_summary(self, section_name: str, data: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Build executive summary section.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section_name",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 726
            },
            {
              "name": "_build_trading_activity",
              "module": "regulatory_monitoring",
              "signature": "def _build_trading_activity(self, section_name: str, data: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Build trading activity section.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section_name",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 739
            },
            {
              "name": "_build_limit_utilization",
              "module": "regulatory_monitoring",
              "signature": "def _build_limit_utilization(self, section_name: str, data: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Build limit utilization section.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section_name",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 755
            },
            {
              "name": "_build_breach_summary",
              "module": "regulatory_monitoring",
              "signature": "def _build_breach_summary(self, section_name: str, data: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Build breach summary section.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section_name",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 769
            },
            {
              "name": "_build_var_metrics",
              "module": "regulatory_monitoring",
              "signature": "def _build_var_metrics(self, section_name: str, data: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Build VaR metrics section.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section_name",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 783
            },
            {
              "name": "_build_venue_statistics",
              "module": "regulatory_monitoring",
              "signature": "def _build_venue_statistics(self, section_name: str, data: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Build venue statistics section.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section_name",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 797
            },
            {
              "name": "_build_generic_section",
              "module": "regulatory_monitoring",
              "signature": "def _build_generic_section(self, section_name: str, data: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Build a generic section.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section_name",
                  "type": "str"
                },
                {
                  "name": "data",
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 809
            },
            {
              "name": "export_template_catalog",
              "module": "regulatory_monitoring",
              "signature": "def export_template_catalog(self) -> str",
              "docstring": "Export catalog of all templates as JSON.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 817
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 419
        },
        {
          "name": "RegulatoryComplianceSystem",
          "module": "regulatory_monitoring",
          "docstring": "Unified system for regulatory change monitoring and compliance reporting.\n\nCombines change monitoring with report generation for comprehensive\nregulatory compliance management.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "regulatory_monitoring",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 839
            },
            {
              "name": "get_compliance_status",
              "module": "regulatory_monitoring",
              "signature": "def get_compliance_status(self) -> Dict[str, Any]",
              "docstring": "Get overall compliance status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 843
            },
            {
              "name": "generate_compliance_dashboard_data",
              "module": "regulatory_monitoring",
              "signature": "def generate_compliance_dashboard_data(self) -> Dict[str, Any]",
              "docstring": "Generate data for compliance dashboard.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "Dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 855
            },
            {
              "name": "_get_upcoming_deadlines",
              "module": "regulatory_monitoring",
              "signature": "def _get_upcoming_deadlines(self, days: int) -> List[Dict[str, Any]]",
              "docstring": "Get regulatory deadlines in the next N days.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days",
                  "type": "int"
                }
              ],
              "return_type": "List[Dict[str, Any]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 873
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 831
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "hashlib",
        "json"
      ],
      "dependencies": [
        "hashlib"
      ]
    },
    "core.risk_budget": {
      "name": "risk_budget",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\risk_budget.py",
      "docstring": "Cross-Strategy Risk Budget Manager\n==================================\n\nImplements risk budget allocation across strategies and portfolio rebalancing triggers\nper Expert Review Issues #P3 and #P4.\n\nFeatures:\n- Cross-strategy risk budget allocation with various methods\n- Risk consumption tracking per strategy\n- Dynamic risk budget adjustment based on performance\n- Portfolio rebalancing triggers (threshold-based, time-based, drift-based)\n- Risk parity allocation",
      "classes": [
        {
          "name": "AllocationMethod",
          "module": "risk_budget",
          "docstring": "Risk budget allocation methods.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 27
        },
        {
          "name": "RebalanceTrigger",
          "module": "risk_budget",
          "docstring": "Types of rebalancing triggers.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 36
        },
        {
          "name": "StrategyRiskBudget",
          "module": "risk_budget",
          "docstring": "Risk budget allocation for a single strategy.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "strategy",
              "type": "str"
            },
            {
              "name": "target_allocation",
              "type": "float"
            },
            {
              "name": "current_allocation",
              "type": "float"
            },
            {
              "name": "min_allocation",
              "type": "float"
            },
            {
              "name": "max_allocation",
              "type": "float"
            },
            {
              "name": "current_var",
              "type": "float"
            },
            {
              "name": "max_var",
              "type": "float"
            },
            {
              "name": "current_drawdown",
              "type": "float"
            },
            {
              "name": "max_drawdown",
              "type": "float"
            },
            {
              "name": "volatility",
              "type": "float"
            },
            {
              "name": "sharpe_ratio",
              "type": "float"
            },
            {
              "name": "last_update",
              "type": "datetime"
            },
            {
              "name": "is_frozen",
              "type": "bool"
            },
            {
              "name": "freeze_reason",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 47
        },
        {
          "name": "RebalanceEvent",
          "module": "risk_budget",
          "docstring": "A rebalancing event triggered by the system.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "trigger",
              "type": "RebalanceTrigger"
            },
            {
              "name": "strategies_affected",
              "type": "list[str]"
            },
            {
              "name": "old_allocations",
              "type": "dict[str, float]"
            },
            {
              "name": "new_allocations",
              "type": "dict[str, float]"
            },
            {
              "name": "reason",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 66
        },
        {
          "name": "RiskBudgetConfig",
          "module": "risk_budget",
          "docstring": "Configuration for risk budget manager.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "allocation_method",
              "type": "AllocationMethod"
            },
            {
              "name": "total_risk_budget",
              "type": "float"
            },
            {
              "name": "rebalance_drift_threshold",
              "type": "float"
            },
            {
              "name": "rebalance_time_interval_hours",
              "type": "int"
            },
            {
              "name": "strategy_max_drawdown",
              "type": "float"
            },
            {
              "name": "portfolio_max_drawdown",
              "type": "float"
            },
            {
              "name": "sharpe_freeze_threshold",
              "type": "float"
            },
            {
              "name": "sharpe_recovery_threshold",
              "type": "float"
            },
            {
              "name": "vol_scaling_enabled",
              "type": "bool"
            },
            {
              "name": "high_vol_threshold",
              "type": "float"
            },
            {
              "name": "high_vol_reduction",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 77
        },
        {
          "name": "RiskBudgetManager",
          "module": "risk_budget",
          "docstring": "Cross-Strategy Risk Budget Manager.\n\nManages risk allocation across multiple trading strategies,\nensuring total risk stays within portfolio limits.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_budget",
              "signature": "def __init__(self, config: , fixed_allocations: )",
              "docstring": "Initialize risk budget manager.\n\nArgs:\n    config: Risk budget configuration\n    fixed_allocations: Fixed strategy allocations (for FIXED method)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                },
                {
                  "name": "fixed_allocations",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 111
            },
            {
              "name": "register_strategy",
              "module": "risk_budget",
              "signature": "def register_strategy(self, strategy: str, initial_allocation: , min_allocation: float, max_allocation: float) -> None",
              "docstring": "Register a strategy for risk budget tracking.\n\nArgs:\n    strategy: Strategy name\n    initial_allocation: Initial target allocation (optional)\n    min_allocation: Minimum allowed allocation\n    max_allocation: Maximum allowed allocation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "initial_allocation",
                  "type": ""
                },
                {
                  "name": "min_allocation",
                  "type": "float"
                },
                {
                  "name": "max_allocation",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 144
            },
            {
              "name": "update_strategy_metrics",
              "module": "risk_budget",
              "signature": "def update_strategy_metrics(self, strategy: str, current_var: float, volatility: float, sharpe_ratio: float, current_drawdown: float, pnl: float) -> None",
              "docstring": "Update strategy metrics for risk budget calculation.\n\nArgs:\n    strategy: Strategy name\n    current_var: Current VaR consumption\n    volatility: Annualized volatility\n    sharpe_ratio: Rolling Sharpe ratio\n    current_drawdown: Current drawdown (as positive fraction)\n    pnl: Latest P&L",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "current_var",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "sharpe_ratio",
                  "type": "float"
                },
                {
                  "name": "current_drawdown",
                  "type": "float"
                },
                {
                  "name": "pnl",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 194
            },
            {
              "name": "_check_freeze_conditions",
              "module": "risk_budget",
              "signature": "def _check_freeze_conditions(self, budget: StrategyRiskBudget) -> None",
              "docstring": "Check if strategy should be frozen.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "budget",
                  "type": "StrategyRiskBudget"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 232
            },
            {
              "name": "_recalculate_allocations",
              "module": "risk_budget",
              "signature": "def _recalculate_allocations(self) -> None",
              "docstring": "Recalculate target allocations based on method.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 270
            },
            {
              "name": "_allocate_equal",
              "module": "risk_budget",
              "signature": "def _allocate_equal(self) -> None",
              "docstring": "Equal allocation to all active strategies.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 295
            },
            {
              "name": "_allocate_risk_parity",
              "module": "risk_budget",
              "signature": "def _allocate_risk_parity(self) -> None",
              "docstring": "Risk parity allocation - inverse volatility weighting.\n\nAllocates more to lower-volatility strategies.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 310
            },
            {
              "name": "_allocate_performance_weighted",
              "module": "risk_budget",
              "signature": "def _allocate_performance_weighted(self) -> None",
              "docstring": "Performance-weighted allocation based on Sharpe ratio.\n\nAllocates more to better-performing strategies.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 338
            },
            {
              "name": "_allocate_drawdown_adjusted",
              "module": "risk_budget",
              "signature": "def _allocate_drawdown_adjusted(self) -> None",
              "docstring": "Drawdown-adjusted allocation.\n\nReduces allocation to strategies in drawdown.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 368
            },
            {
              "name": "_allocate_fixed",
              "module": "risk_budget",
              "signature": "def _allocate_fixed(self) -> None",
              "docstring": "Use fixed allocations from configuration.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 394
            },
            {
              "name": "_apply_allocation_constraints",
              "module": "risk_budget",
              "signature": "def _apply_allocation_constraints(self) -> None",
              "docstring": "Apply min/max constraints and renormalize.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 403
            },
            {
              "name": "check_rebalance_triggers",
              "module": "risk_budget",
              "signature": "def check_rebalance_triggers(self) -> list[RebalanceEvent]",
              "docstring": "Check all rebalancing triggers and return any triggered events.\n\nReturns:\n    List of triggered rebalance events",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[RebalanceEvent]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 419
            },
            {
              "name": "_check_drift_trigger",
              "module": "risk_budget",
              "signature": "def _check_drift_trigger(self)",
              "docstring": "Check if allocation drift exceeds threshold.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 450
            },
            {
              "name": "_check_time_trigger",
              "module": "risk_budget",
              "signature": "def _check_time_trigger(self)",
              "docstring": "Check if time-based rebalancing is due.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 468
            },
            {
              "name": "_check_drawdown_trigger",
              "module": "risk_budget",
              "signature": "def _check_drawdown_trigger(self)",
              "docstring": "Check for drawdown-triggered rebalancing.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 483
            },
            {
              "name": "_check_volatility_trigger",
              "module": "risk_budget",
              "signature": "def _check_volatility_trigger(self)",
              "docstring": "Check for volatility regime change trigger.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 498
            },
            {
              "name": "_create_rebalance_event",
              "module": "risk_budget",
              "signature": "def _create_rebalance_event(self, trigger: RebalanceTrigger, affected: list[str], reason: str) -> RebalanceEvent",
              "docstring": "Create a rebalancing event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trigger",
                  "type": "RebalanceTrigger"
                },
                {
                  "name": "affected",
                  "type": "list[str]"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "RebalanceEvent",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 518
            },
            {
              "name": "trigger_manual_rebalance",
              "module": "risk_budget",
              "signature": "def trigger_manual_rebalance(self, reason: str) -> RebalanceEvent",
              "docstring": "Manually trigger a rebalancing.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "reason",
                  "type": "str"
                }
              ],
              "return_type": "RebalanceEvent",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 555
            },
            {
              "name": "get_available_budget",
              "module": "risk_budget",
              "signature": "def get_available_budget(self, strategy: str) -> float",
              "docstring": "Get available risk budget for a strategy.\n\nReturns the maximum VaR that can be consumed.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 563
            },
            {
              "name": "can_increase_position",
              "module": "risk_budget",
              "signature": "def can_increase_position(self, strategy: str, additional_var: float) -> tuple[bool, str]",
              "docstring": "Check if a strategy can increase its position.\n\nArgs:\n    strategy: Strategy name\n    additional_var: Additional VaR from new position\n\nReturns:\n    Tuple of (can_increase, reason)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "additional_var",
                  "type": "float"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 591
            },
            {
              "name": "get_budget",
              "module": "risk_budget",
              "signature": "def get_budget(self, strategy: str)",
              "docstring": "Get budget for a strategy.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 617
            },
            {
              "name": "get_all_budgets",
              "module": "risk_budget",
              "signature": "def get_all_budgets(self) -> dict[str, StrategyRiskBudget]",
              "docstring": "Get all strategy budgets.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, StrategyRiskBudget]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 621
            },
            {
              "name": "get_portfolio_utilization",
              "module": "risk_budget",
              "signature": "def get_portfolio_utilization(self) -> float",
              "docstring": "Get total portfolio risk budget utilization.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 625
            },
            {
              "name": "get_status",
              "module": "risk_budget",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get manager status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 632
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 103
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.risk_cache": {
      "name": "risk_cache",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\risk_cache.py",
      "docstring": "Risk Metric Caching Module\n==========================\n\nAddresses issue #R29: No risk metric caching optimization.\n\nFeatures:\n- Efficient caching of expensive risk calculations\n- TTL-based cache invalidation\n- Dependency-aware cache management\n- Cache warming on startup\n- Memory-bounded cache with LRU eviction",
      "classes": [
        {
          "name": "CacheInvalidationReason",
          "module": "risk_cache",
          "docstring": "Reasons for cache invalidation.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 34
        },
        {
          "name": "CacheEntry",
          "module": "risk_cache",
          "docstring": "A single cache entry with metadata.",
          "bases": [
            "Generic[...]"
          ],
          "methods": [
            {
              "name": "is_expired",
              "module": "risk_cache",
              "signature": "def is_expired(self) -> bool",
              "docstring": "Check if entry has expired.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 57
            },
            {
              "name": "age_seconds",
              "module": "risk_cache",
              "signature": "def age_seconds(self) -> float",
              "docstring": "Age of entry in seconds.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 62
            }
          ],
          "class_attributes": [
            {
              "name": "key",
              "type": "str"
            },
            {
              "name": "value",
              "type": "T"
            },
            {
              "name": "created_at",
              "type": "float"
            },
            {
              "name": "expires_at",
              "type": "float"
            },
            {
              "name": "access_count",
              "type": "int"
            },
            {
              "name": "last_accessed",
              "type": "float"
            },
            {
              "name": "dependencies",
              "type": "set[str]"
            },
            {
              "name": "size_bytes",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 45
        },
        {
          "name": "CacheStats",
          "module": "risk_cache",
          "docstring": "Cache statistics.",
          "bases": [],
          "methods": [
            {
              "name": "hit_rate",
              "module": "risk_cache",
              "signature": "def hit_rate(self) -> float",
              "docstring": "Cache hit rate.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 79
            },
            {
              "name": "to_dict",
              "module": "risk_cache",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 84
            }
          ],
          "class_attributes": [
            {
              "name": "hits",
              "type": "int"
            },
            {
              "name": "misses",
              "type": "int"
            },
            {
              "name": "evictions",
              "type": "int"
            },
            {
              "name": "invalidations",
              "type": "int"
            },
            {
              "name": "total_entries",
              "type": "int"
            },
            {
              "name": "memory_bytes",
              "type": "int"
            },
            {
              "name": "avg_entry_age_seconds",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 68
        },
        {
          "name": "RiskMetricCache",
          "module": "risk_cache",
          "docstring": "Specialized cache for risk metrics (#R29).\n\nOptimized for:\n- VaR calculations\n- Correlation matrices\n- Greeks calculations\n- Stress test results",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_cache",
              "signature": "def __init__(self, max_entries: int, max_memory_bytes: int, default_ttl_seconds: float)",
              "docstring": "Initialize risk metric cache.\n\nArgs:\n    max_entries: Maximum number of cache entries\n    max_memory_bytes: Maximum memory usage\n    default_ttl_seconds: Default TTL for entries",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "max_entries",
                  "type": "int"
                },
                {
                  "name": "max_memory_bytes",
                  "type": "int"
                },
                {
                  "name": "default_ttl_seconds",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 121
            },
            {
              "name": "get",
              "module": "risk_cache",
              "signature": "def get(self, key: str)",
              "docstring": "Get value from cache.\n\nArgs:\n    key: Cache key\n\nReturns:\n    Cached value or None if not found/expired",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 144
            },
            {
              "name": "set",
              "module": "risk_cache",
              "signature": "def set(self, key: str, value: Any, ttl_seconds: , metric_type: , dependencies: ) -> None",
              "docstring": "Store value in cache.\n\nArgs:\n    key: Cache key\n    value: Value to cache\n    ttl_seconds: Time-to-live (uses type default or global default)\n    metric_type: Type of metric for TTL lookup\n    dependencies: Keys this entry depends on",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "Any"
                },
                {
                  "name": "ttl_seconds",
                  "type": ""
                },
                {
                  "name": "metric_type",
                  "type": ""
                },
                {
                  "name": "dependencies",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 174
            },
            {
              "name": "invalidate",
              "module": "risk_cache",
              "signature": "def invalidate(self, key: str, reason: CacheInvalidationReason) -> bool",
              "docstring": "Invalidate a cache entry.\n\nArgs:\n    key: Cache key\n    reason: Reason for invalidation\n\nReturns:\n    True if entry was removed",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "reason",
                  "type": "CacheInvalidationReason"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 230
            },
            {
              "name": "invalidate_dependency",
              "module": "risk_cache",
              "signature": "def invalidate_dependency(self, dependency_key: str) -> int",
              "docstring": "Invalidate all entries depending on a key.\n\nArgs:\n    dependency_key: The dependency that changed\n\nReturns:\n    Number of entries invalidated",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "dependency_key",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 253
            },
            {
              "name": "invalidate_by_type",
              "module": "risk_cache",
              "signature": "def invalidate_by_type(self, metric_type: str) -> int",
              "docstring": "Invalidate all entries of a specific metric type.\n\nArgs:\n    metric_type: Type prefix to match\n\nReturns:\n    Number of entries invalidated",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metric_type",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 279
            },
            {
              "name": "invalidate_all",
              "module": "risk_cache",
              "signature": "def invalidate_all(self) -> int",
              "docstring": "Invalidate all entries.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 301
            },
            {
              "name": "get_or_compute",
              "module": "risk_cache",
              "signature": "def get_or_compute(self, key: str, compute_fn: Callable[, T], ttl_seconds: , metric_type: , dependencies: ) -> T",
              "docstring": "Get from cache or compute and cache.\n\nArgs:\n    key: Cache key\n    compute_fn: Function to compute value if not cached\n    ttl_seconds: Time-to-live\n    metric_type: Type of metric\n    dependencies: Keys this entry depends on\n\nReturns:\n    Cached or computed value",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "compute_fn",
                  "type": "Callable[, T]"
                },
                {
                  "name": "ttl_seconds",
                  "type": ""
                },
                {
                  "name": "metric_type",
                  "type": ""
                },
                {
                  "name": "dependencies",
                  "type": ""
                }
              ],
              "return_type": "T",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 311
            },
            {
              "name": "_remove_entry",
              "module": "risk_cache",
              "signature": "def _remove_entry(self, key: str) -> None",
              "docstring": "Remove entry and clean up dependencies.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 350
            },
            {
              "name": "_ensure_capacity",
              "module": "risk_cache",
              "signature": "def _ensure_capacity(self, needed_bytes: int) -> None",
              "docstring": "Ensure cache has capacity for new entry.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "needed_bytes",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 365
            },
            {
              "name": "_evict_oldest",
              "module": "risk_cache",
              "signature": "def _evict_oldest(self)",
              "docstring": "Evict oldest (LRU) entry.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 380
            },
            {
              "name": "_estimate_size",
              "module": "risk_cache",
              "signature": "def _estimate_size(self, value: Any) -> int",
              "docstring": "Estimate memory size of value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "value",
                  "type": "Any"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 391
            },
            {
              "name": "get_stats",
              "module": "risk_cache",
              "signature": "def get_stats(self) -> CacheStats",
              "docstring": "Get cache statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "CacheStats",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 402
            },
            {
              "name": "warm_cache",
              "module": "risk_cache",
              "signature": "def warm_cache(self, warm_functions: list[tuple[str, Callable[, Any], ]]) -> int",
              "docstring": "Warm cache with precomputed values.\n\nArgs:\n    warm_functions: List of (key, compute_fn, metric_type) tuples\n\nReturns:\n    Number of entries warmed",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "warm_functions",
                  "type": "list[tuple[str, Callable[, Any], ]]"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 414
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 98
        },
        {
          "name": "PortfolioRiskCache",
          "module": "risk_cache",
          "docstring": "High-level cache manager for portfolio risk calculations.\n\nManages dependencies between different risk calculations.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_cache",
              "signature": "def __init__(self)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 528
            },
            {
              "name": "on_positions_changed",
              "module": "risk_cache",
              "signature": "def on_positions_changed(self, portfolio_id: str) -> None",
              "docstring": "Handle position change event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 539
            },
            {
              "name": "on_market_data_updated",
              "module": "risk_cache",
              "signature": "def on_market_data_updated(self, symbols: list[str]) -> None",
              "docstring": "Handle market data update event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbols",
                  "type": "list[str]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 544
            },
            {
              "name": "on_volatility_updated",
              "module": "risk_cache",
              "signature": "def on_volatility_updated(self, portfolio_id: str) -> None",
              "docstring": "Handle volatility update event.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_id",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 549
            },
            {
              "name": "get_var",
              "module": "risk_cache",
              "signature": "def get_var(self, portfolio_id: str, confidence: float, compute_fn: Callable[, float]) -> float",
              "docstring": "Get cached or computed VaR.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_id",
                  "type": "str"
                },
                {
                  "name": "confidence",
                  "type": "float"
                },
                {
                  "name": "compute_fn",
                  "type": "Callable[, float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 554
            },
            {
              "name": "get_correlation_matrix",
              "module": "risk_cache",
              "signature": "def get_correlation_matrix(self, portfolio_id: str, compute_fn: Callable[, Any]) -> Any",
              "docstring": "Get cached or computed correlation matrix.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_id",
                  "type": "str"
                },
                {
                  "name": "compute_fn",
                  "type": "Callable[, Any]"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 569
            },
            {
              "name": "get_greeks",
              "module": "risk_cache",
              "signature": "def get_greeks(self, position_id: str, compute_fn: Callable[, dict]) -> dict",
              "docstring": "Get cached or computed Greeks.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position_id",
                  "type": "str"
                },
                {
                  "name": "compute_fn",
                  "type": "Callable[, dict]"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 582
            },
            {
              "name": "get_stats",
              "module": "risk_cache",
              "signature": "def get_stats(self) -> dict",
              "docstring": "Get cache statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 595
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 521
        }
      ],
      "functions": [
        {
          "name": "cached_risk_metric",
          "module": "risk_cache",
          "signature": "def cached_risk_metric(cache: RiskMetricCache, metric_type: str, ttl_seconds: , key_fn: , dependencies_fn: )",
          "docstring": "Decorator for caching risk metric calculations.\n\nArgs:\n    cache: RiskMetricCache instance\n    metric_type: Type of metric for TTL lookup\n    ttl_seconds: Optional explicit TTL\n    key_fn: Function to generate cache key from args\n    dependencies_fn: Function to get dependencies from args\n\nExample:\n    @cached_risk_metric(cache, \"var\")\n    def calculate_var(portfolio_id, confidence):\n        # expensive calculation\n        return var_result",
          "parameters": [
            {
              "name": "cache",
              "type": "RiskMetricCache"
            },
            {
              "name": "metric_type",
              "type": "str"
            },
            {
              "name": "ttl_seconds",
              "type": ""
            },
            {
              "name": "key_fn",
              "type": ""
            },
            {
              "name": "dependencies_fn",
              "type": ""
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 440
        },
        {
          "name": "_generate_cache_key",
          "module": "risk_cache",
          "signature": "def _generate_cache_key(func_name: str, args: tuple, kwargs: dict) -> str",
          "docstring": "Generate cache key from function name and arguments.",
          "parameters": [
            {
              "name": "func_name",
              "type": "str"
            },
            {
              "name": "args",
              "type": "tuple"
            },
            {
              "name": "kwargs",
              "type": "dict"
            }
          ],
          "return_type": "str",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 502
        }
      ],
      "constants": [
        {
          "name": "T",
          "line": 31
        }
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "time",
        "threading",
        "functools",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "json"
      ],
      "dependencies": [
        "__future__",
        "hashlib",
        "time",
        "threading"
      ]
    },
    "core.risk_factors": {
      "name": "risk_factors",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\risk_factors.py",
      "docstring": "Risk Factor Decomposition Module\n================================\n\nRisk factor analysis and decomposition (Issue #R12).\n\nFeatures:\n- Multi-factor risk model (market, size, value, momentum, quality)\n- Factor exposure calculation\n- Risk contribution attribution\n- Factor covariance estimation\n- Systematic vs idiosyncratic risk separation",
      "classes": [
        {
          "name": "RiskFactor",
          "module": "risk_factors",
          "docstring": "Standard risk factors.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 29
        },
        {
          "name": "FactorExposure",
          "module": "risk_factors",
          "docstring": "Single factor exposure measurement.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "factor",
              "type": "RiskFactor"
            },
            {
              "name": "exposure",
              "type": "float"
            },
            {
              "name": "t_stat",
              "type": "float"
            },
            {
              "name": "contribution_pct",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 68
        },
        {
          "name": "PositionFactorExposures",
          "module": "risk_factors",
          "docstring": "Factor exposures for a single position.",
          "bases": [],
          "methods": [
            {
              "name": "get_exposure",
              "module": "risk_factors",
              "signature": "def get_exposure(self, factor: RiskFactor) -> float",
              "docstring": "Get exposure to a specific factor.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "factor",
                  "type": "RiskFactor"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 84
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "exposures",
              "type": "dict[RiskFactor, FactorExposure]"
            },
            {
              "name": "r_squared",
              "type": "float"
            },
            {
              "name": "idiosyncratic_vol",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 77
        },
        {
          "name": "PortfolioFactorDecomposition",
          "module": "risk_factors",
          "docstring": "Full portfolio factor decomposition.",
          "bases": [],
          "methods": [
            {
              "name": "get_systematic_pct",
              "module": "risk_factors",
              "signature": "def get_systematic_pct(self) -> float",
              "docstring": "Get percentage of risk that is systematic.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 104
            },
            {
              "name": "get_top_factors",
              "module": "risk_factors",
              "signature": "def get_top_factors(self, n: int) -> list[tuple[RiskFactor, float]]",
              "docstring": "Get top N factors by contribution.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n",
                  "type": "int"
                }
              ],
              "return_type": "list[tuple[RiskFactor, float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 110
            },
            {
              "name": "to_dict",
              "module": "risk_factors",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 119
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "total_variance",
              "type": "float"
            },
            {
              "name": "systematic_variance",
              "type": "float"
            },
            {
              "name": "idiosyncratic_variance",
              "type": "float"
            },
            {
              "name": "factor_exposures",
              "type": "dict[RiskFactor, float]"
            },
            {
              "name": "factor_contributions",
              "type": "dict[RiskFactor, float]"
            },
            {
              "name": "position_exposures",
              "type": "dict[str, PositionFactorExposures]"
            },
            {
              "name": "correlation_with_market",
              "type": "float"
            },
            {
              "name": "tracking_error",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 92
        },
        {
          "name": "FactorModel",
          "module": "risk_factors",
          "docstring": "Multi-factor risk model.\n\nImplements factor-based risk decomposition.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_factors",
              "signature": "def __init__(self, factors: , lookback_days: int, min_observations: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "factors",
                  "type": ""
                },
                {
                  "name": "lookback_days",
                  "type": "int"
                },
                {
                  "name": "min_observations",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 141
            },
            {
              "name": "update_factor_returns",
              "module": "risk_factors",
              "signature": "def update_factor_returns(self, factor_returns: dict[RiskFactor, float]) -> None",
              "docstring": "Update factor return history.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "factor_returns",
                  "type": "dict[RiskFactor, float]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 169
            },
            {
              "name": "update_position_returns",
              "module": "risk_factors",
              "signature": "def update_position_returns(self, position_returns: dict[str, float]) -> None",
              "docstring": "Update position return history.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "position_returns",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 181
            },
            {
              "name": "estimate_factor_covariance",
              "module": "risk_factors",
              "signature": "def estimate_factor_covariance(self) -> dict[tuple[RiskFactor, RiskFactor], float]",
              "docstring": "Estimate factor covariance matrix.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[tuple[RiskFactor, RiskFactor], float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 193
            },
            {
              "name": "calculate_position_exposures",
              "module": "risk_factors",
              "signature": "def calculate_position_exposures(self, symbol: str) -> PositionFactorExposures",
              "docstring": "Calculate factor exposures for a single position.\n\nUses OLS regression of position returns on factor returns.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "PositionFactorExposures",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 216
            },
            {
              "name": "decompose_portfolio",
              "module": "risk_factors",
              "signature": "def decompose_portfolio(self, positions: dict[str, float]) -> PortfolioFactorDecomposition",
              "docstring": "Decompose portfolio risk by factor.\n\nArgs:\n    positions: Dictionary of symbol to portfolio weight\n\nReturns:\n    PortfolioFactorDecomposition with full analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "PortfolioFactorDecomposition",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 284
            },
            {
              "name": "_calculate_portfolio_returns",
              "module": "risk_factors",
              "signature": "def _calculate_portfolio_returns(self, positions: dict[str, float]) -> list[float]",
              "docstring": "Calculate historical portfolio returns.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "list[float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 360
            },
            {
              "name": "_covariance",
              "module": "risk_factors",
              "signature": "def _covariance(self, x: list[float], y: list[float]) -> float",
              "docstring": "Calculate sample covariance.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "x",
                  "type": "list[float]"
                },
                {
                  "name": "y",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 382
            },
            {
              "name": "_variance",
              "module": "risk_factors",
              "signature": "def _variance(self, x: list[float]) -> float",
              "docstring": "Calculate sample variance.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "x",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 393
            },
            {
              "name": "_correlation",
              "module": "risk_factors",
              "signature": "def _correlation(self, x: list[float], y: list[float]) -> float",
              "docstring": "Calculate Pearson correlation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "x",
                  "type": "list[float]"
                },
                {
                  "name": "y",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 399
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 134
        },
        {
          "name": "RiskContribution",
          "module": "risk_factors",
          "docstring": "Risk contribution by source.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "source",
              "type": "str"
            },
            {
              "name": "absolute_var",
              "type": "float"
            },
            {
              "name": "marginal_var",
              "type": "float"
            },
            {
              "name": "percent_of_total",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 415
        },
        {
          "name": "RiskContributionAnalyzer",
          "module": "risk_factors",
          "docstring": "Analyzes risk contributions from different sources.\n\nSupports position-level, factor-level, and strategy-level attribution.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_factors",
              "signature": "def __init__(self, factor_model: FactorModel)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "factor_model",
                  "type": "FactorModel"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 430
            },
            {
              "name": "analyze_position_contributions",
              "module": "risk_factors",
              "signature": "def analyze_position_contributions(self, positions: dict[str, float], position_vols: dict[str, float], correlation_matrix: dict[tuple[str, str], float]) -> list[RiskContribution]",
              "docstring": "Analyze risk contribution by position.\n\nUses Euler decomposition for additive risk attribution.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "position_vols",
                  "type": "dict[str, float]"
                },
                {
                  "name": "correlation_matrix",
                  "type": "dict[tuple[str, str], float]"
                }
              ],
              "return_type": "list[RiskContribution]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 433
            },
            {
              "name": "analyze_factor_contributions",
              "module": "risk_factors",
              "signature": "def analyze_factor_contributions(self, decomposition: PortfolioFactorDecomposition) -> list[RiskContribution]",
              "docstring": "Analyze risk contribution by factor.\n\nBased on factor decomposition results.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "decomposition",
                  "type": "PortfolioFactorDecomposition"
                }
              ],
              "return_type": "list[RiskContribution]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 499
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 423
        },
        {
          "name": "FactorTilt",
          "module": "risk_factors",
          "docstring": "Intentional factor tilt relative to benchmark.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "factor",
              "type": "RiskFactor"
            },
            {
              "name": "portfolio_exposure",
              "type": "float"
            },
            {
              "name": "benchmark_exposure",
              "type": "float"
            },
            {
              "name": "active_exposure",
              "type": "float"
            },
            {
              "name": "contribution_to_te",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 537
        },
        {
          "name": "ActiveRiskDecomposer",
          "module": "risk_factors",
          "docstring": "Decomposes active risk (tracking error) by factor.\n\nUseful for understanding sources of benchmark-relative risk.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_factors",
              "signature": "def __init__(self, factor_model: FactorModel)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "factor_model",
                  "type": "FactorModel"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 553
            },
            {
              "name": "decompose_active_risk",
              "module": "risk_factors",
              "signature": "def decompose_active_risk(self, portfolio_positions: dict[str, float], benchmark_positions: dict[str, float]) -> tuple[float, list[FactorTilt]]",
              "docstring": "Decompose tracking error by factor tilt.\n\nReturns:\n    - Tracking error (annualized volatility)\n    - List of factor tilts with contributions",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "benchmark_positions",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "tuple[float, list[FactorTilt]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 556
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 546
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.risk_reports": {
      "name": "risk_reports",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\risk_reports.py",
      "docstring": "Risk Report Generation Module\n=============================\n\nAutomated risk report generation (Issue #R25).\n\nFeatures:\n- Daily risk summary reports\n- Position risk breakdown\n- VaR/CVaR analysis\n- Greeks exposure reports\n- Limit utilization tracking\n- Stress test summaries\n- Export to multiple formats (JSON, CSV, HTML)",
      "classes": [
        {
          "name": "ReportType",
          "module": "risk_reports",
          "docstring": "Type of risk report.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 32
        },
        {
          "name": "ReportFormat",
          "module": "risk_reports",
          "docstring": "Output format for reports.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 44
        },
        {
          "name": "ReportSection",
          "module": "risk_reports",
          "docstring": "A section within a report.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "data",
              "type": ""
            },
            {
              "name": "summary",
              "type": "str"
            },
            {
              "name": "alerts",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 53
        },
        {
          "name": "RiskReport",
          "module": "risk_reports",
          "docstring": "Complete risk report.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "risk_reports",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 73
            },
            {
              "name": "add_section",
              "module": "risk_reports",
              "signature": "def add_section(self, section: ReportSection) -> None",
              "docstring": "Add a section to the report.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "section",
                  "type": "ReportSection"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 94
            }
          ],
          "class_attributes": [
            {
              "name": "report_id",
              "type": "str"
            },
            {
              "name": "report_type",
              "type": "ReportType"
            },
            {
              "name": "generated_at",
              "type": "datetime"
            },
            {
              "name": "as_of_date",
              "type": "datetime"
            },
            {
              "name": "title",
              "type": "str"
            },
            {
              "name": "sections",
              "type": "list[ReportSection]"
            },
            {
              "name": "metadata",
              "type": "dict"
            },
            {
              "name": "alerts",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 62
        },
        {
          "name": "RiskReportGenerator",
          "module": "risk_reports",
          "docstring": "Generates various risk reports (#R25).\n\nProvides comprehensive risk reporting for compliance and monitoring.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_reports",
              "signature": "def __init__(self, output_dir: str, firm_name: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "output_dir",
                  "type": "str"
                },
                {
                  "name": "firm_name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 107
            },
            {
              "name": "_generate_report_id",
              "module": "risk_reports",
              "signature": "def _generate_report_id(self, report_type: ReportType) -> str",
              "docstring": "Generate unique report ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report_type",
                  "type": "ReportType"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 117
            },
            {
              "name": "generate_daily_summary",
              "module": "risk_reports",
              "signature": "def generate_daily_summary(self, risk_state: Any, positions: dict[str, Any], var_results: , stress_results: ) -> RiskReport",
              "docstring": "Generate daily risk summary report.\n\nComprehensive overview of portfolio risk for the day.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "risk_state",
                  "type": "Any"
                },
                {
                  "name": "positions",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "var_results",
                  "type": ""
                },
                {
                  "name": "stress_results",
                  "type": ""
                }
              ],
              "return_type": "RiskReport",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 123
            },
            {
              "name": "generate_position_risk_report",
              "module": "risk_reports",
              "signature": "def generate_position_risk_report(self, positions: dict[str, Any], risk_contributions: ) -> RiskReport",
              "docstring": "Generate detailed position risk breakdown report.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "risk_contributions",
                  "type": ""
                }
              ],
              "return_type": "RiskReport",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 276
            },
            {
              "name": "generate_limit_utilization_report",
              "module": "risk_reports",
              "signature": "def generate_limit_utilization_report(self, current_values: dict[str, float], limits: dict[str, float]) -> RiskReport",
              "docstring": "Generate limit utilization report.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_values",
                  "type": "dict[str, float]"
                },
                {
                  "name": "limits",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "RiskReport",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 315
            },
            {
              "name": "_calculate_concentration",
              "module": "risk_reports",
              "signature": "def _calculate_concentration(self, positions: dict[str, Any], total_value: float) -> dict",
              "docstring": "Calculate position concentration metrics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "total_value",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 361
            },
            {
              "name": "export_report",
              "module": "risk_reports",
              "signature": "def export_report(self, report: RiskReport, format: ReportFormat, filename: ) -> str",
              "docstring": "Export report to file.\n\nReturns the filepath of the exported report.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report",
                  "type": "RiskReport"
                },
                {
                  "name": "format",
                  "type": "ReportFormat"
                },
                {
                  "name": "filename",
                  "type": ""
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 409
            },
            {
              "name": "_export_csv",
              "module": "risk_reports",
              "signature": "def _export_csv(self, report: RiskReport, filepath: Path) -> None",
              "docstring": "Export report to CSV.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report",
                  "type": "RiskReport"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 441
            },
            {
              "name": "_export_html",
              "module": "risk_reports",
              "signature": "def _export_html(self, report: RiskReport, filepath: Path) -> None",
              "docstring": "Export report to HTML.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report",
                  "type": "RiskReport"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 469
            },
            {
              "name": "_export_text",
              "module": "risk_reports",
              "signature": "def _export_text(self, report: RiskReport, filepath: Path) -> None",
              "docstring": "Export report to plain text.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "report",
                  "type": "RiskReport"
                },
                {
                  "name": "filepath",
                  "type": "Path"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 531
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 100
        },
        {
          "name": "ScheduledReportManager",
          "module": "risk_reports",
          "docstring": "Manages scheduled report generation.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "risk_reports",
              "signature": "def __init__(self, generator: RiskReportGenerator)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "generator",
                  "type": "RiskReportGenerator"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 571
            },
            {
              "name": "should_generate_daily_report",
              "module": "risk_reports",
              "signature": "def should_generate_daily_report(self) -> bool",
              "docstring": "Check if daily report should be generated.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 575
            },
            {
              "name": "mark_daily_report_generated",
              "module": "risk_reports",
              "signature": "def mark_daily_report_generated(self) -> None",
              "docstring": "Mark that daily report was generated.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 585
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 568
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "csv",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing",
        "io"
      ],
      "dependencies": [
        "__future__",
        "csv",
        "io"
      ]
    },
    "core.scenario_analysis": {
      "name": "scenario_analysis",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\scenario_analysis.py",
      "docstring": "Scenario Analysis Module\n========================\n\nWorst-case scenario reporting (Issue #R17).\nHistorical stress event playback (Issue #R18).\nWhat-if analysis support (Issue #P16).\n\nFeatures:\n- Historical crisis replay\n- Custom scenario definition\n- What-if position changes\n- Worst-case scenario identification",
      "classes": [
        {
          "name": "HistoricalEvent",
          "module": "scenario_analysis",
          "docstring": "Notable historical market events for stress testing.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 28
        },
        {
          "name": "AssetShock",
          "module": "scenario_analysis",
          "docstring": "Price/factor shock for an asset class.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "asset_class",
              "type": "str"
            },
            {
              "name": "price_change_pct",
              "type": "float"
            },
            {
              "name": "volatility_multiplier",
              "type": "float"
            },
            {
              "name": "correlation_shift",
              "type": "float"
            },
            {
              "name": "duration_days",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 46
        },
        {
          "name": "ScenarioDefinition",
          "module": "scenario_analysis",
          "docstring": "Definition of a market scenario.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "scenario_analysis",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 70
            }
          ],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "shocks",
              "type": "list[AssetShock]"
            },
            {
              "name": "event_date",
              "type": ""
            },
            {
              "name": "duration_days",
              "type": "int"
            },
            {
              "name": "is_historical",
              "type": "bool"
            },
            {
              "name": "interest_rate_change_bps",
              "type": "float"
            },
            {
              "name": "vix_level",
              "type": ""
            },
            {
              "name": "credit_spread_change_bps",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 56
        },
        {
          "name": "PositionImpact",
          "module": "scenario_analysis",
          "docstring": "Impact of scenario on a single position.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "scenario_analysis",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 103
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "current_value",
              "type": "float"
            },
            {
              "name": "stressed_value",
              "type": "float"
            },
            {
              "name": "pnl",
              "type": "float"
            },
            {
              "name": "pnl_pct",
              "type": "float"
            },
            {
              "name": "contribution_to_total",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 93
        },
        {
          "name": "ScenarioResult",
          "module": "scenario_analysis",
          "docstring": "Result of running a scenario.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "scenario_analysis",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 139
            }
          ],
          "class_attributes": [
            {
              "name": "scenario_name",
              "type": "str"
            },
            {
              "name": "run_timestamp",
              "type": "datetime"
            },
            {
              "name": "portfolio_value_before",
              "type": "float"
            },
            {
              "name": "portfolio_value_after",
              "type": "float"
            },
            {
              "name": "total_pnl",
              "type": "float"
            },
            {
              "name": "total_pnl_pct",
              "type": "float"
            },
            {
              "name": "position_impacts",
              "type": "list[PositionImpact]"
            },
            {
              "name": "var_under_scenario",
              "type": ""
            },
            {
              "name": "margin_call_triggered",
              "type": "bool"
            },
            {
              "name": "margin_shortfall",
              "type": "float"
            },
            {
              "name": "worst_position",
              "type": "str"
            },
            {
              "name": "worst_position_pnl_pct",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 116
        },
        {
          "name": "WhatIfResult",
          "module": "scenario_analysis",
          "docstring": "Result of what-if analysis (#P16).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "scenario_analysis",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 174
            }
          ],
          "class_attributes": [
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "position_changes",
              "type": "dict[str, int]"
            },
            {
              "name": "metrics_before",
              "type": "dict"
            },
            {
              "name": "metrics_after",
              "type": "dict"
            },
            {
              "name": "pnl_impact",
              "type": "float"
            },
            {
              "name": "var_impact",
              "type": "float"
            },
            {
              "name": "margin_impact",
              "type": "float"
            },
            {
              "name": "exposure_change",
              "type": "dict"
            },
            {
              "name": "recommendation",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 157
        },
        {
          "name": "HistoricalEventLibrary",
          "module": "scenario_analysis",
          "docstring": "Library of historical market events for stress testing (#R18).\n\nContains calibrated shocks based on actual market moves.",
          "bases": [],
          "methods": [
            {
              "name": "get_event",
              "module": "scenario_analysis",
              "signature": "def get_event(cls, event: HistoricalEvent) -> ScenarioDefinition",
              "docstring": "Get scenario definition for a historical event.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "event",
                  "type": "HistoricalEvent"
                }
              ],
              "return_type": "ScenarioDefinition",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 320
            },
            {
              "name": "get_all_events",
              "module": "scenario_analysis",
              "signature": "def get_all_events(cls) -> list[ScenarioDefinition]",
              "docstring": "Get all historical event scenarios.",
              "parameters": [
                {
                  "name": "cls"
                }
              ],
              "return_type": "list[ScenarioDefinition]",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 325
            },
            {
              "name": "get_events_by_severity",
              "module": "scenario_analysis",
              "signature": "def get_events_by_severity(cls, min_equity_drop: float) -> list[ScenarioDefinition]",
              "docstring": "Get events with equity drop worse than threshold.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "min_equity_drop",
                  "type": "float"
                }
              ],
              "return_type": "list[ScenarioDefinition]",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 330
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 188
        },
        {
          "name": "ScenarioEngine",
          "module": "scenario_analysis",
          "docstring": "Runs scenario analysis on portfolios (#R17, #R18).\n\nSupports both historical replay and custom scenarios.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "scenario_analysis",
              "signature": "def __init__(self, margin_requirement_pct: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "margin_requirement_pct",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 350
            },
            {
              "name": "update_position",
              "module": "scenario_analysis",
              "signature": "def update_position(self, symbol: str, quantity: int, price: float, asset_class: str) -> None",
              "docstring": "Update position for scenario analysis.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "asset_class",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 368
            },
            {
              "name": "add_custom_scenario",
              "module": "scenario_analysis",
              "signature": "def add_custom_scenario(self, scenario: ScenarioDefinition) -> None",
              "docstring": "Add a custom scenario.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario",
                  "type": "ScenarioDefinition"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 383
            },
            {
              "name": "run_scenario",
              "module": "scenario_analysis",
              "signature": "def run_scenario(self, scenario: ScenarioDefinition, account_equity: ) -> ScenarioResult",
              "docstring": "Run a scenario on the current portfolio.\n\nArgs:\n    scenario: Scenario to run\n    account_equity: Account equity for margin calculations\n\nReturns:\n    ScenarioResult with detailed impact",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario",
                  "type": "ScenarioDefinition"
                },
                {
                  "name": "account_equity",
                  "type": ""
                }
              ],
              "return_type": "ScenarioResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 387
            },
            {
              "name": "run_historical_event",
              "module": "scenario_analysis",
              "signature": "def run_historical_event(self, event: HistoricalEvent, account_equity: ) -> ScenarioResult",
              "docstring": "Run a historical event scenario.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "HistoricalEvent"
                },
                {
                  "name": "account_equity",
                  "type": ""
                }
              ],
              "return_type": "ScenarioResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 482
            },
            {
              "name": "run_all_historical_events",
              "module": "scenario_analysis",
              "signature": "def run_all_historical_events(self, account_equity: ) -> list[ScenarioResult]",
              "docstring": "Run all historical event scenarios.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_equity",
                  "type": ""
                }
              ],
              "return_type": "list[ScenarioResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 493
            },
            {
              "name": "find_worst_case",
              "module": "scenario_analysis",
              "signature": "def find_worst_case(self, account_equity: ) -> ScenarioResult",
              "docstring": "Find the worst-case scenario from all available (#R17).\n\nRuns all scenarios and returns the one with worst P&L.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_equity",
                  "type": ""
                }
              ],
              "return_type": "ScenarioResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 507
            },
            {
              "name": "generate_worst_case_report",
              "module": "scenario_analysis",
              "signature": "def generate_worst_case_report(self, account_equity: float, include_top_n: int) -> dict",
              "docstring": "Generate comprehensive worst-case report (#R17).\n\nReturns top N worst scenarios with detailed analysis.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_equity",
                  "type": "float"
                },
                {
                  "name": "include_top_n",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 529
            },
            {
              "name": "_identify_vulnerable_positions",
              "module": "scenario_analysis",
              "signature": "def _identify_vulnerable_positions(self, worst_results: list[ScenarioResult]) -> list[dict]",
              "docstring": "Identify positions that appear frequently in worst scenarios.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "worst_results",
                  "type": "list[ScenarioResult]"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 566
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 343
        },
        {
          "name": "WhatIfAnalyzer",
          "module": "scenario_analysis",
          "docstring": "What-if analysis for position changes (#P16).\n\nAllows testing hypothetical portfolio changes.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "scenario_analysis",
              "signature": "def __init__(self, scenario_engine: ScenarioEngine, margin_calc: , var_calc: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario_engine",
                  "type": "ScenarioEngine"
                },
                {
                  "name": "margin_calc",
                  "type": ""
                },
                {
                  "name": "var_calc",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 602
            },
            {
              "name": "_default_margin_calc",
              "module": "scenario_analysis",
              "signature": "def _default_margin_calc(self, positions: dict) -> float",
              "docstring": "Default margin calculation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 612
            },
            {
              "name": "_default_var_calc",
              "module": "scenario_analysis",
              "signature": "def _default_var_calc(self, positions: dict) -> float",
              "docstring": "Default VaR calculation (simplified).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 620
            },
            {
              "name": "analyze_position_change",
              "module": "scenario_analysis",
              "signature": "def analyze_position_change(self, symbol: str, quantity_change: int, price: , asset_class: str) -> WhatIfResult",
              "docstring": "Analyze impact of changing a single position.\n\nArgs:\n    symbol: Symbol to change\n    quantity_change: Change in quantity (positive = buy, negative = sell)\n    price: Current price (uses existing if not provided)\n    asset_class: Asset class for new positions\n\nReturns:\n    WhatIfResult with before/after comparison",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity_change",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": ""
                },
                {
                  "name": "asset_class",
                  "type": "str"
                }
              ],
              "return_type": "WhatIfResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 628
            },
            {
              "name": "analyze_multiple_changes",
              "module": "scenario_analysis",
              "signature": "def analyze_multiple_changes(self, changes: dict[str, dict]) -> WhatIfResult",
              "docstring": "Analyze impact of multiple position changes.\n\nArgs:\n    changes: Dict of symbol -> {quantity_change, price, asset_class}\n\nReturns:\n    WhatIfResult with aggregate impact",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "changes",
                  "type": "dict[str, dict]"
                }
              ],
              "return_type": "WhatIfResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 725
            },
            {
              "name": "find_optimal_hedge",
              "module": "scenario_analysis",
              "signature": "def find_optimal_hedge(self, target_symbol: str, hedge_candidates: list[str], target_var_reduction_pct: float) -> list[WhatIfResult]",
              "docstring": "Find optimal hedge for a position.\n\nTests various hedge ratios and returns best options.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "target_symbol",
                  "type": "str"
                },
                {
                  "name": "hedge_candidates",
                  "type": "list[str]"
                },
                {
                  "name": "target_var_reduction_pct",
                  "type": "float"
                }
              ],
              "return_type": "list[WhatIfResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 816
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 595
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.signal_decay": {
      "name": "signal_decay",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\signal_decay.py",
      "docstring": "Signal Decay/Half-Life Module\n=============================\n\nModels signal strength decay over time (Issue #Q18).\n\nFeatures:\n- Exponential decay modeling\n- Half-life calculation and calibration\n- Signal freshness scoring\n- Multi-timeframe decay\n- Historical decay analysis",
      "classes": [
        {
          "name": "DecayModel",
          "module": "signal_decay",
          "docstring": "Signal decay model types.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 28
        },
        {
          "name": "SignalDecayConfig",
          "module": "signal_decay",
          "docstring": "Configuration for signal decay.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "model",
              "type": "DecayModel"
            },
            {
              "name": "half_life_minutes",
              "type": "float"
            },
            {
              "name": "min_strength",
              "type": "float"
            },
            {
              "name": "max_age_minutes",
              "type": "float"
            },
            {
              "name": "refresh_on_confirmation",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 38
        },
        {
          "name": "DecayedSignal",
          "module": "signal_decay",
          "docstring": "Signal with decay tracking.",
          "bases": [],
          "methods": [
            {
              "name": "age_minutes",
              "module": "signal_decay",
              "signature": "def age_minutes(self) -> float",
              "docstring": "Get signal age in minutes.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 62
            },
            {
              "name": "freshness_score",
              "module": "signal_decay",
              "signature": "def freshness_score(self) -> float",
              "docstring": "Get freshness score (0-1, higher is fresher).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 68
            },
            {
              "name": "is_expired",
              "module": "signal_decay",
              "signature": "def is_expired(self) -> bool",
              "docstring": "Check if signal has expired.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 73
            },
            {
              "name": "to_dict",
              "module": "signal_decay",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 80
            }
          ],
          "class_attributes": [
            {
              "name": "signal_id",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "direction",
              "type": "str"
            },
            {
              "name": "original_strength",
              "type": "float"
            },
            {
              "name": "current_strength",
              "type": "float"
            },
            {
              "name": "created_at",
              "type": "datetime"
            },
            {
              "name": "last_updated",
              "type": "datetime"
            },
            {
              "name": "source_strategy",
              "type": "str"
            },
            {
              "name": "decay_config",
              "type": "SignalDecayConfig"
            },
            {
              "name": "metadata",
              "type": "dict"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 48
        },
        {
          "name": "SignalDecayCalculator",
          "module": "signal_decay",
          "docstring": "Calculates signal decay based on various models (#Q18).\n\nSupports multiple decay models for different signal types.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "signal_decay",
              "signature": "def __init__(self, default_config: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "default_config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 104
            },
            {
              "name": "calculate_decay",
              "module": "signal_decay",
              "signature": "def calculate_decay(self, original_strength: float, age_minutes: float, config: ) -> float",
              "docstring": "Calculate decayed signal strength.\n\nArgs:\n    original_strength: Initial signal strength (0-1)\n    age_minutes: Signal age in minutes\n    config: Decay configuration\n\nReturns:\n    Decayed strength (0-1)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "original_strength",
                  "type": "float"
                },
                {
                  "name": "age_minutes",
                  "type": "float"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 107
            },
            {
              "name": "_exponential_decay",
              "module": "signal_decay",
              "signature": "def _exponential_decay(self, strength: float, age_minutes: float, half_life_minutes: float) -> float",
              "docstring": "Exponential decay: S(t) = S0 * exp(-\u03bbt)\n\nWhere \u03bb = ln(2) / half_life",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strength",
                  "type": "float"
                },
                {
                  "name": "age_minutes",
                  "type": "float"
                },
                {
                  "name": "half_life_minutes",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 147
            },
            {
              "name": "_linear_decay",
              "module": "signal_decay",
              "signature": "def _linear_decay(self, strength: float, age_minutes: float, max_age_minutes: float) -> float",
              "docstring": "Linear decay from strength to 0 over max_age.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strength",
                  "type": "float"
                },
                {
                  "name": "age_minutes",
                  "type": "float"
                },
                {
                  "name": "max_age_minutes",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 164
            },
            {
              "name": "_step_decay",
              "module": "signal_decay",
              "signature": "def _step_decay(self, strength: float, age_minutes: float, threshold_minutes: float) -> float",
              "docstring": "Step function: full strength until threshold, then zero.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strength",
                  "type": "float"
                },
                {
                  "name": "age_minutes",
                  "type": "float"
                },
                {
                  "name": "threshold_minutes",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 177
            },
            {
              "name": "_power_decay",
              "module": "signal_decay",
              "signature": "def _power_decay(self, strength: float, age_minutes: float, half_life_minutes: float, power: float) -> float",
              "docstring": "Power law decay: S(t) = S0 / (1 + (t/\u03c4)^\u03b1)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strength",
                  "type": "float"
                },
                {
                  "name": "age_minutes",
                  "type": "float"
                },
                {
                  "name": "half_life_minutes",
                  "type": "float"
                },
                {
                  "name": "power",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 186
            },
            {
              "name": "estimate_half_life",
              "module": "signal_decay",
              "signature": "def estimate_half_life(self, signal_history: list[tuple[float, float]]) -> float",
              "docstring": "Estimate half-life from historical signal performance.\n\nUses regression to fit exponential decay curve.\n\nArgs:\n    signal_history: List of (age, observed_strength) pairs\n\nReturns:\n    Estimated half-life in minutes",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signal_history",
                  "type": "list[tuple[float, float]]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 199
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 97
        },
        {
          "name": "SignalDecayManager",
          "module": "signal_decay",
          "docstring": "Manages signal decay for multiple signals (#Q18).\n\nTracks active signals and applies decay over time.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "signal_decay",
              "signature": "def __init__(self, calculator: , cleanup_interval_minutes: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "calculator",
                  "type": ""
                },
                {
                  "name": "cleanup_interval_minutes",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 256
            },
            {
              "name": "add_signal",
              "module": "signal_decay",
              "signature": "def add_signal(self, symbol: str, direction: str, strength: float, source_strategy: str, config: , metadata: ) -> DecayedSignal",
              "docstring": "Add a new signal to track.\n\nArgs:\n    symbol: Trading symbol\n    direction: 'LONG', 'SHORT', or 'NEUTRAL'\n    strength: Signal strength (0-1)\n    source_strategy: Strategy that generated the signal\n    config: Optional decay configuration\n    metadata: Additional signal metadata\n\nReturns:\n    The created DecayedSignal",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "direction",
                  "type": "str"
                },
                {
                  "name": "strength",
                  "type": "float"
                },
                {
                  "name": "source_strategy",
                  "type": "str"
                },
                {
                  "name": "config",
                  "type": ""
                },
                {
                  "name": "metadata",
                  "type": ""
                }
              ],
              "return_type": "DecayedSignal",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 272
            },
            {
              "name": "update_signal",
              "module": "signal_decay",
              "signature": "def update_signal(self, signal_id: str, new_strength: , refresh: bool)",
              "docstring": "Update an existing signal.\n\nArgs:\n    signal_id: Signal to update\n    new_strength: Optional new strength value\n    refresh: If True, reset decay timer\n\nReturns:\n    Updated signal or None if not found",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signal_id",
                  "type": "str"
                },
                {
                  "name": "new_strength",
                  "type": ""
                },
                {
                  "name": "refresh",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 323
            },
            {
              "name": "get_signal",
              "module": "signal_decay",
              "signature": "def get_signal(self, signal_id: str)",
              "docstring": "Get a specific signal by ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signal_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 355
            },
            {
              "name": "get_signals_for_symbol",
              "module": "signal_decay",
              "signature": "def get_signals_for_symbol(self, symbol: str, include_expired: bool) -> list[DecayedSignal]",
              "docstring": "Get all signals for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "include_expired",
                  "type": "bool"
                }
              ],
              "return_type": "list[DecayedSignal]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 363
            },
            {
              "name": "get_aggregate_signal",
              "module": "signal_decay",
              "signature": "def get_aggregate_signal(self, symbol: str) -> dict",
              "docstring": "Get aggregated signal for a symbol.\n\nCombines multiple signals with decay-weighted averaging.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 378
            },
            {
              "name": "_apply_decay",
              "module": "signal_decay",
              "signature": "def _apply_decay(self) -> None",
              "docstring": "Apply decay to all signals.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 429
            },
            {
              "name": "cleanup_expired",
              "module": "signal_decay",
              "signature": "def cleanup_expired(self) -> int",
              "docstring": "Remove expired signals.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 443
            },
            {
              "name": "record_signal_performance",
              "module": "signal_decay",
              "signature": "def record_signal_performance(self, strategy: str, age_at_action: float, effectiveness: float) -> None",
              "docstring": "Record signal performance for half-life calibration.\n\nArgs:\n    strategy: Strategy that generated the signal\n    age_at_action: Age of signal when action was taken (minutes)\n    effectiveness: How effective the signal was (0-1)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                },
                {
                  "name": "age_at_action",
                  "type": "float"
                },
                {
                  "name": "effectiveness",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 468
            },
            {
              "name": "calibrate_half_life",
              "module": "signal_decay",
              "signature": "def calibrate_half_life(self, strategy: str) -> float",
              "docstring": "Calibrate half-life for a strategy based on historical performance.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 487
            },
            {
              "name": "get_statistics",
              "module": "signal_decay",
              "signature": "def get_statistics(self) -> dict",
              "docstring": "Get signal manager statistics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 496
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 249
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.signal_validation": {
      "name": "signal_validation",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\signal_validation.py",
      "docstring": "Signal Validation Module\n========================\n\nMean reversion signal validation (Issue #Q16).\nSpread ratio validation for stat arb (Issue #Q17).\n\nFeatures:\n- Mean reversion signal quality checks\n- Spread ratio statistical validation\n- Signal confidence scoring\n- Historical performance validation",
      "classes": [
        {
          "name": "ValidationResult",
          "module": "signal_validation",
          "docstring": "Signal validation result.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 28
        },
        {
          "name": "MeanReversionValidation",
          "module": "signal_validation",
          "docstring": "Mean reversion signal validation result (#Q16).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "signal_validation",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 66
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "signal_direction",
              "type": "str"
            },
            {
              "name": "signal_strength",
              "type": "float"
            },
            {
              "name": "stationarity_test_passed",
              "type": "bool"
            },
            {
              "name": "adf_statistic",
              "type": "float"
            },
            {
              "name": "adf_pvalue",
              "type": "float"
            },
            {
              "name": "half_life_days",
              "type": "float"
            },
            {
              "name": "half_life_valid",
              "type": "bool"
            },
            {
              "name": "current_zscore",
              "type": "float"
            },
            {
              "name": "zscore_extreme",
              "type": "bool"
            },
            {
              "name": "hurst_exponent",
              "type": "float"
            },
            {
              "name": "hurst_valid",
              "type": "bool"
            },
            {
              "name": "support_resistance_confirmed",
              "type": "bool"
            },
            {
              "name": "volume_confirmation",
              "type": "bool"
            },
            {
              "name": "result",
              "type": "ValidationResult"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "rejection_reasons",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 37
        },
        {
          "name": "SpreadRatioValidation",
          "module": "signal_validation",
          "docstring": "Spread ratio validation for stat arb (#Q17).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "signal_validation",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 124
            }
          ],
          "class_attributes": [
            {
              "name": "symbol1",
              "type": "str"
            },
            {
              "name": "symbol2",
              "type": "str"
            },
            {
              "name": "current_spread",
              "type": "float"
            },
            {
              "name": "spread_mean",
              "type": "float"
            },
            {
              "name": "spread_std",
              "type": "float"
            },
            {
              "name": "current_zscore",
              "type": "float"
            },
            {
              "name": "is_cointegrated",
              "type": "bool"
            },
            {
              "name": "cointegration_pvalue",
              "type": "float"
            },
            {
              "name": "hedge_ratio",
              "type": "float"
            },
            {
              "name": "hedge_ratio_stable",
              "type": "bool"
            },
            {
              "name": "hedge_ratio_std",
              "type": "float"
            },
            {
              "name": "spread_half_life_days",
              "type": "float"
            },
            {
              "name": "half_life_acceptable",
              "type": "bool"
            },
            {
              "name": "correlation",
              "type": "float"
            },
            {
              "name": "correlation_stable",
              "type": "bool"
            },
            {
              "name": "is_beta_neutral",
              "type": "bool"
            },
            {
              "name": "net_beta",
              "type": "float"
            },
            {
              "name": "result",
              "type": "ValidationResult"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "warnings",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 87
        },
        {
          "name": "MeanReversionValidator",
          "module": "signal_validation",
          "docstring": "Validates mean reversion signals (#Q16).\n\nEnsures signals have statistical support before trading.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "signal_validation",
              "signature": "def __init__(self, min_adf_confidence: float, max_half_life_days: float, min_half_life_days: float, max_hurst_exponent: float, zscore_entry_threshold: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "min_adf_confidence",
                  "type": "float"
                },
                {
                  "name": "max_half_life_days",
                  "type": "float"
                },
                {
                  "name": "min_half_life_days",
                  "type": "float"
                },
                {
                  "name": "max_hurst_exponent",
                  "type": "float"
                },
                {
                  "name": "zscore_entry_threshold",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 153
            },
            {
              "name": "update_price",
              "module": "signal_validation",
              "signature": "def update_price(self, symbol: str, price: float, volume: int) -> None",
              "docstring": "Update price history for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "volume",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 171
            },
            {
              "name": "validate_signal",
              "module": "signal_validation",
              "signature": "def validate_signal(self, symbol: str, direction: str, strength: float, current_price: ) -> MeanReversionValidation",
              "docstring": "Validate a mean reversion signal.\n\nArgs:\n    symbol: Trading symbol\n    direction: 'LONG' (expecting price to rise) or 'SHORT'\n    strength: Signal strength (0-1)\n    current_price: Optional current price\n\nReturns:\n    MeanReversionValidation with detailed checks",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "direction",
                  "type": "str"
                },
                {
                  "name": "strength",
                  "type": "float"
                },
                {
                  "name": "current_price",
                  "type": ""
                }
              ],
              "return_type": "MeanReversionValidation",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 180
            },
            {
              "name": "_adf_test",
              "module": "signal_validation",
              "signature": "def _adf_test(self, prices: list[float]) -> tuple[float, float]",
              "docstring": "Augmented Dickey-Fuller test for stationarity.\n\nReturns (test_statistic, p_value)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "list[float]"
                }
              ],
              "return_type": "tuple[float, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 307
            },
            {
              "name": "_estimate_half_life",
              "module": "signal_validation",
              "signature": "def _estimate_half_life(self, prices: list[float]) -> float",
              "docstring": "Estimate mean reversion half-life using OLS.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 359
            },
            {
              "name": "_estimate_hurst",
              "module": "signal_validation",
              "signature": "def _estimate_hurst(self, prices: list[float]) -> float",
              "docstring": "Estimate Hurst exponent using R/S analysis.\n\nH < 0.5: mean reverting\nH = 0.5: random walk\nH > 0.5: trending",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 399
            },
            {
              "name": "_check_support_resistance",
              "module": "signal_validation",
              "signature": "def _check_support_resistance(self, prices: list[float], current: float, direction: str) -> bool",
              "docstring": "Check if price is near support (LONG) or resistance (SHORT).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "list[float]"
                },
                {
                  "name": "current",
                  "type": "float"
                },
                {
                  "name": "direction",
                  "type": "str"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 474
            },
            {
              "name": "_check_volume_confirmation",
              "module": "signal_validation",
              "signature": "def _check_volume_confirmation(self, volumes: list[int]) -> bool",
              "docstring": "Check if volume confirms signal (above average).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "volumes",
                  "type": "list[int]"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 501
            },
            {
              "name": "_calculate_confidence",
              "module": "signal_validation",
              "signature": "def _calculate_confidence(self, stationarity: bool, half_life: bool, zscore: bool, hurst: bool, support_resistance: bool, volume: bool) -> float",
              "docstring": "Calculate overall confidence score.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "stationarity",
                  "type": "bool"
                },
                {
                  "name": "half_life",
                  "type": "bool"
                },
                {
                  "name": "zscore",
                  "type": "bool"
                },
                {
                  "name": "hurst",
                  "type": "bool"
                },
                {
                  "name": "support_resistance",
                  "type": "bool"
                },
                {
                  "name": "volume",
                  "type": "bool"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 511
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 146
        },
        {
          "name": "SpreadRatioValidator",
          "module": "signal_validation",
          "docstring": "Validates spread ratios for stat arb (#Q17).\n\nEnsures pairs trading signals are statistically sound.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "signal_validation",
              "signature": "def __init__(self, min_cointegration_confidence: float, max_half_life_days: float, min_correlation: float, hedge_ratio_stability_threshold: float, beta_neutrality_threshold: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "min_cointegration_confidence",
                  "type": "float"
                },
                {
                  "name": "max_half_life_days",
                  "type": "float"
                },
                {
                  "name": "min_correlation",
                  "type": "float"
                },
                {
                  "name": "hedge_ratio_stability_threshold",
                  "type": "float"
                },
                {
                  "name": "beta_neutrality_threshold",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 548
            },
            {
              "name": "update_price",
              "module": "signal_validation",
              "signature": "def update_price(self, symbol: str, price: float) -> None",
              "docstring": "Update price for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 568
            },
            {
              "name": "set_beta",
              "module": "signal_validation",
              "signature": "def set_beta(self, symbol: str, beta: float) -> None",
              "docstring": "Set market beta for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "beta",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 574
            },
            {
              "name": "validate_spread",
              "module": "signal_validation",
              "signature": "def validate_spread(self, symbol1: str, symbol2: str, hedge_ratio: float) -> SpreadRatioValidation",
              "docstring": "Validate a pairs trading spread.\n\nArgs:\n    symbol1: Long leg symbol\n    symbol2: Short leg symbol\n    hedge_ratio: Number of symbol2 shares per symbol1 share\n\nReturns:\n    SpreadRatioValidation with all checks",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol1",
                  "type": "str"
                },
                {
                  "name": "symbol2",
                  "type": "str"
                },
                {
                  "name": "hedge_ratio",
                  "type": "float"
                }
              ],
              "return_type": "SpreadRatioValidation",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 578
            },
            {
              "name": "_cointegration_test",
              "module": "signal_validation",
              "signature": "def _cointegration_test(self, prices1: list[float], prices2: list[float], hedge_ratio: float) -> tuple[float, float]",
              "docstring": "Engle-Granger cointegration test.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices1",
                  "type": "list[float]"
                },
                {
                  "name": "prices2",
                  "type": "list[float]"
                },
                {
                  "name": "hedge_ratio",
                  "type": "float"
                }
              ],
              "return_type": "tuple[float, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 717
            },
            {
              "name": "_check_hedge_ratio_stability",
              "module": "signal_validation",
              "signature": "def _check_hedge_ratio_stability(self, prices1: list[float], prices2: list[float], window: int) -> float",
              "docstring": "Check stability of rolling hedge ratio.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices1",
                  "type": "list[float]"
                },
                {
                  "name": "prices2",
                  "type": "list[float]"
                },
                {
                  "name": "window",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 769
            },
            {
              "name": "_estimate_spread_half_life",
              "module": "signal_validation",
              "signature": "def _estimate_spread_half_life(self, spread: list[float]) -> float",
              "docstring": "Estimate half-life of spread mean reversion.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 803
            },
            {
              "name": "_calculate_correlation",
              "module": "signal_validation",
              "signature": "def _calculate_correlation(self, prices1: list[float], prices2: list[float]) -> float",
              "docstring": "Calculate Pearson correlation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices1",
                  "type": "list[float]"
                },
                {
                  "name": "prices2",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 832
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 541
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.slippage_estimator": {
      "name": "slippage_estimator",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\slippage_estimator.py",
      "docstring": "Slippage Estimation Module\n==========================\n\nEstimates expected slippage for signal generation (Issue #Q11).\nIncorporates capacity constraints for strategy sizing (Issue #Q12).\n\nFeatures:\n- Market impact estimation\n- Liquidity-based slippage\n- Capacity constraints\n- Size-adjusted signal strength",
      "classes": [
        {
          "name": "LiquidityTier",
          "module": "slippage_estimator",
          "docstring": "Asset liquidity classification.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 27
        },
        {
          "name": "SlippageEstimate",
          "module": "slippage_estimator",
          "docstring": "Estimated slippage for a trade.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "slippage_estimator",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 61
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "side",
              "type": "str"
            },
            {
              "name": "quantity",
              "type": "int"
            },
            {
              "name": "spread_cost_bps",
              "type": "float"
            },
            {
              "name": "market_impact_bps",
              "type": "float"
            },
            {
              "name": "permanent_impact_bps",
              "type": "float"
            },
            {
              "name": "volatility_cost_bps",
              "type": "float"
            },
            {
              "name": "total_slippage_bps",
              "type": "float"
            },
            {
              "name": "total_slippage_dollars",
              "type": "float"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "estimation_method",
              "type": "str"
            },
            {
              "name": "recommended_urgency",
              "type": "str"
            },
            {
              "name": "optimal_execution_horizon_minutes",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 37
        },
        {
          "name": "CapacityConstraints",
          "module": "slippage_estimator",
          "docstring": "Capacity limits for a strategy/symbol.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "slippage_estimator",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 100
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "max_position_shares",
              "type": "int"
            },
            {
              "name": "max_position_pct_adv",
              "type": "float"
            },
            {
              "name": "max_single_order_shares",
              "type": "int"
            },
            {
              "name": "max_single_order_pct_adv",
              "type": "float"
            },
            {
              "name": "max_daily_volume_pct",
              "type": "float"
            },
            {
              "name": "max_hourly_volume_pct",
              "type": "float"
            },
            {
              "name": "current_capacity_used_pct",
              "type": "float"
            },
            {
              "name": "remaining_capacity_shares",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 80
        },
        {
          "name": "LiquidityProfile",
          "module": "slippage_estimator",
          "docstring": "Liquidity characteristics of an asset.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "average_daily_volume",
              "type": "int"
            },
            {
              "name": "average_spread_bps",
              "type": "float"
            },
            {
              "name": "average_depth_shares",
              "type": "int"
            },
            {
              "name": "volatility_daily_pct",
              "type": "float"
            },
            {
              "name": "liquidity_tier",
              "type": "LiquidityTier"
            },
            {
              "name": "volume_by_hour",
              "type": "dict[int, float]"
            },
            {
              "name": "spread_by_hour",
              "type": "dict[int, float]"
            },
            {
              "name": "last_updated",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 115
        },
        {
          "name": "SlippageEstimator",
          "module": "slippage_estimator",
          "docstring": "Estimates execution slippage for trading signals (#Q11).\n\nUses multiple models:\n- Square-root market impact (Almgren-Chriss)\n- Linear spread model\n- Volatility adjustment",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "slippage_estimator",
              "signature": "def __init__(self, permanent_impact_fraction: float, volatility_risk_premium: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "permanent_impact_fraction",
                  "type": "float"
                },
                {
                  "name": "volatility_risk_premium",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 170
            },
            {
              "name": "update_liquidity_profile",
              "module": "slippage_estimator",
              "signature": "def update_liquidity_profile(self, symbol: str, adv: int, spread_bps: float, depth_shares: int, volatility_pct: float, tier: ) -> LiquidityProfile",
              "docstring": "Update liquidity profile for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "adv",
                  "type": "int"
                },
                {
                  "name": "spread_bps",
                  "type": "float"
                },
                {
                  "name": "depth_shares",
                  "type": "int"
                },
                {
                  "name": "volatility_pct",
                  "type": "float"
                },
                {
                  "name": "tier",
                  "type": ""
                }
              ],
              "return_type": "LiquidityProfile",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 184
            },
            {
              "name": "update_price",
              "module": "slippage_estimator",
              "signature": "def update_price(self, symbol: str, price: float) -> None",
              "docstring": "Update current price for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "price",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 210
            },
            {
              "name": "_classify_liquidity_tier",
              "module": "slippage_estimator",
              "signature": "def _classify_liquidity_tier(self, adv: int, spread_bps: float) -> LiquidityTier",
              "docstring": "Classify asset into liquidity tier.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "adv",
                  "type": "int"
                },
                {
                  "name": "spread_bps",
                  "type": "float"
                }
              ],
              "return_type": "LiquidityTier",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 214
            },
            {
              "name": "estimate_slippage",
              "module": "slippage_estimator",
              "signature": "def estimate_slippage(self, symbol: str, side: str, quantity: int, price: , urgency: str) -> SlippageEstimate",
              "docstring": "Estimate slippage for a potential trade.\n\nArgs:\n    symbol: Trading symbol\n    side: 'BUY' or 'SELL'\n    quantity: Number of shares/contracts\n    price: Current price (uses cached if not provided)\n    urgency: 'immediate', 'normal', or 'patient'\n\nReturns:\n    SlippageEstimate with breakdown",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": ""
                },
                {
                  "name": "urgency",
                  "type": "str"
                }
              ],
              "return_type": "SlippageEstimate",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 231
            },
            {
              "name": "_estimate_without_profile",
              "module": "slippage_estimator",
              "signature": "def _estimate_without_profile(self, symbol: str, side: str, quantity: int, price: float, urgency: str) -> SlippageEstimate",
              "docstring": "Estimate with default assumptions when no profile available.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "urgency",
                  "type": "str"
                }
              ],
              "return_type": "SlippageEstimate",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 340
            },
            {
              "name": "_calculate_optimal_horizon",
              "module": "slippage_estimator",
              "signature": "def _calculate_optimal_horizon(self, quantity: int, adv: int, urgency: str) -> float",
              "docstring": "Calculate optimal execution horizon in minutes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "adv",
                  "type": "int"
                },
                {
                  "name": "urgency",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 384
            },
            {
              "name": "_recommend_urgency",
              "module": "slippage_estimator",
              "signature": "def _recommend_urgency(self, participation_rate: float) -> str",
              "docstring": "Recommend execution urgency based on participation rate.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "participation_rate",
                  "type": "float"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 404
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 131
        },
        {
          "name": "CapacityManager",
          "module": "slippage_estimator",
          "docstring": "Manages capacity constraints for strategies (#Q12).\n\nEnsures strategies don't exceed sustainable position sizes.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "slippage_estimator",
              "signature": "def __init__(self, default_max_adv_pct: float, default_max_order_adv_pct: float, default_max_daily_volume_pct: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "default_max_adv_pct",
                  "type": "float"
                },
                {
                  "name": "default_max_order_adv_pct",
                  "type": "float"
                },
                {
                  "name": "default_max_daily_volume_pct",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 421
            },
            {
              "name": "set_adv",
              "module": "slippage_estimator",
              "signature": "def set_adv(self, symbol: str, adv: int) -> None",
              "docstring": "Set average daily volume for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "adv",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 442
            },
            {
              "name": "set_custom_constraints",
              "module": "slippage_estimator",
              "signature": "def set_custom_constraints(self, symbol: str, max_position_pct_adv: , max_order_pct_adv: , max_daily_volume_pct: ) -> None",
              "docstring": "Set custom capacity constraints for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "max_position_pct_adv",
                  "type": ""
                },
                {
                  "name": "max_order_pct_adv",
                  "type": ""
                },
                {
                  "name": "max_daily_volume_pct",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 447
            },
            {
              "name": "_update_constraints",
              "module": "slippage_estimator",
              "signature": "def _update_constraints(self, symbol: str) -> None",
              "docstring": "Update constraints when ADV changes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 469
            },
            {
              "name": "update_position",
              "module": "slippage_estimator",
              "signature": "def update_position(self, symbol: str, quantity: int) -> None",
              "docstring": "Update current position for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 489
            },
            {
              "name": "record_execution",
              "module": "slippage_estimator",
              "signature": "def record_execution(self, symbol: str, quantity: int) -> None",
              "docstring": "Record executed volume.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 494
            },
            {
              "name": "_update_capacity_used",
              "module": "slippage_estimator",
              "signature": "def _update_capacity_used(self, symbol: str) -> None",
              "docstring": "Update capacity usage metrics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 503
            },
            {
              "name": "get_constraints",
              "module": "slippage_estimator",
              "signature": "def get_constraints(self, symbol: str) -> CapacityConstraints",
              "docstring": "Get capacity constraints for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "CapacityConstraints",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 514
            },
            {
              "name": "check_capacity",
              "module": "slippage_estimator",
              "signature": "def check_capacity(self, symbol: str, proposed_quantity: int) -> dict",
              "docstring": "Check if proposed trade fits within capacity constraints.\n\nReturns:\n    Dict with 'allowed', 'max_allowed', and 'reasons'",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "proposed_quantity",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 520
            },
            {
              "name": "get_adjusted_signal_size",
              "module": "slippage_estimator",
              "signature": "def get_adjusted_signal_size(self, symbol: str, desired_quantity: int, signal_strength: float) -> dict",
              "docstring": "Get capacity-adjusted position size.\n\nScales down size if hitting capacity limits.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "desired_quantity",
                  "type": "int"
                },
                {
                  "name": "signal_strength",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 575
            },
            {
              "name": "reset_daily_volume",
              "module": "slippage_estimator",
              "signature": "def reset_daily_volume(self) -> None",
              "docstring": "Reset daily volume counters (call at EOD).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 612
            },
            {
              "name": "get_all_constraints",
              "module": "slippage_estimator",
              "signature": "def get_all_constraints(self) -> dict[str, dict]",
              "docstring": "Get constraints for all tracked symbols.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 618
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 414
        },
        {
          "name": "SignalSlippageAdjuster",
          "module": "slippage_estimator",
          "docstring": "Adjusts signal strength based on expected slippage (#Q11).\n\nReduces signal strength when slippage would consume expected alpha.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "slippage_estimator",
              "signature": "def __init__(self, slippage_estimator: SlippageEstimator, capacity_manager: CapacityManager, min_edge_after_slippage_bps: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "slippage_estimator",
                  "type": "SlippageEstimator"
                },
                {
                  "name": "capacity_manager",
                  "type": "CapacityManager"
                },
                {
                  "name": "min_edge_after_slippage_bps",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 633
            },
            {
              "name": "adjust_signal",
              "module": "slippage_estimator",
              "signature": "def adjust_signal(self, symbol: str, direction: str, raw_strength: float, expected_alpha_bps: float, desired_quantity: int, price: float, urgency: str) -> dict",
              "docstring": "Adjust signal strength based on execution costs and capacity.\n\nArgs:\n    symbol: Trading symbol\n    direction: 'LONG' or 'SHORT'\n    raw_strength: Original signal strength (0-1)\n    expected_alpha_bps: Expected alpha from the signal in bps\n    desired_quantity: Desired position size\n    price: Current price\n    urgency: Execution urgency\n\nReturns:\n    Adjusted signal with all components",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "direction",
                  "type": "str"
                },
                {
                  "name": "raw_strength",
                  "type": "float"
                },
                {
                  "name": "expected_alpha_bps",
                  "type": "float"
                },
                {
                  "name": "desired_quantity",
                  "type": "int"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "urgency",
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 643
            },
            {
              "name": "batch_adjust_signals",
              "module": "slippage_estimator",
              "signature": "def batch_adjust_signals(self, signals: list[dict]) -> list[dict]",
              "docstring": "Adjust multiple signals considering portfolio-level capacity.\n\nArgs:\n    signals: List of dicts with symbol, direction, strength, alpha, quantity, price\n\nReturns:\n    List of adjusted signals sorted by net alpha",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "signals",
                  "type": "list[dict]"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 725
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 626
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.smart_order_router": {
      "name": "smart_order_router",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\smart_order_router.py",
      "docstring": "Smart Order Router (SOR)\n========================\n\nImplements smart order routing for best execution per MiFID II RTS 27/28.\n\nKey features:\n- Multi-venue price comparison\n- Order splitting across venues\n- Best execution logic\n- Venue selection based on:\n  - Price (best bid/ask)\n  - Liquidity (order book depth)\n  - Fees (maker/taker, rebates)\n  - Latency (venue responsiveness)\n\n#E11 - Smart Order Routing implementation",
      "classes": [
        {
          "name": "VenueType",
          "module": "smart_order_router",
          "docstring": "Trading venue type.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 34
        },
        {
          "name": "RoutingStrategy",
          "module": "smart_order_router",
          "docstring": "Order routing strategy.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 43
        },
        {
          "name": "VenueQuote",
          "module": "smart_order_router",
          "docstring": "Quote from a single venue.",
          "bases": [],
          "methods": [
            {
              "name": "mid",
              "module": "smart_order_router",
              "signature": "def mid(self) -> float",
              "docstring": "Mid price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 67
            },
            {
              "name": "spread",
              "module": "smart_order_router",
              "signature": "def spread(self) -> float",
              "docstring": "Bid-ask spread.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 72
            },
            {
              "name": "spread_bps",
              "module": "smart_order_router",
              "signature": "def spread_bps(self) -> float",
              "docstring": "Spread in basis points.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 77
            }
          ],
          "class_attributes": [
            {
              "name": "venue_id",
              "type": "str"
            },
            {
              "name": "venue_type",
              "type": "VenueType"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "bid",
              "type": "float"
            },
            {
              "name": "ask",
              "type": "float"
            },
            {
              "name": "bid_size",
              "type": "int"
            },
            {
              "name": "ask_size",
              "type": "int"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "latency_ms",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 54
        },
        {
          "name": "VenueConfig",
          "module": "smart_order_router",
          "docstring": "Configuration for a trading venue.",
          "bases": [],
          "methods": [
            {
              "name": "get_fee_bps",
              "module": "smart_order_router",
              "signature": "def get_fee_bps(self, is_maker: bool) -> float",
              "docstring": "Get fee in basis points.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "is_maker",
                  "type": "bool"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 103
            }
          ],
          "class_attributes": [
            {
              "name": "venue_id",
              "type": "str"
            },
            {
              "name": "venue_type",
              "type": "VenueType"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "enabled",
              "type": "bool"
            },
            {
              "name": "maker_fee_bps",
              "type": "float"
            },
            {
              "name": "taker_fee_bps",
              "type": "float"
            },
            {
              "name": "avg_latency_ms",
              "type": "float"
            },
            {
              "name": "min_order_size",
              "type": "int"
            },
            {
              "name": "max_order_size",
              "type": "int"
            },
            {
              "name": "supports_market_orders",
              "type": "bool"
            },
            {
              "name": "supports_limit_orders",
              "type": "bool"
            },
            {
              "name": "supports_stop_orders",
              "type": "bool"
            },
            {
              "name": "supports_iceberg",
              "type": "bool"
            },
            {
              "name": "supports_hidden",
              "type": "bool"
            },
            {
              "name": "connection_status",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 85
        },
        {
          "name": "RouteDecision",
          "module": "smart_order_router",
          "docstring": "Result of smart order routing decision.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "smart_order_router",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 119
            }
          ],
          "class_attributes": [
            {
              "name": "routes",
              "type": "list[tuple[str, int, float]]"
            },
            {
              "name": "total_quantity",
              "type": "int"
            },
            {
              "name": "strategy_used",
              "type": "RoutingStrategy"
            },
            {
              "name": "expected_avg_price",
              "type": "float"
            },
            {
              "name": "expected_total_fee_bps",
              "type": "float"
            },
            {
              "name": "rationale",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 109
        },
        {
          "name": "SmartOrderRouter",
          "module": "smart_order_router",
          "docstring": "Smart Order Router for multi-venue execution (#E11).\n\nImplements best execution logic per MiFID II requirements:\n- Considers price, cost, speed, and likelihood of execution\n- Provides audit trail of routing decisions\n- Supports multiple routing strategies",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "smart_order_router",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize smart order router.\n\nArgs:\n    config: Configuration with:\n        - default_strategy: Default routing strategy\n        - max_venue_split: Maximum number of venues to split order\n        - min_split_size: Minimum size per venue when splitting",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 145
            },
            {
              "name": "_initialize_default_venues",
              "module": "smart_order_router",
              "signature": "def _initialize_default_venues(self) -> None",
              "docstring": "Initialize default venue configurations.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 179
            },
            {
              "name": "add_venue",
              "module": "smart_order_router",
              "signature": "def add_venue(self, venue_config: VenueConfig) -> None",
              "docstring": "Add or update venue configuration.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "venue_config",
                  "type": "VenueConfig"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 240
            },
            {
              "name": "update_quote",
              "module": "smart_order_router",
              "signature": "def update_quote(self, quote: VenueQuote) -> None",
              "docstring": "Update quote for a venue.\n\nCalled by market data handlers when venue quotes update.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "quote",
                  "type": "VenueQuote"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 245
            },
            {
              "name": "get_quotes",
              "module": "smart_order_router",
              "signature": "def get_quotes(self, symbol: str) -> list[VenueQuote]",
              "docstring": "Get all quotes for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "list[VenueQuote]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 258
            },
            {
              "name": "route_order",
              "module": "smart_order_router",
              "signature": "def route_order(self, symbol: str, side: str, quantity: int, strategy: , max_price: , min_price: ) -> RouteDecision",
              "docstring": "Determine optimal routing for an order (#E11).\n\nArgs:\n    symbol: Instrument symbol\n    side: Order side (\"buy\" or \"sell\")\n    quantity: Order quantity\n    strategy: Routing strategy (uses default if None)\n    max_price: Maximum price for buys\n    min_price: Minimum price for sells\n\nReturns:\n    RouteDecision with routing instructions",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "side",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "strategy",
                  "type": ""
                },
                {
                  "name": "max_price",
                  "type": ""
                },
                {
                  "name": "min_price",
                  "type": ""
                }
              ],
              "return_type": "RouteDecision",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 262
            },
            {
              "name": "_route_best_price",
              "module": "smart_order_router",
              "signature": "def _route_best_price(self, symbol: str, is_buy: bool, quantity: int, quotes: list[VenueQuote], max_price: , min_price: ) -> RouteDecision",
              "docstring": "Route to venue with best price.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "is_buy",
                  "type": "bool"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "quotes",
                  "type": "list[VenueQuote]"
                },
                {
                  "name": "max_price",
                  "type": ""
                },
                {
                  "name": "min_price",
                  "type": ""
                }
              ],
              "return_type": "RouteDecision",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 328
            },
            {
              "name": "_route_lowest_cost",
              "module": "smart_order_router",
              "signature": "def _route_lowest_cost(self, symbol: str, is_buy: bool, quantity: int, quotes: list[VenueQuote], max_price: , min_price: ) -> RouteDecision",
              "docstring": "Route to venue with lowest total cost (price + fees).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "is_buy",
                  "type": "bool"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "quotes",
                  "type": "list[VenueQuote]"
                },
                {
                  "name": "max_price",
                  "type": ""
                },
                {
                  "name": "min_price",
                  "type": ""
                }
              ],
              "return_type": "RouteDecision",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 380
            },
            {
              "name": "_route_split_order",
              "module": "smart_order_router",
              "signature": "def _route_split_order(self, symbol: str, is_buy: bool, quantity: int, quotes: list[VenueQuote], max_price: , min_price: ) -> RouteDecision",
              "docstring": "Split order across multiple venues to access more liquidity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "is_buy",
                  "type": "bool"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "quotes",
                  "type": "list[VenueQuote]"
                },
                {
                  "name": "max_price",
                  "type": ""
                },
                {
                  "name": "min_price",
                  "type": ""
                }
              ],
              "return_type": "RouteDecision",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 443
            },
            {
              "name": "_route_fastest",
              "module": "smart_order_router",
              "signature": "def _route_fastest(self, symbol: str, is_buy: bool, quantity: int, quotes: list[VenueQuote], max_price: , min_price: ) -> RouteDecision",
              "docstring": "Route to fastest venue.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "is_buy",
                  "type": "bool"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "quotes",
                  "type": "list[VenueQuote]"
                },
                {
                  "name": "max_price",
                  "type": ""
                },
                {
                  "name": "min_price",
                  "type": ""
                }
              ],
              "return_type": "RouteDecision",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 517
            },
            {
              "name": "_route_liquidity",
              "module": "smart_order_router",
              "signature": "def _route_liquidity(self, symbol: str, is_buy: bool, quantity: int, quotes: list[VenueQuote], max_price: , min_price: ) -> RouteDecision",
              "docstring": "Route to venue with deepest liquidity.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "is_buy",
                  "type": "bool"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "quotes",
                  "type": "list[VenueQuote]"
                },
                {
                  "name": "max_price",
                  "type": ""
                },
                {
                  "name": "min_price",
                  "type": ""
                }
              ],
              "return_type": "RouteDecision",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 570
            },
            {
              "name": "_route_adaptive",
              "module": "smart_order_router",
              "signature": "def _route_adaptive(self, symbol: str, is_buy: bool, quantity: int, quotes: list[VenueQuote], max_price: , min_price: ) -> RouteDecision",
              "docstring": "Adaptive routing based on order characteristics.\n\n- Small orders: Route to best price\n- Large orders (> 25% of best venue): Split across venues\n- Urgent orders: Route to fastest venue",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "is_buy",
                  "type": "bool"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "quotes",
                  "type": "list[VenueQuote]"
                },
                {
                  "name": "max_price",
                  "type": ""
                },
                {
                  "name": "min_price",
                  "type": ""
                }
              ],
              "return_type": "RouteDecision",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 623
            },
            {
              "name": "get_routing_history",
              "module": "smart_order_router",
              "signature": "def get_routing_history(self, limit: int) -> list[RouteDecision]",
              "docstring": "Get recent routing decisions for audit.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[RouteDecision]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 658
            },
            {
              "name": "get_venue_stats",
              "module": "smart_order_router",
              "signature": "def get_venue_stats(self) -> dict[str, Any]",
              "docstring": "Get venue statistics for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 662
            },
            {
              "name": "get_status",
              "module": "smart_order_router",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get router status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 676
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 135
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy"
      ],
      "dependencies": [
        "__future__",
        "numpy"
      ]
    },
    "core.strategy_parameters": {
      "name": "strategy_parameters",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\strategy_parameters.py",
      "docstring": "Strategy Parameters Module\n==========================\n\nAddresses issues:\n- #Q20: Magic numbers in RSI calculation (70/30 thresholds)\n- #Q21: No parameter sensitivity analysis\n\nFeatures:\n- Centralized strategy parameter definitions\n- Configurable thresholds with validation\n- Parameter sensitivity analysis framework\n- Parameter optimization support",
      "classes": [
        {
          "name": "ParameterBounds",
          "module": "strategy_parameters",
          "docstring": "Defines valid bounds for a strategy parameter.\n\nEliminates magic numbers by providing named, validated parameters.",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "strategy_parameters",
              "signature": "def __post_init__(self) -> None",
              "docstring": "Validate bounds configuration.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 47
            },
            {
              "name": "validate",
              "module": "strategy_parameters",
              "signature": "def validate(self, value: float) -> bool",
              "docstring": "Check if value is within bounds.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 57
            },
            {
              "name": "generate_range",
              "module": "strategy_parameters",
              "signature": "def generate_range(self) -> list[float]",
              "docstring": "Generate all valid values within bounds.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 61
            }
          ],
          "class_attributes": [
            {
              "name": "min_value",
              "type": "float"
            },
            {
              "name": "max_value",
              "type": "float"
            },
            {
              "name": "default_value",
              "type": "float"
            },
            {
              "name": "step",
              "type": "float"
            },
            {
              "name": "description",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 35
        },
        {
          "name": "RSIParameters",
          "module": "strategy_parameters",
          "docstring": "RSI indicator parameters with named constants (#Q20).\n\nReplaces magic numbers 70/30 with configurable, documented thresholds.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "strategy_parameters",
              "signature": "def __init__(self, overbought: , oversold: , period: )",
              "docstring": "Initialize RSI parameters.\n\nArgs:\n    overbought: Overbought threshold (default 70)\n    oversold: Oversold threshold (default 30)\n    period: Lookback period (default 14)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "overbought",
                  "type": ""
                },
                {
                  "name": "oversold",
                  "type": ""
                },
                {
                  "name": "period",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 114
            },
            {
              "name": "_validate",
              "module": "strategy_parameters",
              "signature": "def _validate(self) -> None",
              "docstring": "Validate parameter consistency.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 134
            },
            {
              "name": "is_overbought",
              "module": "strategy_parameters",
              "signature": "def is_overbought(self, rsi_value: float) -> bool",
              "docstring": "Check if RSI indicates overbought condition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "rsi_value",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 152
            },
            {
              "name": "is_oversold",
              "module": "strategy_parameters",
              "signature": "def is_oversold(self, rsi_value: float) -> bool",
              "docstring": "Check if RSI indicates oversold condition.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "rsi_value",
                  "type": "float"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 156
            },
            {
              "name": "get_signal_strength",
              "module": "strategy_parameters",
              "signature": "def get_signal_strength(self, rsi_value: float) -> float",
              "docstring": "Get signal strength from RSI value.\n\nReturns:\n    -1 to 1 where:\n    - Negative = oversold (buy signal)\n    - Positive = overbought (sell signal)\n    - Near zero = neutral",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "rsi_value",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 160
            },
            {
              "name": "for_trending_market",
              "module": "strategy_parameters",
              "signature": "def for_trending_market(cls) -> RSIParameters",
              "docstring": "Create parameters optimized for trending markets.",
              "parameters": [
                {
                  "name": "cls"
                }
              ],
              "return_type": "RSIParameters",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 185
            },
            {
              "name": "for_ranging_market",
              "module": "strategy_parameters",
              "signature": "def for_ranging_market(cls) -> RSIParameters",
              "docstring": "Create parameters optimized for ranging/mean-reverting markets.",
              "parameters": [
                {
                  "name": "cls"
                }
              ],
              "return_type": "RSIParameters",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 193
            },
            {
              "name": "to_dict",
              "module": "strategy_parameters",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 200
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 71
        },
        {
          "name": "MACDParameters",
          "module": "strategy_parameters",
          "docstring": "MACD indicator parameters.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "strategy_parameters",
              "signature": "def __init__(self, fast_period: , slow_period: , signal_period: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "fast_period",
                  "type": ""
                },
                {
                  "name": "slow_period",
                  "type": ""
                },
                {
                  "name": "signal_period",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 241
            },
            {
              "name": "_validate",
              "module": "strategy_parameters",
              "signature": "def _validate(self) -> None",
              "docstring": "Validate parameter consistency.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 253
            },
            {
              "name": "to_dict",
              "module": "strategy_parameters",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 261
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 209
        },
        {
          "name": "BollingerBandsParameters",
          "module": "strategy_parameters",
          "docstring": "Bollinger Bands indicator parameters.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "strategy_parameters",
              "signature": "def __init__(self, period: , std_dev: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "period",
                  "type": ""
                },
                {
                  "name": "std_dev",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 292
            },
            {
              "name": "to_dict",
              "module": "strategy_parameters",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 300
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 270
        },
        {
          "name": "SensitivityResult",
          "module": "strategy_parameters",
          "docstring": "Result of a single sensitivity test.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "strategy_parameters",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 322
            }
          ],
          "class_attributes": [
            {
              "name": "parameter_name",
              "type": "str"
            },
            {
              "name": "parameter_value",
              "type": "float"
            },
            {
              "name": "metric_name",
              "type": "str"
            },
            {
              "name": "metric_value",
              "type": "float"
            },
            {
              "name": "baseline_value",
              "type": "float"
            },
            {
              "name": "change_pct",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 313
        },
        {
          "name": "SensitivityReport",
          "module": "strategy_parameters",
          "docstring": "Complete sensitivity analysis report.",
          "bases": [],
          "methods": [
            {
              "name": "get_most_sensitive_parameter",
              "module": "strategy_parameters",
              "signature": "def get_most_sensitive_parameter(self, metric: str)",
              "docstring": "Find parameter with highest sensitivity to given metric.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "metric",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 344
            },
            {
              "name": "get_stability_score",
              "module": "strategy_parameters",
              "signature": "def get_stability_score(self, parameter: str) -> float",
              "docstring": "Get stability score for a parameter.\n\nHigher score = more stable (less sensitive)\nRange: 0-100",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "parameter",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 362
            },
            {
              "name": "to_dict",
              "module": "strategy_parameters",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 371
            }
          ],
          "class_attributes": [
            {
              "name": "strategy_name",
              "type": "str"
            },
            {
              "name": "generated_at",
              "type": "datetime"
            },
            {
              "name": "baseline_params",
              "type": "dict[str, Any]"
            },
            {
              "name": "baseline_metrics",
              "type": "dict[str, float]"
            },
            {
              "name": "results",
              "type": "list[SensitivityResult]"
            },
            {
              "name": "stability_scores",
              "type": "dict[str, float]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 335
        },
        {
          "name": "ParameterSensitivityAnalyzer",
          "module": "strategy_parameters",
          "docstring": "Parameter sensitivity analysis framework (#Q21).\n\nAnalyzes how strategy performance changes with parameter variations.\nHelps identify:\n- Overfitted parameters\n- Stable vs unstable parameter regions\n- Optimal parameter ranges",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "strategy_parameters",
              "signature": "def __init__(self, strategy_evaluator: Callable[, dict[str, float]])",
              "docstring": "Initialize analyzer.\n\nArgs:\n    strategy_evaluator: Function that takes parameter dict and returns\n                       metrics dict (e.g., {\"sharpe_ratio\": 1.5, \"return\": 0.1})",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy_evaluator",
                  "type": "Callable[, dict[str, float]]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 394
            },
            {
              "name": "analyze_parameter",
              "module": "strategy_parameters",
              "signature": "def analyze_parameter(self, baseline_params: dict[str, Any], parameter_name: str, test_values: list[float], metrics: ) -> list[SensitivityResult]",
              "docstring": "Analyze sensitivity to a single parameter.\n\nArgs:\n    baseline_params: Baseline parameter values\n    parameter_name: Parameter to vary\n    test_values: Values to test\n    metrics: Which metrics to track (default: all)\n\nReturns:\n    List of sensitivity results",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "baseline_params",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "parameter_name",
                  "type": "str"
                },
                {
                  "name": "test_values",
                  "type": "list[float]"
                },
                {
                  "name": "metrics",
                  "type": ""
                }
              ],
              "return_type": "list[SensitivityResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 408
            },
            {
              "name": "analyze_all_parameters",
              "module": "strategy_parameters",
              "signature": "def analyze_all_parameters(self, baseline_params: dict[str, Any], parameter_bounds: dict[str, ParameterBounds], num_samples: int, metrics: ) -> SensitivityReport",
              "docstring": "Analyze sensitivity to all parameters.\n\nArgs:\n    baseline_params: Baseline parameter values\n    parameter_bounds: Bounds for each parameter\n    num_samples: Number of values to test per parameter\n    metrics: Which metrics to track\n\nReturns:\n    Complete sensitivity report",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "baseline_params",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "parameter_bounds",
                  "type": "dict[str, ParameterBounds]"
                },
                {
                  "name": "num_samples",
                  "type": "int"
                },
                {
                  "name": "metrics",
                  "type": ""
                }
              ],
              "return_type": "SensitivityReport",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 466
            },
            {
              "name": "_calculate_stability_scores",
              "module": "strategy_parameters",
              "signature": "def _calculate_stability_scores(self, results: list[SensitivityResult], baseline_metrics: dict[str, float]) -> dict[str, float]",
              "docstring": "Calculate stability score for each parameter.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "results",
                  "type": "list[SensitivityResult]"
                },
                {
                  "name": "baseline_metrics",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 510
            },
            {
              "name": "find_optimal_parameters",
              "module": "strategy_parameters",
              "signature": "def find_optimal_parameters(self, baseline_params: dict[str, Any], parameter_bounds: dict[str, ParameterBounds], objective_metric: str, num_iterations: int) -> dict[str, Any]",
              "docstring": "Find optimal parameters using grid search.\n\nArgs:\n    baseline_params: Starting parameters\n    parameter_bounds: Search bounds\n    objective_metric: Metric to optimize\n    num_iterations: Max iterations\n\nReturns:\n    Optimal parameter set",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "baseline_params",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "parameter_bounds",
                  "type": "dict[str, ParameterBounds]"
                },
                {
                  "name": "objective_metric",
                  "type": "str"
                },
                {
                  "name": "num_iterations",
                  "type": "int"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 534
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 383
        },
        {
          "name": "StrategyParameterSet",
          "module": "strategy_parameters",
          "docstring": "Complete parameter set for a trading strategy.\n\nCentralizes all parameters with validation and defaults.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "strategy_parameters",
              "signature": "def __init__(self, strategy_name: str, rsi: , macd: , bollinger: , custom_params: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "strategy_name",
                  "type": "str"
                },
                {
                  "name": "rsi",
                  "type": ""
                },
                {
                  "name": "macd",
                  "type": ""
                },
                {
                  "name": "bollinger",
                  "type": ""
                },
                {
                  "name": "custom_params",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 603
            },
            {
              "name": "to_dict",
              "module": "strategy_parameters",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert all parameters to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 617
            },
            {
              "name": "to_flat_dict",
              "module": "strategy_parameters",
              "signature": "def to_flat_dict(self) -> dict[str, Any]",
              "docstring": "Convert to flat dictionary for optimization.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 627
            },
            {
              "name": "from_flat_dict",
              "module": "strategy_parameters",
              "signature": "def from_flat_dict(cls, strategy_name: str, params: dict[str, Any]) -> StrategyParameterSet",
              "docstring": "Create from flat dictionary.",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "strategy_name",
                  "type": "str"
                },
                {
                  "name": "params",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "StrategyParameterSet",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 643
            },
            {
              "name": "get_default_bounds",
              "module": "strategy_parameters",
              "signature": "def get_default_bounds(cls) -> dict[str, ParameterBounds]",
              "docstring": "Get default parameter bounds for optimization.",
              "parameters": [
                {
                  "name": "cls"
                }
              ],
              "return_type": "dict[str, ParameterBounds]",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 668
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 596
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "itertools"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.stress_tester": {
      "name": "stress_tester",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\stress_tester.py",
      "docstring": "Stress Testing Module\n=====================\n\nComprehensive stress testing for portfolio risk assessment.\nImplements predefined and custom scenarios for regulatory\ncompliance and risk management.",
      "classes": [
        {
          "name": "ScenarioType",
          "module": "stress_tester",
          "docstring": "Type of stress scenario.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 24
        },
        {
          "name": "StressScenario",
          "module": "stress_tester",
          "docstring": "Definition of a stress scenario.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "stress_tester",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 63
            }
          ],
          "class_attributes": [
            {
              "name": "scenario_id",
              "type": "str"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "scenario_type",
              "type": "ScenarioType"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "price_shocks",
              "type": "dict[str, float]"
            },
            {
              "name": "volatility_multiplier",
              "type": "float"
            },
            {
              "name": "correlation_override",
              "type": ""
            },
            {
              "name": "liquidity_haircut",
              "type": "float"
            },
            {
              "name": "horizon_days",
              "type": "int"
            },
            {
              "name": "severity",
              "type": "int"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 38
        },
        {
          "name": "StressTestResult",
          "module": "stress_tester",
          "docstring": "Result of a stress test.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "stress_tester",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 95
            }
          ],
          "class_attributes": [
            {
              "name": "scenario",
              "type": "StressScenario"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "portfolio_value_before",
              "type": "float"
            },
            {
              "name": "portfolio_value_after",
              "type": "float"
            },
            {
              "name": "pnl_impact",
              "type": "float"
            },
            {
              "name": "pnl_impact_pct",
              "type": "float"
            },
            {
              "name": "positions_impacted",
              "type": "dict[str, float]"
            },
            {
              "name": "margin_impact",
              "type": "float"
            },
            {
              "name": "liquidity_impact",
              "type": "float"
            },
            {
              "name": "passes_limit",
              "type": "bool"
            },
            {
              "name": "limit_breaches",
              "type": "list[str]"
            },
            {
              "name": "details",
              "type": "dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 80
        },
        {
          "name": "StressTester",
          "module": "stress_tester",
          "docstring": "Portfolio stress testing system.\n\nFeatures:\n- Predefined crisis scenarios\n- Custom scenario creation\n- Portfolio impact analysis\n- Limit breach detection\n- Regulatory reporting support",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "stress_tester",
              "signature": "def __init__(self, config: , max_scenario_loss_pct: float, margin_buffer_pct: float)",
              "docstring": "Initialize stress tester.\n\nArgs:\n    config: Configuration with:\n        - max_scenario_loss_pct: Maximum acceptable loss (default: 25%)\n        - margin_buffer_pct: Margin buffer requirement (default: 20%)\n        - run_on_startup: Run tests at startup (default: False)\n        - use_predefined: Load predefined scenarios (default: True)\n        - custom_scenarios: List of custom scenario definitions (#R5)\n    max_scenario_loss_pct: Fallback max loss if not in config\n    margin_buffer_pct: Fallback margin buffer if not in config",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                },
                {
                  "name": "max_scenario_loss_pct",
                  "type": "float"
                },
                {
                  "name": "margin_buffer_pct",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 324
            },
            {
              "name": "_parse_scenario_config",
              "module": "stress_tester",
              "signature": "def _parse_scenario_config(self, config: dict[str, Any]) -> StressScenario",
              "docstring": "Parse a scenario from config dictionary (#R5).\n\nArgs:\n    config: Scenario configuration dict with:\n        - id: Unique scenario ID\n        - name: Display name\n        - type: Scenario type (market_crash, volatility_spike, etc.)\n        - description: Description\n        - price_shocks: Dict of symbol -> percentage shock\n        - volatility_multiplier: Vol multiplier (default: 1.0)\n        - correlation_override: Optional correlation override\n        - liquidity_haircut: Liquidity reduction % (default: 0)\n        - horizon_days: Time horizon (default: 1)\n        - severity: Severity 1-5 (default: 3)\n\nReturns:\n    StressScenario instance",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "StressScenario",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 372
            },
            {
              "name": "load_scenarios_from_file",
              "module": "stress_tester",
              "signature": "def load_scenarios_from_file(self, filepath: str) -> int",
              "docstring": "Load additional scenarios from a YAML or JSON file (#R5).\n\nArgs:\n    filepath: Path to scenarios file\n\nReturns:\n    Number of scenarios loaded",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "filepath",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 419
            },
            {
              "name": "register_callback",
              "module": "stress_tester",
              "signature": "def register_callback(self, callback: Callable[, None]) -> None",
              "docstring": "Register callback for stress test results.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 464
            },
            {
              "name": "add_custom_scenario",
              "module": "stress_tester",
              "signature": "def add_custom_scenario(self, scenario: StressScenario) -> None",
              "docstring": "Add a custom stress scenario.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario",
                  "type": "StressScenario"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 468
            },
            {
              "name": "run_scenario",
              "module": "stress_tester",
              "signature": "def run_scenario(self, scenario_id: str, positions: dict[str, float], portfolio_value: float, prices: dict[str, float], contract_specs: ) -> StressTestResult",
              "docstring": "Run a single stress scenario.\n\nArgs:\n    scenario_id: ID of scenario to run\n    positions: Current positions (symbol -> value or contracts)\n    portfolio_value: Total portfolio value\n    prices: Current prices by symbol\n    contract_specs: Optional contract specifications\n\nReturns:\n    StressTestResult with impact analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario_id",
                  "type": "str"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "prices",
                  "type": "dict[str, float]"
                },
                {
                  "name": "contract_specs",
                  "type": ""
                }
              ],
              "return_type": "StressTestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 473
            },
            {
              "name": "run_all_scenarios",
              "module": "stress_tester",
              "signature": "def run_all_scenarios(self, positions: dict[str, float], portfolio_value: float, prices: dict[str, float], contract_specs: , severity_filter: ) -> list[StressTestResult]",
              "docstring": "Run all stress scenarios.\n\nArgs:\n    positions: Current positions\n    portfolio_value: Total portfolio value\n    prices: Current prices\n    contract_specs: Optional contract specifications\n    severity_filter: Only run scenarios with this severity or higher\n\nReturns:\n    List of StressTestResult",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "prices",
                  "type": "dict[str, float]"
                },
                {
                  "name": "contract_specs",
                  "type": ""
                },
                {
                  "name": "severity_filter",
                  "type": ""
                }
              ],
              "return_type": "list[StressTestResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 500
            },
            {
              "name": "_execute_scenario",
              "module": "stress_tester",
              "signature": "def _execute_scenario(self, scenario: StressScenario, positions: dict[str, float], portfolio_value: float, prices: dict[str, float], contract_specs: ) -> StressTestResult",
              "docstring": "Execute a stress scenario and calculate impact.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario",
                  "type": "StressScenario"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "prices",
                  "type": "dict[str, float]"
                },
                {
                  "name": "contract_specs",
                  "type": ""
                }
              ],
              "return_type": "StressTestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 539
            },
            {
              "name": "get_worst_case_scenario",
              "module": "stress_tester",
              "signature": "def get_worst_case_scenario(self, positions: dict[str, float], portfolio_value: float, prices: dict[str, float])",
              "docstring": "Run all scenarios and return the worst case.\n\nArgs:\n    positions: Current positions\n    portfolio_value: Portfolio value\n    prices: Current prices\n\nReturns:\n    StressTestResult with worst impact",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "prices",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 635
            },
            {
              "name": "get_scenario",
              "module": "stress_tester",
              "signature": "def get_scenario(self, scenario_id: str)",
              "docstring": "Get scenario by ID.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario_id",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 661
            },
            {
              "name": "get_all_scenarios",
              "module": "stress_tester",
              "signature": "def get_all_scenarios(self) -> list[StressScenario]",
              "docstring": "Get all available scenarios.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[StressScenario]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 665
            },
            {
              "name": "get_scenarios_by_type",
              "module": "stress_tester",
              "signature": "def get_scenarios_by_type(self, scenario_type: ScenarioType) -> list[StressScenario]",
              "docstring": "Get scenarios of a specific type.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario_type",
                  "type": "ScenarioType"
                }
              ],
              "return_type": "list[StressScenario]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 669
            },
            {
              "name": "get_recent_results",
              "module": "stress_tester",
              "signature": "def get_recent_results(self, scenario_id: , limit: int) -> list[StressTestResult]",
              "docstring": "Get recent stress test results.\n\nArgs:\n    scenario_id: Filter by scenario ID\n    limit: Maximum results to return\n\nReturns:\n    List of recent results",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "scenario_id",
                  "type": ""
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[StressTestResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 673
            },
            {
              "name": "get_failed_scenarios",
              "module": "stress_tester",
              "signature": "def get_failed_scenarios(self, positions: dict[str, float], portfolio_value: float, prices: dict[str, float]) -> list[StressTestResult]",
              "docstring": "Run all scenarios and return those that fail limits.\n\nArgs:\n    positions: Current positions\n    portfolio_value: Portfolio value\n    prices: Current prices\n\nReturns:\n    List of failed StressTestResult",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "prices",
                  "type": "dict[str, float]"
                }
              ],
              "return_type": "list[StressTestResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 695
            },
            {
              "name": "generate_report",
              "module": "stress_tester",
              "signature": "def generate_report(self, results: list[StressTestResult]) -> dict[str, Any]",
              "docstring": "Generate stress test report.\n\nArgs:\n    results: List of stress test results\n\nReturns:\n    Report dictionary",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "results",
                  "type": "list[StressTestResult]"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 715
            },
            {
              "name": "get_status",
              "module": "stress_tester",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get tester status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 773
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 312
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy",
        "json",
        "yaml",
        "pathlib"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "yaml"
      ]
    },
    "core.structured_logging": {
      "name": "structured_logging",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\structured_logging.py",
      "docstring": "Structured Logging Module\n=========================\n\nImplements JSON-structured logging for production environments (Issue #S11).\n\nFeatures:\n- JSON-formatted log entries for machine parsing\n- Correlation ID tracking across distributed components\n- Log context propagation\n- Performance metrics in logs\n- Log level filtering by component\n- ELK/Splunk compatible output format",
      "classes": [
        {
          "name": "LogLevel",
          "module": "structured_logging",
          "docstring": "Standardized log levels.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 46
        },
        {
          "name": "StructuredLogEntry",
          "module": "structured_logging",
          "docstring": "Structured log entry for JSON output.",
          "bases": [],
          "methods": [
            {
              "name": "to_json",
              "module": "structured_logging",
              "signature": "def to_json(self) -> str",
              "docstring": "Convert to JSON string.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 71
            },
            {
              "name": "to_dict",
              "module": "structured_logging",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 76
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "str"
            },
            {
              "name": "level",
              "type": "str"
            },
            {
              "name": "logger_name",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "correlation_id",
              "type": "str"
            },
            {
              "name": "component",
              "type": "str"
            },
            {
              "name": "event_type",
              "type": "str"
            },
            {
              "name": "duration_ms",
              "type": ""
            },
            {
              "name": "context",
              "type": "dict"
            },
            {
              "name": "exception",
              "type": ""
            },
            {
              "name": "metrics",
              "type": "dict"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 57
        },
        {
          "name": "JsonFormatter",
          "module": "structured_logging",
          "docstring": "JSON formatter for structured logging.",
          "bases": [
            "logging.Formatter"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "structured_logging",
              "signature": "def __init__(self, include_stack: bool)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "include_stack",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 84
            },
            {
              "name": "format",
              "module": "structured_logging",
              "signature": "def format(self, record: logging.LogRecord) -> str",
              "docstring": "Format log record as JSON.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record",
                  "type": "logging.LogRecord"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 88
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 81
        },
        {
          "name": "StructuredLogger",
          "module": "structured_logging",
          "docstring": "Enhanced logger with structured JSON output.\n\nFeatures:\n- JSON-formatted logs for ELK/Splunk ingestion\n- Correlation ID tracking\n- Performance timing\n- Context propagation\n- Async logging support",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "structured_logging",
              "signature": "def __init__(self, name: str, component: str, log_dir: str, json_file: str, console_json: bool, max_bytes: int, backup_count: int, async_logging: bool)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "component",
                  "type": "str"
                },
                {
                  "name": "log_dir",
                  "type": "str"
                },
                {
                  "name": "json_file",
                  "type": "str"
                },
                {
                  "name": "console_json",
                  "type": "bool"
                },
                {
                  "name": "max_bytes",
                  "type": "int"
                },
                {
                  "name": "backup_count",
                  "type": "int"
                },
                {
                  "name": "async_logging",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 127
            },
            {
              "name": "_setup_handlers",
              "module": "structured_logging",
              "signature": "def _setup_handlers(self, json_file: str, console_json: bool, max_bytes: int, backup_count: int, async_logging: bool) -> None",
              "docstring": "Configure log handlers.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "json_file",
                  "type": "str"
                },
                {
                  "name": "console_json",
                  "type": "bool"
                },
                {
                  "name": "max_bytes",
                  "type": "int"
                },
                {
                  "name": "backup_count",
                  "type": "int"
                },
                {
                  "name": "async_logging",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 157
            },
            {
              "name": "_log",
              "module": "structured_logging",
              "signature": "def _log(self, level: int, message: str, event_type: str, context: , metrics: , duration_ms: , exc_info: bool) -> None",
              "docstring": "Internal log method with structured data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "level",
                  "type": "int"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                },
                {
                  "name": "metrics",
                  "type": ""
                },
                {
                  "name": "duration_ms",
                  "type": ""
                },
                {
                  "name": "exc_info",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 207
            },
            {
              "name": "debug",
              "module": "structured_logging",
              "signature": "def debug(self, message: str, event_type: str, context: ) -> None",
              "docstring": "Log debug message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 227
            },
            {
              "name": "info",
              "module": "structured_logging",
              "signature": "def info(self, message: str, event_type: str, context: , metrics: ) -> None",
              "docstring": "Log info message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                },
                {
                  "name": "metrics",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 237
            },
            {
              "name": "warning",
              "module": "structured_logging",
              "signature": "def warning(self, message: str, event_type: str, context: ) -> None",
              "docstring": "Log warning message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 248
            },
            {
              "name": "error",
              "module": "structured_logging",
              "signature": "def error(self, message: str, event_type: str, context: , exc_info: bool) -> None",
              "docstring": "Log error message with optional exception info.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                },
                {
                  "name": "exc_info",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 258
            },
            {
              "name": "critical",
              "module": "structured_logging",
              "signature": "def critical(self, message: str, event_type: str, context: , exc_info: bool) -> None",
              "docstring": "Log critical message.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                },
                {
                  "name": "exc_info",
                  "type": "bool"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 269
            },
            {
              "name": "audit",
              "module": "structured_logging",
              "signature": "def audit(self, message: str, event_type: str, context: , metrics: ) -> None",
              "docstring": "Log audit event (compliance requirement).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                },
                {
                  "name": "metrics",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 280
            },
            {
              "name": "start_timer",
              "module": "structured_logging",
              "signature": "def start_timer(self, operation: str) -> str",
              "docstring": "Start a performance timer.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation",
                  "type": "str"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 297
            },
            {
              "name": "stop_timer",
              "module": "structured_logging",
              "signature": "def stop_timer(self, timer_id: str) -> float",
              "docstring": "Stop timer and return duration in milliseconds.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "timer_id",
                  "type": "str"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 304
            },
            {
              "name": "timed",
              "module": "structured_logging",
              "signature": "def timed(self, message: str, event_type: str, context: )",
              "docstring": "Context manager for timed operations.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 312
            },
            {
              "name": "with_context",
              "module": "structured_logging",
              "signature": "def with_context(self) -> LogContextManager",
              "docstring": "Add context to all logs within the context manager.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "LogContextManager",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 321
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 115
        },
        {
          "name": "TimedOperation",
          "module": "structured_logging",
          "docstring": "Context manager for timing operations.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "structured_logging",
              "signature": "def __init__(self, logger: StructuredLogger, message: str, event_type: str, context: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "logger",
                  "type": "StructuredLogger"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "event_type",
                  "type": "str"
                },
                {
                  "name": "context",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 329
            },
            {
              "name": "__enter__",
              "module": "structured_logging",
              "signature": "def __enter__(self) -> TimedOperation",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "TimedOperation",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 342
            },
            {
              "name": "__exit__",
              "module": "structured_logging",
              "signature": "def __exit__(self, exc_type, exc_val, exc_tb) -> None",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exc_type"
                },
                {
                  "name": "exc_val"
                },
                {
                  "name": "exc_tb"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 346
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 326
        },
        {
          "name": "LogContextManager",
          "module": "structured_logging",
          "docstring": "Context manager for adding context to logs.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "structured_logging",
              "signature": "def __init__(self, context: dict)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "context",
                  "type": "dict"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 369
            },
            {
              "name": "__enter__",
              "module": "structured_logging",
              "signature": "def __enter__(self) -> LogContextManager",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "LogContextManager",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 373
            },
            {
              "name": "__exit__",
              "module": "structured_logging",
              "signature": "def __exit__(self, exc_type, exc_val, exc_tb) -> None",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exc_type"
                },
                {
                  "name": "exc_val"
                },
                {
                  "name": "exc_tb"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 379
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 366
        },
        {
          "name": "LogAggregator",
          "module": "structured_logging",
          "docstring": "Aggregates and summarizes log metrics.\n\nUseful for dashboards and alerting.",
          "bases": [],
          "methods": [
            {
              "name": "record_log",
              "module": "structured_logging",
              "signature": "def record_log(self, level: str, message: str, duration_ms: ) -> None",
              "docstring": "Record a log entry.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "level",
                  "type": "str"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "duration_ms",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 450
            },
            {
              "name": "record_operation_time",
              "module": "structured_logging",
              "signature": "def record_operation_time(self, operation: str, duration_ms: float) -> None",
              "docstring": "Record operation timing.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation",
                  "type": "str"
                },
                {
                  "name": "duration_ms",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 466
            },
            {
              "name": "get_summary",
              "module": "structured_logging",
              "signature": "def get_summary(self) -> dict",
              "docstring": "Get log summary for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 478
            },
            {
              "name": "_calculate_error_rate",
              "module": "structured_logging",
              "signature": "def _calculate_error_rate(self) -> float",
              "docstring": "Calculate error rate as percentage.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 504
            }
          ],
          "class_attributes": [
            {
              "name": "counts",
              "type": "dict[str, int]"
            },
            {
              "name": "recent_errors",
              "type": "list[dict]"
            },
            {
              "name": "max_recent_errors",
              "type": "int"
            },
            {
              "name": "operation_times",
              "type": "dict[str, list[float]]"
            },
            {
              "name": "_lock",
              "type": "Lock"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 428
        },
        {
          "name": "ComponentLogFilter",
          "module": "structured_logging",
          "docstring": "Filter logs by component.",
          "bases": [
            "logging.Filter"
          ],
          "methods": [
            {
              "name": "__init__",
              "module": "structured_logging",
              "signature": "def __init__(self, allowed_components: , excluded_components: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "allowed_components",
                  "type": ""
                },
                {
                  "name": "excluded_components",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 525
            },
            {
              "name": "filter",
              "module": "structured_logging",
              "signature": "def filter(self, record: logging.LogRecord) -> bool",
              "docstring": "Filter log record by component.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "record",
                  "type": "logging.LogRecord"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 531
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 522
        }
      ],
      "functions": [
        {
          "name": "set_correlation_id",
          "module": "structured_logging",
          "signature": "def set_correlation_id(correlation_id: ) -> str",
          "docstring": "Set or generate correlation ID for request tracing.\n\nReturns the correlation ID.",
          "parameters": [
            {
              "name": "correlation_id",
              "type": ""
            }
          ],
          "return_type": "str",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 384
        },
        {
          "name": "get_correlation_id",
          "module": "structured_logging",
          "signature": "def get_correlation_id() -> str",
          "docstring": "Get current correlation ID.",
          "parameters": [],
          "return_type": "str",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 396
        },
        {
          "name": "add_log_context",
          "module": "structured_logging",
          "signature": "def add_log_context() -> contextvars.Token",
          "docstring": "Add context to current log context.",
          "parameters": [],
          "return_type": "contextvars.Token",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 401
        },
        {
          "name": "clear_log_context",
          "module": "structured_logging",
          "signature": "def clear_log_context() -> None",
          "docstring": "Clear log context.",
          "parameters": [],
          "return_type": "None",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 408
        },
        {
          "name": "get_logger",
          "module": "structured_logging",
          "signature": "def get_logger(name: str, component: str) -> StructuredLogger",
          "docstring": "Get or create a structured logger.",
          "parameters": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "component",
              "type": "str"
            }
          ],
          "return_type": "StructuredLogger",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 418
        },
        {
          "name": "get_log_aggregator",
          "module": "structured_logging",
          "signature": "def get_log_aggregator() -> LogAggregator",
          "docstring": "Get global log aggregator.",
          "parameters": [],
          "return_type": "LogAggregator",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 517
        },
        {
          "name": "configure_global_logging",
          "module": "structured_logging",
          "signature": "def configure_global_logging(log_dir: str, json_file: str, console_json: bool, level: str, async_logging: bool) -> None",
          "docstring": "Configure global structured logging.\n\nCall this once at application startup.",
          "parameters": [
            {
              "name": "log_dir",
              "type": "str"
            },
            {
              "name": "json_file",
              "type": "str"
            },
            {
              "name": "console_json",
              "type": "bool"
            },
            {
              "name": "level",
              "type": "str"
            },
            {
              "name": "async_logging",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 544
        }
      ],
      "constants": [],
      "imports": [
        "__future__",
        "contextvars",
        "json",
        "logging",
        "sys",
        "time",
        "traceback",
        "dataclasses",
        "datetime",
        "enum",
        "logging.handlers",
        "pathlib",
        "queue",
        "threading",
        "typing",
        "uuid"
      ],
      "dependencies": [
        "__future__",
        "contextvars",
        "time",
        "traceback",
        "queue",
        "threading",
        "uuid"
      ]
    },
    "core.system_infrastructure": {
      "name": "system_infrastructure",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\system_infrastructure.py",
      "docstring": "System Infrastructure Module\n============================\n\nHot reload, dependency injection, and distributed tracing support.\n\nIssues Addressed:\n- #S9: No hot reload of configuration\n- #S10: Missing dependency injection framework\n- #S12: No distributed tracing support",
      "classes": [
        {
          "name": "ConfigChangeType",
          "module": "system_infrastructure",
          "docstring": "Type of configuration change.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 41
        },
        {
          "name": "ConfigChange",
          "module": "system_infrastructure",
          "docstring": "Record of configuration change (#S9).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "system_infrastructure",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 58
            }
          ],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "change_type",
              "type": "ConfigChangeType"
            },
            {
              "name": "key",
              "type": "str"
            },
            {
              "name": "old_value",
              "type": "Any"
            },
            {
              "name": "new_value",
              "type": "Any"
            },
            {
              "name": "source",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 49
        },
        {
          "name": "HotReloadableConfig",
          "module": "system_infrastructure",
          "docstring": "Configuration with hot reload support (#S9).\n\nFeatures:\n- File watching for changes\n- Automatic reload on change\n- Change callbacks for dependent systems\n- Validation before applying changes\n- Rollback on failed validation",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "system_infrastructure",
              "signature": "def __init__(self, config_path: , auto_reload: bool, poll_interval_seconds: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config_path",
                  "type": ""
                },
                {
                  "name": "auto_reload",
                  "type": "bool"
                },
                {
                  "name": "poll_interval_seconds",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 81
            },
            {
              "name": "load_from_file",
              "module": "system_infrastructure",
              "signature": "def load_from_file(self, path: str) -> dict[str, Any]",
              "docstring": "Load configuration from file.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "path",
                  "type": "str"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 112
            },
            {
              "name": "load_from_dict",
              "module": "system_infrastructure",
              "signature": "def load_from_dict(self, config: dict[str, Any], source: str) -> None",
              "docstring": "Load configuration from dictionary.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "source",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 129
            },
            {
              "name": "_apply_config",
              "module": "system_infrastructure",
              "signature": "def _apply_config(self, new_config: dict[str, Any], source: str) -> None",
              "docstring": "Apply new configuration, triggering callbacks for changes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "new_config",
                  "type": "dict[str, Any]"
                },
                {
                  "name": "source",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 133
            },
            {
              "name": "_validate",
              "module": "system_infrastructure",
              "signature": "def _validate(self, key: str, value: Any) -> tuple[bool, str]",
              "docstring": "Validate configuration value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "Any"
                }
              ],
              "return_type": "tuple[bool, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 184
            },
            {
              "name": "_trigger_callbacks",
              "module": "system_infrastructure",
              "signature": "def _trigger_callbacks(self, key: str, old_value: Any, new_value: Any) -> None",
              "docstring": "Trigger callbacks for configuration change.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "old_value",
                  "type": "Any"
                },
                {
                  "name": "new_value",
                  "type": "Any"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 197
            },
            {
              "name": "_compute_hash",
              "module": "system_infrastructure",
              "signature": "def _compute_hash(self, config: dict) -> str",
              "docstring": "Compute hash of configuration.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 215
            },
            {
              "name": "get",
              "module": "system_infrastructure",
              "signature": "def get(self, key: str, default: Any) -> Any",
              "docstring": "Get configuration value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "default",
                  "type": "Any"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 220
            },
            {
              "name": "get_nested",
              "module": "system_infrastructure",
              "signature": "def get_nested(self, path: str, default: Any, separator: str) -> Any",
              "docstring": "Get nested configuration value using dot notation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "path",
                  "type": "str"
                },
                {
                  "name": "default",
                  "type": "Any"
                },
                {
                  "name": "separator",
                  "type": "str"
                }
              ],
              "return_type": "Any",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 224
            },
            {
              "name": "set",
              "module": "system_infrastructure",
              "signature": "def set(self, key: str, value: Any) -> None",
              "docstring": "Set configuration value (triggers callbacks).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "Any"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 240
            },
            {
              "name": "register_callback",
              "module": "system_infrastructure",
              "signature": "def register_callback(self, key_pattern: str, callback: Callable[, None]) -> None",
              "docstring": "Register callback for configuration changes (#S9).\n\nArgs:\n    key_pattern: Key or pattern (e.g., \"database.*\")\n    callback: Function called with (key, old_value, new_value)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key_pattern",
                  "type": "str"
                },
                {
                  "name": "callback",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 244
            },
            {
              "name": "register_validator",
              "module": "system_infrastructure",
              "signature": "def register_validator(self, key_pattern: str, validator: Callable[, tuple[bool, str]]) -> None",
              "docstring": "Register validator for configuration values (#S9).\n\nArgs:\n    key_pattern: Key or pattern\n    validator: Function returning (is_valid, error_message)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key_pattern",
                  "type": "str"
                },
                {
                  "name": "validator",
                  "type": "Callable[, tuple[bool, str]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 259
            },
            {
              "name": "start_watching",
              "module": "system_infrastructure",
              "signature": "def start_watching(self) -> None",
              "docstring": "Start watching configuration file for changes (#S9).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 273
            },
            {
              "name": "stop_watching",
              "module": "system_infrastructure",
              "signature": "def stop_watching(self) -> None",
              "docstring": "Stop watching configuration file.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 287
            },
            {
              "name": "_watch_loop",
              "module": "system_infrastructure",
              "signature": "def _watch_loop(self) -> None",
              "docstring": "Background loop to watch for config changes.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 294
            },
            {
              "name": "get_change_history",
              "module": "system_infrastructure",
              "signature": "def get_change_history(self, limit: int) -> list[ConfigChange]",
              "docstring": "Get configuration change history.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "limit",
                  "type": "int"
                }
              ],
              "return_type": "list[ConfigChange]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 313
            },
            {
              "name": "to_dict",
              "module": "system_infrastructure",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Get full configuration as dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 317
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 69
        },
        {
          "name": "Scope",
          "module": "system_infrastructure",
          "docstring": "Dependency injection scope (#S10).",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 329
        },
        {
          "name": "ServiceRegistration",
          "module": "system_infrastructure",
          "docstring": "Service registration for DI (#S10).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "service_type",
              "type": "Type"
            },
            {
              "name": "implementation",
              "type": ""
            },
            {
              "name": "scope",
              "type": "Scope"
            },
            {
              "name": "factory",
              "type": ""
            },
            {
              "name": "instance",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 337
        },
        {
          "name": "DIContainer",
          "module": "system_infrastructure",
          "docstring": "Dependency injection container (#S10).\n\nFeatures:\n- Constructor injection\n- Interface-to-implementation binding\n- Singleton, transient, and scoped lifetimes\n- Factory functions\n- Circular dependency detection\n- Child containers for scoped resolution",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "system_infrastructure",
              "signature": "def __init__(self, parent: DIContainer | None)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "parent",
                  "type": "DIContainer | None"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 359
            },
            {
              "name": "register_singleton",
              "module": "system_infrastructure",
              "signature": "def register_singleton(self, service_type: Type[T], implementation: ) -> DIContainer",
              "docstring": "Register singleton service (#S10).\n\nArgs:\n    service_type: Interface/base type\n    implementation: Implementation class or instance\n\nReturns:\n    Self for chaining",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_type",
                  "type": "Type[T]"
                },
                {
                  "name": "implementation",
                  "type": ""
                }
              ],
              "return_type": "DIContainer",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 365
            },
            {
              "name": "register_transient",
              "module": "system_infrastructure",
              "signature": "def register_transient(self, service_type: Type[T], implementation: ) -> DIContainer",
              "docstring": "Register transient service (#S10).\n\nNew instance created for each resolution.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_type",
                  "type": "Type[T]"
                },
                {
                  "name": "implementation",
                  "type": ""
                }
              ],
              "return_type": "DIContainer",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 401
            },
            {
              "name": "register_scoped",
              "module": "system_infrastructure",
              "signature": "def register_scoped(self, service_type: Type[T], implementation: ) -> DIContainer",
              "docstring": "Register scoped service (#S10).\n\nOne instance per scope (child container).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_type",
                  "type": "Type[T]"
                },
                {
                  "name": "implementation",
                  "type": ""
                }
              ],
              "return_type": "DIContainer",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 423
            },
            {
              "name": "register_factory",
              "module": "system_infrastructure",
              "signature": "def register_factory(self, service_type: Type[T], factory: Callable[, T], scope: Scope) -> DIContainer",
              "docstring": "Register factory function (#S10).\n\nArgs:\n    service_type: Type to register\n    factory: Function taking container and returning instance\n    scope: Lifetime scope",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_type",
                  "type": "Type[T]"
                },
                {
                  "name": "factory",
                  "type": "Callable[, T]"
                },
                {
                  "name": "scope",
                  "type": "Scope"
                }
              ],
              "return_type": "DIContainer",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 445
            },
            {
              "name": "resolve",
              "module": "system_infrastructure",
              "signature": "def resolve(self, service_type: Type[T]) -> T",
              "docstring": "Resolve service from container (#S10).\n\nArgs:\n    service_type: Type to resolve\n\nReturns:\n    Service instance\n\nRaises:\n    ValueError: If service not registered\n    RuntimeError: If circular dependency detected",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_type",
                  "type": "Type[T]"
                }
              ],
              "return_type": "T",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 469
            },
            {
              "name": "_create_instance",
              "module": "system_infrastructure",
              "signature": "def _create_instance(self, impl_type: Type) -> object",
              "docstring": "Create instance with constructor injection.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "impl_type",
                  "type": "Type"
                }
              ],
              "return_type": "object",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 525
            },
            {
              "name": "create_scope",
              "module": "system_infrastructure",
              "signature": "def create_scope(self) -> DIContainer",
              "docstring": "Create child container for scoped resolution (#S10).\n\nReturns:\n    New container with this as parent",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "DIContainer",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 549
            },
            {
              "name": "try_resolve",
              "module": "system_infrastructure",
              "signature": "def try_resolve(self, service_type: Type[T])",
              "docstring": "Try to resolve service, returning None if not found.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_type",
                  "type": "Type[T]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 558
            },
            {
              "name": "is_registered",
              "module": "system_infrastructure",
              "signature": "def is_registered(self, service_type: Type) -> bool",
              "docstring": "Check if service is registered.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_type",
                  "type": "Type"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 565
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 346
        },
        {
          "name": "SpanContext",
          "module": "system_infrastructure",
          "docstring": "Context for a trace span (#S12).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "system_infrastructure",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 619
            }
          ],
          "class_attributes": [
            {
              "name": "trace_id",
              "type": "str"
            },
            {
              "name": "span_id",
              "type": "str"
            },
            {
              "name": "parent_span_id",
              "type": ""
            },
            {
              "name": "operation_name",
              "type": "str"
            },
            {
              "name": "service_name",
              "type": "str"
            },
            {
              "name": "start_time",
              "type": "datetime"
            },
            {
              "name": "end_time",
              "type": ""
            },
            {
              "name": "status",
              "type": "str"
            },
            {
              "name": "tags",
              "type": "dict[str, str]"
            },
            {
              "name": "logs",
              "type": "list[dict]"
            },
            {
              "name": "baggage",
              "type": "dict[str, str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 605
        },
        {
          "name": "TraceContext",
          "module": "system_infrastructure",
          "docstring": "Trace context for distributed tracing (#S12).\n\nFollows OpenTelemetry-like semantics.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "system_infrastructure",
              "signature": "def __init__(self, trace_id: , parent_span_id: , baggage: )",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trace_id",
                  "type": ""
                },
                {
                  "name": "parent_span_id",
                  "type": ""
                },
                {
                  "name": "baggage",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 646
            },
            {
              "name": "_generate_trace_id",
              "module": "system_infrastructure",
              "signature": "def _generate_trace_id() -> str",
              "docstring": "Generate unique trace ID.",
              "parameters": [],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 659
            },
            {
              "name": "_generate_span_id",
              "module": "system_infrastructure",
              "signature": "def _generate_span_id() -> str",
              "docstring": "Generate unique span ID.",
              "parameters": [],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 664
            },
            {
              "name": "start_span",
              "module": "system_infrastructure",
              "signature": "def start_span(self, operation_name: str, service_name: str, tags: ) -> SpanContext",
              "docstring": "Start a new span (#S12).\n\nArgs:\n    operation_name: Name of operation\n    service_name: Name of service\n    tags: Initial tags\n\nReturns:\n    New span context",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation_name",
                  "type": "str"
                },
                {
                  "name": "service_name",
                  "type": "str"
                },
                {
                  "name": "tags",
                  "type": ""
                }
              ],
              "return_type": "SpanContext",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 668
            },
            {
              "name": "end_span",
              "module": "system_infrastructure",
              "signature": "def end_span(self, span: , status: str, error: ) -> None",
              "docstring": "End a span (#S12).\n\nArgs:\n    span: Span to end (current if None)\n    status: Final status\n    error: Error message if failed",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "span",
                  "type": ""
                },
                {
                  "name": "status",
                  "type": "str"
                },
                {
                  "name": "error",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 703
            },
            {
              "name": "add_tag",
              "module": "system_infrastructure",
              "signature": "def add_tag(self, key: str, value: str, span: ) -> None",
              "docstring": "Add tag to span.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "str"
                },
                {
                  "name": "span",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 739
            },
            {
              "name": "add_log",
              "module": "system_infrastructure",
              "signature": "def add_log(self, message: str, level: str, span: ) -> None",
              "docstring": "Add log entry to span.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "message",
                  "type": "str"
                },
                {
                  "name": "level",
                  "type": "str"
                },
                {
                  "name": "span",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 745
            },
            {
              "name": "set_baggage",
              "module": "system_infrastructure",
              "signature": "def set_baggage(self, key: str, value: str) -> None",
              "docstring": "Set baggage item (propagates to child spans).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "key",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "str"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 760
            },
            {
              "name": "get_spans",
              "module": "system_infrastructure",
              "signature": "def get_spans(self) -> list[SpanContext]",
              "docstring": "Get all spans in trace.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[SpanContext]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 764
            },
            {
              "name": "current_span",
              "module": "system_infrastructure",
              "signature": "def current_span(self)",
              "docstring": "Get current span.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 769
            },
            {
              "name": "to_dict",
              "module": "system_infrastructure",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 773
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 639
        },
        {
          "name": "DistributedTracer",
          "module": "system_infrastructure",
          "docstring": "Distributed tracing manager (#S12).\n\nFeatures:\n- Trace context propagation\n- Span creation and management\n- Trace collection and export\n- Sampling",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "system_infrastructure",
              "signature": "def __init__(self, service_name: str, sampling_rate: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "service_name",
                  "type": "str"
                },
                {
                  "name": "sampling_rate",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 792
            },
            {
              "name": "register_exporter",
              "module": "system_infrastructure",
              "signature": "def register_exporter(self, exporter: Callable[, None]) -> None",
              "docstring": "Register trace exporter.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exporter",
                  "type": "Callable[, None]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 806
            },
            {
              "name": "start_trace",
              "module": "system_infrastructure",
              "signature": "def start_trace(self, operation_name: str, parent_trace_id: , parent_span_id: , baggage: ) -> TraceContext",
              "docstring": "Start a new trace (#S12).\n\nArgs:\n    operation_name: Root operation name\n    parent_trace_id: ID of parent trace (for distributed tracing)\n    parent_span_id: ID of parent span\n    baggage: Initial baggage\n\nReturns:\n    New trace context",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "operation_name",
                  "type": "str"
                },
                {
                  "name": "parent_trace_id",
                  "type": ""
                },
                {
                  "name": "parent_span_id",
                  "type": ""
                },
                {
                  "name": "baggage",
                  "type": ""
                }
              ],
              "return_type": "TraceContext",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 810
            },
            {
              "name": "end_trace",
              "module": "system_infrastructure",
              "signature": "def end_trace(self, trace: ) -> None",
              "docstring": "End a trace and export (#S12).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trace",
                  "type": ""
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 852
            },
            {
              "name": "get_current_trace",
              "module": "system_infrastructure",
              "signature": "def get_current_trace()",
              "docstring": "Get current trace context.",
              "parameters": [],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [
                "staticmethod"
              ],
              "is_async": false,
              "line_number": 880
            },
            {
              "name": "inject_headers",
              "module": "system_infrastructure",
              "signature": "def inject_headers(self, trace: ) -> dict[str, str]",
              "docstring": "Inject trace context into HTTP headers (#S12).\n\nReturns headers for propagation.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "trace",
                  "type": ""
                }
              ],
              "return_type": "dict[str, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 884
            },
            {
              "name": "extract_headers",
              "module": "system_infrastructure",
              "signature": "def extract_headers(self, headers: dict[str, str]) -> tuple[, , dict]",
              "docstring": "Extract trace context from HTTP headers (#S12).\n\nReturns (trace_id, span_id, baggage).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "headers",
                  "type": "dict[str, str]"
                }
              ],
              "return_type": "tuple[, , dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 907
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 781
        }
      ],
      "functions": [
        {
          "name": "inject",
          "module": "system_infrastructure",
          "signature": "def inject(service_type: Type[T]) -> Callable[, Callable]",
          "docstring": "Decorator for dependency injection (#S10).\n\nUsage:\n    @inject(MyService)\n    def my_function(service: MyService):\n        ...",
          "parameters": [
            {
              "name": "service_type",
              "type": "Type[T]"
            }
          ],
          "return_type": "Callable[, Callable]",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 574
        },
        {
          "name": "traced",
          "module": "system_infrastructure",
          "signature": "def traced(operation_name: )",
          "docstring": "Decorator for tracing functions (#S12).\n\nSupports both sync and async functions.\n\nUsage:\n    @traced(\"process_order\")\n    def process_order(order_id: str):\n        ...\n\n    @traced(\"async_process\")\n    async def async_process(order_id: str):\n        ...",
          "parameters": [
            {
              "name": "operation_name",
              "type": ""
            }
          ],
          "return_type": "",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 925
        },
        {
          "name": "log_trace_exporter",
          "module": "system_infrastructure",
          "signature": "def log_trace_exporter(trace: TraceContext) -> None",
          "docstring": "Export trace to logs.",
          "parameters": [
            {
              "name": "trace",
              "type": "TraceContext"
            }
          ],
          "return_type": "None",
          "raises": [],
          "examples": [],
          "decorators": [],
          "is_async": false,
          "line_number": 986
        }
      ],
      "constants": [
        {
          "name": "T",
          "line": 326
        }
      ],
      "imports": [
        "__future__",
        "asyncio",
        "inspect",
        "logging",
        "os",
        "json",
        "yaml",
        "hashlib",
        "threading",
        "time",
        "uuid",
        "contextvars",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "functools",
        "collections",
        "weakref",
        "inspect",
        "random"
      ],
      "dependencies": [
        "__future__",
        "inspect",
        "yaml",
        "hashlib",
        "threading",
        "time",
        "uuid",
        "contextvars",
        "weakref",
        "inspect",
        "random"
      ]
    },
    "core.technical_indicators": {
      "name": "technical_indicators",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\technical_indicators.py",
      "docstring": "Technical Indicators Module\n===========================\n\nComprehensive technical analysis indicators (Issues #Q13, #Q14, #Q15).\n\nFeatures:\n- ADX (Average Directional Index) trend strength\n- Bollinger Bands with squeeze detection\n- Volume-weighted indicators (VWAP, OBV, MFI)\n- Additional momentum and trend indicators",
      "classes": [
        {
          "name": "OHLCV",
          "module": "technical_indicators",
          "docstring": "Single OHLCV bar.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "open",
              "type": "float"
            },
            {
              "name": "high",
              "type": "float"
            },
            {
              "name": "low",
              "type": "float"
            },
            {
              "name": "close",
              "type": "float"
            },
            {
              "name": "volume",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 29
        },
        {
          "name": "ADXResult",
          "module": "technical_indicators",
          "docstring": "ADX calculation result (Issue #Q13).",
          "bases": [],
          "methods": [
            {
              "name": "trend_strength",
              "module": "technical_indicators",
              "signature": "def trend_strength(self) -> str",
              "docstring": "Classify trend strength.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 48
            },
            {
              "name": "trend_direction",
              "module": "technical_indicators",
              "signature": "def trend_direction(self) -> str",
              "docstring": "Determine trend direction.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 60
            }
          ],
          "class_attributes": [
            {
              "name": "adx",
              "type": "float"
            },
            {
              "name": "plus_di",
              "type": "float"
            },
            {
              "name": "minus_di",
              "type": "float"
            },
            {
              "name": "dx",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 40
        },
        {
          "name": "ADXCalculator",
          "module": "technical_indicators",
          "docstring": "Average Directional Index calculator (Issue #Q13).\n\nADX measures trend strength without regard to direction.\nValues above 25 indicate trending market.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, period: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 78
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, bar: OHLCV)",
              "docstring": "Update with new bar and return ADX result.\n\nReturns None until enough data is accumulated.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OHLCV"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 95
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 70
        },
        {
          "name": "BollingerBandsResult",
          "module": "technical_indicators",
          "docstring": "Bollinger Bands result (Issue #Q14).",
          "bases": [],
          "methods": [
            {
              "name": "is_squeeze",
              "module": "technical_indicators",
              "signature": "def is_squeeze(self) -> bool",
              "docstring": "Detect Bollinger squeeze (low volatility).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 183
            },
            {
              "name": "position",
              "module": "technical_indicators",
              "signature": "def position(self) -> str",
              "docstring": "Price position within bands.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "str",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 188
            }
          ],
          "class_attributes": [
            {
              "name": "upper",
              "type": "float"
            },
            {
              "name": "middle",
              "type": "float"
            },
            {
              "name": "lower",
              "type": "float"
            },
            {
              "name": "bandwidth",
              "type": "float"
            },
            {
              "name": "percent_b",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 174
        },
        {
          "name": "BollingerBandsCalculator",
          "module": "technical_indicators",
          "docstring": "Bollinger Bands calculator (Issue #Q14).\n\nBands based on SMA and standard deviation.\nUseful for volatility and mean reversion signals.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, period: int, std_dev: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "period",
                  "type": "int"
                },
                {
                  "name": "std_dev",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 210
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, close: float)",
              "docstring": "Update with new close and return bands.\n\nReturns None until enough data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "close",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 216
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 202
        },
        {
          "name": "VWAPResult",
          "module": "technical_indicators",
          "docstring": "VWAP calculation result (Issue #Q15).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "vwap",
              "type": "float"
            },
            {
              "name": "upper_band",
              "type": "float"
            },
            {
              "name": "lower_band",
              "type": "float"
            },
            {
              "name": "cumulative_volume",
              "type": "float"
            },
            {
              "name": "deviation_pct",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 248
        },
        {
          "name": "VWAPCalculator",
          "module": "technical_indicators",
          "docstring": "Volume Weighted Average Price calculator (Issue #Q15).\n\nIntraday benchmark for institutional execution.\nResets daily.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, use_bands: bool, band_std: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "use_bands",
                  "type": "bool"
                },
                {
                  "name": "band_std",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 265
            },
            {
              "name": "reset",
              "module": "technical_indicators",
              "signature": "def reset(self) -> None",
              "docstring": "Reset for new trading day.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 274
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, bar: OHLCV)",
              "docstring": "Update with new bar and return VWAP.\n\nAutomatically resets on new day.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OHLCV"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 280
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 257
        },
        {
          "name": "OBVResult",
          "module": "technical_indicators",
          "docstring": "On Balance Volume result (Issue #Q15).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "obv",
              "type": "float"
            },
            {
              "name": "obv_ema",
              "type": "float"
            },
            {
              "name": "signal",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 329
        },
        {
          "name": "OBVCalculator",
          "module": "technical_indicators",
          "docstring": "On Balance Volume calculator (Issue #Q15).\n\nCumulative volume indicator for trend confirmation.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, ema_period: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "ema_period",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 343
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, close: float, volume: float)",
              "docstring": "Update with new close/volume and return OBV.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "close",
                  "type": "float"
                },
                {
                  "name": "volume",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 352
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 336
        },
        {
          "name": "MFIResult",
          "module": "technical_indicators",
          "docstring": "Money Flow Index result (Issue #Q15).",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "mfi",
              "type": "float"
            },
            {
              "name": "overbought",
              "type": "bool"
            },
            {
              "name": "oversold",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 392
        },
        {
          "name": "MFICalculator",
          "module": "technical_indicators",
          "docstring": "Money Flow Index calculator (Issue #Q15).\n\nVolume-weighted RSI that incorporates price and volume.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, period: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 406
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, bar: OHLCV)",
              "docstring": "Update with new bar and return MFI.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OHLCV"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 412
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 399
        },
        {
          "name": "ATRResult",
          "module": "technical_indicators",
          "docstring": "Average True Range result.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "atr",
              "type": "float"
            },
            {
              "name": "atr_percent",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 450
        },
        {
          "name": "ATRCalculator",
          "module": "technical_indicators",
          "docstring": "Average True Range calculator.\n\nMeasures volatility.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, period: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 463
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, bar: OHLCV)",
              "docstring": "Update with new bar and return ATR.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OHLCV"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 469
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 456
        },
        {
          "name": "StochasticResult",
          "module": "technical_indicators",
          "docstring": "Stochastic Oscillator result.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "k",
              "type": "float"
            },
            {
              "name": "d",
              "type": "float"
            },
            {
              "name": "overbought",
              "type": "bool"
            },
            {
              "name": "oversold",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 496
        },
        {
          "name": "StochasticCalculator",
          "module": "technical_indicators",
          "docstring": "Stochastic Oscillator calculator.\n\nMomentum indicator comparing close to high-low range.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, k_period: int, d_period: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "k_period",
                  "type": "int"
                },
                {
                  "name": "d_period",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 511
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, bar: OHLCV)",
              "docstring": "Update with new bar and return Stochastic.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OHLCV"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 520
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 504
        },
        {
          "name": "KeltnerChannelResult",
          "module": "technical_indicators",
          "docstring": "Keltner Channel result.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "upper",
              "type": "float"
            },
            {
              "name": "middle",
              "type": "float"
            },
            {
              "name": "lower",
              "type": "float"
            },
            {
              "name": "width_pct",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 557
        },
        {
          "name": "KeltnerChannelCalculator",
          "module": "technical_indicators",
          "docstring": "Keltner Channel calculator.\n\nEMA-based bands using ATR for width.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, ema_period: int, atr_period: int, atr_mult: float)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "ema_period",
                  "type": "int"
                },
                {
                  "name": "atr_period",
                  "type": "int"
                },
                {
                  "name": "atr_mult",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 572
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, bar: OHLCV)",
              "docstring": "Update with new bar and return Keltner Channel.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OHLCV"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 580
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 565
        },
        {
          "name": "TechnicalIndicatorSuite",
          "module": "technical_indicators",
          "docstring": "Comprehensive technical indicator suite.\n\nCombines multiple indicators for signal generation.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "technical_indicators",
              "signature": "def __init__(self, adx_period: int, bb_period: int, bb_std: float, mfi_period: int, atr_period: int)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "adx_period",
                  "type": "int"
                },
                {
                  "name": "bb_period",
                  "type": "int"
                },
                {
                  "name": "bb_std",
                  "type": "float"
                },
                {
                  "name": "mfi_period",
                  "type": "int"
                },
                {
                  "name": "atr_period",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 615
            },
            {
              "name": "update",
              "module": "technical_indicators",
              "signature": "def update(self, bar: OHLCV) -> dict[str, Any]",
              "docstring": "Update all indicators with new bar.\n\nReturns dictionary of indicator results.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OHLCV"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 632
            },
            {
              "name": "get_composite_signal",
              "module": "technical_indicators",
              "signature": "def get_composite_signal(self, bar: OHLCV) -> dict[str, Any]",
              "docstring": "Get composite trading signal from all indicators.\n\nReturns signal strength and direction.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bar",
                  "type": "OHLCV"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 715
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 608
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections"
      ],
      "dependencies": [
        "__future__"
      ]
    },
    "core.time_based_risk": {
      "name": "time_based_risk",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\time_based_risk.py",
      "docstring": "Time-Based Risk Module\n======================\n\nRisk limits that are time-of-day aware (Issue #R19).\nOvernight vs intraday risk differentiation (Issue #R22).\n\nFeatures:\n- Time-of-day dependent risk limits\n- Market hours awareness\n- Overnight position limits\n- Intraday vs overnight risk metrics",
      "classes": [
        {
          "name": "TradingSession",
          "module": "time_based_risk",
          "docstring": "Trading session periods.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 27
        },
        {
          "name": "RiskLevel",
          "module": "time_based_risk",
          "docstring": "Risk level classification.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 40
        },
        {
          "name": "SessionRiskLimits",
          "module": "time_based_risk",
          "docstring": "Risk limits for a trading session.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "time_based_risk",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 69
            }
          ],
          "class_attributes": [
            {
              "name": "session",
              "type": "TradingSession"
            },
            {
              "name": "max_position_pct",
              "type": "float"
            },
            {
              "name": "max_new_orders_pct",
              "type": "float"
            },
            {
              "name": "max_var_pct",
              "type": "float"
            },
            {
              "name": "max_concentration_pct",
              "type": "float"
            },
            {
              "name": "min_order_interval_ms",
              "type": "float"
            },
            {
              "name": "max_market_orders",
              "type": "bool"
            },
            {
              "name": "vol_multiplier",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 50
        },
        {
          "name": "OvernightRiskMetrics",
          "module": "time_based_risk",
          "docstring": "Overnight risk metrics (#R22).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "time_based_risk",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 109
            }
          ],
          "class_attributes": [
            {
              "name": "as_of",
              "type": "datetime"
            },
            {
              "name": "total_overnight_exposure",
              "type": "float"
            },
            {
              "name": "long_exposure",
              "type": "float"
            },
            {
              "name": "short_exposure",
              "type": "float"
            },
            {
              "name": "net_exposure",
              "type": "float"
            },
            {
              "name": "overnight_var",
              "type": "float"
            },
            {
              "name": "overnight_var_pct",
              "type": "float"
            },
            {
              "name": "estimated_gap_risk",
              "type": "float"
            },
            {
              "name": "gap_risk_pct",
              "type": "float"
            },
            {
              "name": "exposure_by_asset",
              "type": "dict[str, float]"
            },
            {
              "name": "var_by_asset",
              "type": "dict[str, float]"
            },
            {
              "name": "exposure_vs_intraday_avg",
              "type": "float"
            },
            {
              "name": "var_vs_intraday_avg",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 83
        },
        {
          "name": "IntradayRiskMetrics",
          "module": "time_based_risk",
          "docstring": "Intraday risk metrics (#R22).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "time_based_risk",
              "signature": "def to_dict(self) -> dict",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 149
            }
          ],
          "class_attributes": [
            {
              "name": "as_of",
              "type": "datetime"
            },
            {
              "name": "session",
              "type": "TradingSession"
            },
            {
              "name": "current_exposure",
              "type": "float"
            },
            {
              "name": "peak_exposure_today",
              "type": "float"
            },
            {
              "name": "avg_exposure_today",
              "type": "float"
            },
            {
              "name": "current_var",
              "type": "float"
            },
            {
              "name": "peak_var_today",
              "type": "float"
            },
            {
              "name": "orders_today",
              "type": "int"
            },
            {
              "name": "trades_today",
              "type": "int"
            },
            {
              "name": "pnl_today",
              "type": "float"
            },
            {
              "name": "time_to_close_minutes",
              "type": "float"
            },
            {
              "name": "vol_regime",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 126
        },
        {
          "name": "TimeBasedRiskManager",
          "module": "time_based_risk",
          "docstring": "Manages time-of-day dependent risk limits (#R19).\n\nAdjusts risk limits based on market session and time.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "time_based_risk",
              "signature": "def __init__(self, base_var_limit: float, base_position_limit: float, timezone_str: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "base_var_limit",
                  "type": "float"
                },
                {
                  "name": "base_position_limit",
                  "type": "float"
                },
                {
                  "name": "timezone_str",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 256
            },
            {
              "name": "add_holiday",
              "module": "time_based_risk",
              "signature": "def add_holiday(self, holiday: date) -> None",
              "docstring": "Add a market holiday.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "holiday",
                  "type": "date"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 273
            },
            {
              "name": "add_half_day",
              "module": "time_based_risk",
              "signature": "def add_half_day(self, half_day: date) -> None",
              "docstring": "Add a half-day (early close).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "half_day",
                  "type": "date"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 277
            },
            {
              "name": "set_custom_limits",
              "module": "time_based_risk",
              "signature": "def set_custom_limits(self, session: TradingSession, limits: SessionRiskLimits) -> None",
              "docstring": "Override default limits for a session.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "session",
                  "type": "TradingSession"
                },
                {
                  "name": "limits",
                  "type": "SessionRiskLimits"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 281
            },
            {
              "name": "get_current_session",
              "module": "time_based_risk",
              "signature": "def get_current_session(self, dt: ) -> TradingSession",
              "docstring": "Get current trading session.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "dt",
                  "type": ""
                }
              ],
              "return_type": "TradingSession",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 285
            },
            {
              "name": "get_session_limits",
              "module": "time_based_risk",
              "signature": "def get_session_limits(self, session: ) -> SessionRiskLimits",
              "docstring": "Get risk limits for a session.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "session",
                  "type": ""
                }
              ],
              "return_type": "SessionRiskLimits",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 319
            },
            {
              "name": "get_effective_limits",
              "module": "time_based_risk",
              "signature": "def get_effective_limits(self, dt: ) -> dict",
              "docstring": "Get effective risk limits for current time.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "dt",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 333
            },
            {
              "name": "check_limit",
              "module": "time_based_risk",
              "signature": "def check_limit(self, current_position: float, current_var: float, proposed_order_size: float, is_market_order: bool) -> dict",
              "docstring": "Check if proposed action is within time-based limits.\n\nReturns dict with 'allowed' and any violations.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_position",
                  "type": "float"
                },
                {
                  "name": "current_var",
                  "type": "float"
                },
                {
                  "name": "proposed_order_size",
                  "type": "float"
                },
                {
                  "name": "is_market_order",
                  "type": "bool"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 353
            },
            {
              "name": "get_time_to_session_change",
              "module": "time_based_risk",
              "signature": "def get_time_to_session_change(self) -> timedelta",
              "docstring": "Get time until next session change.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "timedelta",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 398
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 165
        },
        {
          "name": "OvernightRiskManager",
          "module": "time_based_risk",
          "docstring": "Manages overnight vs intraday risk (#R22).\n\nDifferentiates risk treatment based on holding period.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "time_based_risk",
              "signature": "def __init__(self, overnight_var_multiplier: float, gap_risk_pct: float, max_overnight_exposure_pct: float, timezone_str: str)",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "overnight_var_multiplier",
                  "type": "float"
                },
                {
                  "name": "gap_risk_pct",
                  "type": "float"
                },
                {
                  "name": "max_overnight_exposure_pct",
                  "type": "float"
                },
                {
                  "name": "timezone_str",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 429
            },
            {
              "name": "update_position",
              "module": "time_based_risk",
              "signature": "def update_position(self, symbol: str, quantity: int, value: float, asset_class: str, beta: float) -> None",
              "docstring": "Update position for overnight tracking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "quantity",
                  "type": "int"
                },
                {
                  "name": "value",
                  "type": "float"
                },
                {
                  "name": "asset_class",
                  "type": "str"
                },
                {
                  "name": "beta",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 463
            },
            {
              "name": "record_trade",
              "module": "time_based_risk",
              "signature": "def record_trade(self, pnl: float) -> None",
              "docstring": "Record a trade execution.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pnl",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 479
            },
            {
              "name": "record_order",
              "module": "time_based_risk",
              "signature": "def record_order(self) -> None",
              "docstring": "Record an order submission.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 484
            },
            {
              "name": "record_exposure",
              "module": "time_based_risk",
              "signature": "def record_exposure(self, exposure: float, var: float) -> None",
              "docstring": "Record current exposure for intraday tracking.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "exposure",
                  "type": "float"
                },
                {
                  "name": "var",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 488
            },
            {
              "name": "_reset_daily_tracking",
              "module": "time_based_risk",
              "signature": "def _reset_daily_tracking(self) -> None",
              "docstring": "Reset daily tracking metrics.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 501
            },
            {
              "name": "calculate_overnight_risk",
              "module": "time_based_risk",
              "signature": "def calculate_overnight_risk(self, account_equity: float) -> OvernightRiskMetrics",
              "docstring": "Calculate overnight risk metrics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_equity",
                  "type": "float"
                }
              ],
              "return_type": "OvernightRiskMetrics",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 510
            },
            {
              "name": "calculate_intraday_risk",
              "module": "time_based_risk",
              "signature": "def calculate_intraday_risk(self, current_exposure: float, current_var: float) -> IntradayRiskMetrics",
              "docstring": "Calculate intraday risk metrics.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_exposure",
                  "type": "float"
                },
                {
                  "name": "current_var",
                  "type": "float"
                }
              ],
              "return_type": "IntradayRiskMetrics",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 572
            },
            {
              "name": "check_overnight_limits",
              "module": "time_based_risk",
              "signature": "def check_overnight_limits(self, account_equity: float) -> dict",
              "docstring": "Check if overnight position limits are exceeded.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_equity",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 621
            },
            {
              "name": "suggest_position_reduction",
              "module": "time_based_risk",
              "signature": "def suggest_position_reduction(self, account_equity: float) -> list[dict]",
              "docstring": "Suggest positions to reduce for overnight limits.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "account_equity",
                  "type": "float"
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 652
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 422
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "zoneinfo"
      ],
      "dependencies": [
        "__future__",
        "zoneinfo"
      ]
    },
    "core.var_backtest": {
      "name": "var_backtest",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\var_backtest.py",
      "docstring": "VaR Backtesting Module\n======================\n\nAddresses issue #R28: Historical VaR backtest missing.\n\nFeatures:\n- VaR model validation through backtesting\n- Kupiec POF test for exception analysis\n- Christoffersen independence test\n- Traffic light framework (Basel)\n- Backtesting reports and visualization data",
      "classes": [
        {
          "name": "VaRBacktestZone",
          "module": "var_backtest",
          "docstring": "Basel traffic light zones for VaR backtesting.",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 29
        },
        {
          "name": "VaRException",
          "module": "var_backtest",
          "docstring": "A single VaR exception (loss exceeded VaR).",
          "bases": [],
          "methods": [
            {
              "name": "exception_severity",
              "module": "var_backtest",
              "signature": "def exception_severity(self) -> float",
              "docstring": "Severity as ratio of loss to VaR.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 45
            }
          ],
          "class_attributes": [
            {
              "name": "date",
              "type": "datetime"
            },
            {
              "name": "var_estimate",
              "type": "float"
            },
            {
              "name": "actual_loss",
              "type": "float"
            },
            {
              "name": "excess",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 37
        },
        {
          "name": "KupiecTestResult",
          "module": "var_backtest",
          "docstring": "Result of Kupiec POF (Proportion of Failures) test.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "var_backtest",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 64
            }
          ],
          "class_attributes": [
            {
              "name": "test_statistic",
              "type": "float"
            },
            {
              "name": "p_value",
              "type": "float"
            },
            {
              "name": "is_rejected",
              "type": "bool"
            },
            {
              "name": "observed_exceptions",
              "type": "int"
            },
            {
              "name": "expected_exceptions",
              "type": "float"
            },
            {
              "name": "exception_rate",
              "type": "float"
            },
            {
              "name": "confidence_level",
              "type": "float"
            },
            {
              "name": "significance_level",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 53
        },
        {
          "name": "ChristoffersenTestResult",
          "module": "var_backtest",
          "docstring": "Result of Christoffersen independence test.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "var_backtest",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 86
            }
          ],
          "class_attributes": [
            {
              "name": "test_statistic",
              "type": "float"
            },
            {
              "name": "p_value",
              "type": "float"
            },
            {
              "name": "is_rejected",
              "type": "bool"
            },
            {
              "name": "cluster_ratio",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 79
        },
        {
          "name": "VaRBacktestResult",
          "module": "var_backtest",
          "docstring": "Complete VaR backtest result.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "var_backtest",
              "signature": "def to_dict(self) -> dict",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 129
            }
          ],
          "class_attributes": [
            {
              "name": "start_date",
              "type": "datetime"
            },
            {
              "name": "end_date",
              "type": "datetime"
            },
            {
              "name": "total_observations",
              "type": "int"
            },
            {
              "name": "var_confidence_level",
              "type": "float"
            },
            {
              "name": "total_exceptions",
              "type": "int"
            },
            {
              "name": "exception_rate",
              "type": "float"
            },
            {
              "name": "expected_exceptions",
              "type": "float"
            },
            {
              "name": "exceptions",
              "type": "list[VaRException]"
            },
            {
              "name": "kupiec_test",
              "type": "KupiecTestResult"
            },
            {
              "name": "christoffersen_test",
              "type": ""
            },
            {
              "name": "zone",
              "type": "VaRBacktestZone"
            },
            {
              "name": "zone_reason",
              "type": "str"
            },
            {
              "name": "avg_exception_severity",
              "type": "float"
            },
            {
              "name": "max_exception_severity",
              "type": "float"
            },
            {
              "name": "avg_var_estimate",
              "type": "float"
            },
            {
              "name": "avg_actual_return",
              "type": "float"
            },
            {
              "name": "var_series",
              "type": "list[tuple[datetime, float]]"
            },
            {
              "name": "return_series",
              "type": "list[tuple[datetime, float]]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 97
        },
        {
          "name": "VaRBacktester",
          "module": "var_backtest",
          "docstring": "VaR model backtesting framework (#R28).\n\nValidates VaR models using historical exceptions analysis\nand statistical tests.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "var_backtest",
              "signature": "def __init__(self, confidence_level: float, significance_level: float)",
              "docstring": "Initialize backtester.\n\nArgs:\n    confidence_level: VaR confidence level (e.g., 0.95 for 95%)\n    significance_level: Statistical test significance level",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "confidence_level",
                  "type": "float"
                },
                {
                  "name": "significance_level",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 168
            },
            {
              "name": "add_observation",
              "module": "var_backtest",
              "signature": "def add_observation(self, date: datetime, var_estimate: float, actual_return: float) -> None",
              "docstring": "Add a single observation for backtesting.\n\nArgs:\n    date: Observation date\n    var_estimate: VaR estimate (as positive number)\n    actual_return: Actual realized return (negative for loss)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "date",
                  "type": "datetime"
                },
                {
                  "name": "var_estimate",
                  "type": "float"
                },
                {
                  "name": "actual_return",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 185
            },
            {
              "name": "add_observations_bulk",
              "module": "var_backtest",
              "signature": "def add_observations_bulk(self, var_estimates: list[tuple[datetime, float]], actual_returns: list[tuple[datetime, float]]) -> None",
              "docstring": "Add multiple observations at once.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "var_estimates",
                  "type": "list[tuple[datetime, float]]"
                },
                {
                  "name": "actual_returns",
                  "type": "list[tuple[datetime, float]]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 202
            },
            {
              "name": "run_backtest",
              "module": "var_backtest",
              "signature": "def run_backtest(self) -> VaRBacktestResult",
              "docstring": "Run VaR backtest on accumulated observations.\n\nReturns:\n    VaRBacktestResult with comprehensive analysis",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "VaRBacktestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 211
            },
            {
              "name": "_kupiec_test",
              "module": "var_backtest",
              "signature": "def _kupiec_test(self, n: int, x: int) -> KupiecTestResult",
              "docstring": "Kupiec Proportion of Failures test.\n\nTests if the number of exceptions is consistent with\nthe VaR confidence level.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n",
                  "type": "int"
                },
                {
                  "name": "x",
                  "type": "int"
                }
              ],
              "return_type": "KupiecTestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 296
            },
            {
              "name": "_christoffersen_test",
              "module": "var_backtest",
              "signature": "def _christoffersen_test(self, indicators: list[int]) -> ChristoffersenTestResult",
              "docstring": "Christoffersen independence test.\n\nTests if exceptions are independently distributed\n(not clustered).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "indicators",
                  "type": "list[int]"
                }
              ],
              "return_type": "ChristoffersenTestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 336
            },
            {
              "name": "_determine_zone",
              "module": "var_backtest",
              "signature": "def _determine_zone(self, n: int, exceptions: int) -> tuple[VaRBacktestZone, str]",
              "docstring": "Determine Basel traffic light zone.\n\nBased on 250-day window at 99% confidence:\n- Green: 0-4 exceptions\n- Yellow: 5-9 exceptions\n- Red: 10+ exceptions\n\nScaled for other windows/confidence levels.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "n",
                  "type": "int"
                },
                {
                  "name": "exceptions",
                  "type": "int"
                }
              ],
              "return_type": "tuple[VaRBacktestZone, str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 395
            },
            {
              "name": "reset",
              "module": "var_backtest",
              "signature": "def reset(self) -> None",
              "docstring": "Reset accumulated observations.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 434
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 160
        },
        {
          "name": "RollingVaRBacktester",
          "module": "var_backtest",
          "docstring": "Rolling window VaR backtester for ongoing model validation.\n\nMaintains a rolling window of observations and periodically\nruns backtests.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "var_backtest",
              "signature": "def __init__(self, window_size: int, confidence_level: float, backtest_frequency: int)",
              "docstring": "Initialize rolling backtester.\n\nArgs:\n    window_size: Number of observations in rolling window\n    confidence_level: VaR confidence level\n    backtest_frequency: Days between automatic backtests",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "window_size",
                  "type": "int"
                },
                {
                  "name": "confidence_level",
                  "type": "float"
                },
                {
                  "name": "backtest_frequency",
                  "type": "int"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 448
            },
            {
              "name": "add_observation",
              "module": "var_backtest",
              "signature": "def add_observation(self, date: datetime, var_estimate: float, actual_return: float)",
              "docstring": "Add observation and potentially trigger backtest.\n\nReturns:\n    VaRBacktestResult if backtest was triggered, None otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "date",
                  "type": "datetime"
                },
                {
                  "name": "var_estimate",
                  "type": "float"
                },
                {
                  "name": "actual_return",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 471
            },
            {
              "name": "_run_backtest",
              "module": "var_backtest",
              "signature": "def _run_backtest(self) -> VaRBacktestResult",
              "docstring": "Run backtest on current window.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "VaRBacktestResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 499
            },
            {
              "name": "force_backtest",
              "module": "var_backtest",
              "signature": "def force_backtest(self)",
              "docstring": "Force immediate backtest if enough data.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 510
            },
            {
              "name": "get_last_result",
              "module": "var_backtest",
              "signature": "def get_last_result(self)",
              "docstring": "Get most recent backtest result.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 518
            },
            {
              "name": "get_exception_count",
              "module": "var_backtest",
              "signature": "def get_exception_count(self, lookback_days: ) -> int",
              "docstring": "Get exception count for recent period.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "lookback_days",
                  "type": ""
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 522
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 440
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "statistics",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "collections",
        "scipy.stats",
        "scipy.stats"
      ],
      "dependencies": [
        "__future__",
        "scipy.stats",
        "scipy.stats"
      ]
    },
    "core.var_calculator": {
      "name": "var_calculator",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\var_calculator.py",
      "docstring": "Value at Risk Calculator\n========================\n\nComprehensive VaR calculation with multiple methodologies:\n- Parametric (Variance-Covariance)\n- Historical Simulation\n- Monte Carlo Simulation\n- Incremental and Marginal VaR\n\nDesigned for institutional-grade risk management.",
      "classes": [
        {
          "name": "VaRMethod",
          "module": "var_calculator",
          "docstring": "VaR calculation methodology.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 48
        },
        {
          "name": "VaRResult",
          "module": "var_calculator",
          "docstring": "Result of VaR calculation.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "var_calculator",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 67
            }
          ],
          "class_attributes": [
            {
              "name": "method",
              "type": "VaRMethod"
            },
            {
              "name": "confidence_level",
              "type": "float"
            },
            {
              "name": "horizon_days",
              "type": "int"
            },
            {
              "name": "var_absolute",
              "type": "float"
            },
            {
              "name": "var_pct",
              "type": "float"
            },
            {
              "name": "expected_shortfall",
              "type": ""
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "details",
              "type": "dict[str, Any]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 56
        },
        {
          "name": "LiquidityProfile",
          "module": "var_calculator",
          "docstring": "Liquidity profile for a position (#R6).\n\nUsed to adjust VaR for liquidity risk factors:\n- Bid-ask spread (immediate cost)\n- Market impact (price movement from liquidating)\n- Time to liquidate (days to exit position)",
          "bases": [],
          "methods": [
            {
              "name": "days_to_liquidate",
              "module": "var_calculator",
              "signature": "def days_to_liquidate(self) -> float",
              "docstring": "Estimate days to liquidate position.\n\nAssumes max 10% of ADV per day participation rate.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 98
            },
            {
              "name": "market_impact_bps",
              "module": "var_calculator",
              "signature": "def market_impact_bps(self) -> float",
              "docstring": "Estimate market impact in basis points.\n\nUses square-root market impact model:\nImpact = sigma * sqrt(Q / ADV) * constant\n\nWhere constant is typically 0.5-1.0 for developed markets.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 111
            },
            {
              "name": "total_liquidity_cost_bps",
              "module": "var_calculator",
              "signature": "def total_liquidity_cost_bps(self) -> float",
              "docstring": "Total expected liquidity cost in basis points.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 136
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "average_daily_volume",
              "type": "float"
            },
            {
              "name": "bid_ask_spread_bps",
              "type": "float"
            },
            {
              "name": "volatility_daily",
              "type": "float"
            },
            {
              "name": "position_size",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 82
        },
        {
          "name": "LiquidityAdjustedVaRResult",
          "module": "var_calculator",
          "docstring": "Result of liquidity-adjusted VaR calculation (#R6).",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "var_calculator",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 153
            }
          ],
          "class_attributes": [
            {
              "name": "base_var",
              "type": "VaRResult"
            },
            {
              "name": "liquidity_var",
              "type": "float"
            },
            {
              "name": "total_var",
              "type": "float"
            },
            {
              "name": "liquidation_cost",
              "type": "float"
            },
            {
              "name": "liquidation_time_var",
              "type": "float"
            },
            {
              "name": "by_position",
              "type": "dict[str, dict[str, float]]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 144
        },
        {
          "name": "IncrementalVaRResult",
          "module": "var_calculator",
          "docstring": "Result of incremental/marginal VaR calculation.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "var_calculator",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 177
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "base_var",
              "type": "float"
            },
            {
              "name": "new_var",
              "type": "float"
            },
            {
              "name": "incremental_var",
              "type": "float"
            },
            {
              "name": "marginal_var",
              "type": "float"
            },
            {
              "name": "component_var",
              "type": "float"
            },
            {
              "name": "pct_contribution",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 167
        },
        {
          "name": "VaRCalculator",
          "module": "var_calculator",
          "docstring": "Comprehensive Value at Risk calculator.\n\nSupports multiple methodologies and provides detailed\nrisk decomposition for portfolio management.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "var_calculator",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize VaR calculator.\n\nArgs:\n    config: Configuration with:\n        - method: Default VaR method (default: \"all\")\n        - confidence_level: Default confidence (default: 0.95)\n        - horizon_days: Default horizon (default: 1)\n        - monte_carlo_simulations: MC iterations (default: 10000)\n        - decay_factor: EWMA decay for volatility (default: 0.94)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 198
            },
            {
              "name": "update_returns",
              "module": "var_calculator",
              "signature": "def update_returns(self, returns_dict: dict[str, np.ndarray]) -> None",
              "docstring": "Update returns data for VaR calculation.\n\nArgs:\n    returns_dict: Dictionary mapping symbols to returns arrays",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "returns_dict",
                  "type": "dict[str, np.ndarray]"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 227
            },
            {
              "name": "_build_covariance_matrix",
              "module": "var_calculator",
              "signature": "def _build_covariance_matrix(self, use_ewma: bool) -> np.ndarray",
              "docstring": "Build covariance matrix from returns data.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "use_ewma",
                  "type": "bool"
                }
              ],
              "return_type": "np.ndarray",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 241
            },
            {
              "name": "_ewma_covariance",
              "module": "var_calculator",
              "signature": "def _ewma_covariance(self, returns: np.ndarray) -> np.ndarray",
              "docstring": "Calculate EWMA covariance matrix.\n\nArgs:\n    returns: T x N matrix of returns\n\nReturns:\n    N x N covariance matrix",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "returns",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "np.ndarray",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 280
            },
            {
              "name": "calculate_parametric_var",
              "module": "var_calculator",
              "signature": "def calculate_parametric_var(self, positions: dict[str, float], portfolio_value: float, confidence_level: , horizon_days: ) -> VaRResult",
              "docstring": "Calculate Parametric (Variance-Covariance) VaR.\n\nAssumes returns are normally distributed.\n\nArgs:\n    positions: Dictionary of symbol to position value\n    portfolio_value: Total portfolio value\n    confidence_level: Confidence level (e.g., 0.95)\n    horizon_days: Time horizon in days\n\nReturns:\n    VaRResult with parametric VaR",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "confidence_level",
                  "type": ""
                },
                {
                  "name": "horizon_days",
                  "type": ""
                }
              ],
              "return_type": "VaRResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 309
            },
            {
              "name": "calculate_historical_var",
              "module": "var_calculator",
              "signature": "def calculate_historical_var(self, positions: dict[str, float], portfolio_value: float, confidence_level: , horizon_days: ) -> VaRResult",
              "docstring": "Calculate Historical Simulation VaR.\n\nUses actual historical returns distribution.\n\nArgs:\n    positions: Dictionary of symbol to position value\n    portfolio_value: Total portfolio value\n    confidence_level: Confidence level\n    horizon_days: Time horizon\n\nReturns:\n    VaRResult with historical VaR",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "confidence_level",
                  "type": ""
                },
                {
                  "name": "horizon_days",
                  "type": ""
                }
              ],
              "return_type": "VaRResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 376
            },
            {
              "name": "calculate_monte_carlo_var",
              "module": "var_calculator",
              "signature": "def calculate_monte_carlo_var(self, positions: dict[str, float], portfolio_value: float, confidence_level: , horizon_days: , n_simulations: ) -> VaRResult",
              "docstring": "Calculate Monte Carlo VaR.\n\nSimulates potential portfolio returns using the covariance structure.\n\nArgs:\n    positions: Dictionary of symbol to position value\n    portfolio_value: Total portfolio value\n    confidence_level: Confidence level\n    horizon_days: Time horizon\n    n_simulations: Number of simulations\n\nReturns:\n    VaRResult with Monte Carlo VaR",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "confidence_level",
                  "type": ""
                },
                {
                  "name": "horizon_days",
                  "type": ""
                },
                {
                  "name": "n_simulations",
                  "type": ""
                }
              ],
              "return_type": "VaRResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 450
            },
            {
              "name": "calculate_all_methods",
              "module": "var_calculator",
              "signature": "def calculate_all_methods(self, positions: dict[str, float], portfolio_value: float, confidence_level: , horizon_days: ) -> dict[VaRMethod, VaRResult]",
              "docstring": "Calculate VaR using all methods.\n\nArgs:\n    positions: Position values\n    portfolio_value: Total portfolio value\n    confidence_level: Confidence level\n    horizon_days: Time horizon\n\nReturns:\n    Dictionary of method to VaRResult",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "confidence_level",
                  "type": ""
                },
                {
                  "name": "horizon_days",
                  "type": ""
                }
              ],
              "return_type": "dict[VaRMethod, VaRResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 548
            },
            {
              "name": "calculate_incremental_var",
              "module": "var_calculator",
              "signature": "def calculate_incremental_var(self, positions: dict[str, float], portfolio_value: float, new_position_symbol: str, new_position_value: float, method: VaRMethod) -> IncrementalVaRResult",
              "docstring": "Calculate incremental VaR for adding a new position.\n\nArgs:\n    positions: Current positions\n    portfolio_value: Current portfolio value\n    new_position_symbol: Symbol to add\n    new_position_value: Value of new position\n    method: VaR calculation method\n\nReturns:\n    IncrementalVaRResult with decomposition",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "new_position_symbol",
                  "type": "str"
                },
                {
                  "name": "new_position_value",
                  "type": "float"
                },
                {
                  "name": "method",
                  "type": "VaRMethod"
                }
              ],
              "return_type": "IncrementalVaRResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 583
            },
            {
              "name": "calculate_component_var",
              "module": "var_calculator",
              "signature": "def calculate_component_var(self, positions: dict[str, float], portfolio_value: float) -> dict[str, IncrementalVaRResult]",
              "docstring": "Calculate component VaR for all positions.\n\nShows each position's contribution to total VaR.\n\nArgs:\n    positions: Current positions\n    portfolio_value: Portfolio value\n\nReturns:\n    Dictionary of symbol to IncrementalVaRResult",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "dict[str, IncrementalVaRResult]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 651
            },
            {
              "name": "stress_test_var",
              "module": "var_calculator",
              "signature": "def stress_test_var(self, positions: dict[str, float], portfolio_value: float, volatility_multiplier: float, correlation_override: ) -> VaRResult",
              "docstring": "Calculate stressed VaR with increased volatility.\n\nArgs:\n    positions: Current positions\n    portfolio_value: Portfolio value\n    volatility_multiplier: Factor to increase volatility\n    correlation_override: Override all correlations to this value\n\nReturns:\n    VaRResult under stressed conditions",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "volatility_multiplier",
                  "type": "float"
                },
                {
                  "name": "correlation_override",
                  "type": ""
                }
              ],
              "return_type": "VaRResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 718
            },
            {
              "name": "calculate_liquidity_adjusted_var",
              "module": "var_calculator",
              "signature": "def calculate_liquidity_adjusted_var(self, positions: dict[str, float], portfolio_value: float, liquidity_profiles: dict[str, LiquidityProfile], confidence_level: , horizon_days: , method: VaRMethod) -> LiquidityAdjustedVaRResult",
              "docstring": "Calculate liquidity-adjusted VaR (#R6).\n\nIncorporates three liquidity risk components:\n1. Direct liquidation cost (spread + market impact)\n2. Extended horizon VaR (for positions that take multiple days to liquidate)\n3. Liquidity-volatility correlation (liquidity often dries up during stress)\n\nArgs:\n    positions: Dictionary of symbol to position value\n    portfolio_value: Total portfolio value\n    liquidity_profiles: Liquidity profile for each position\n    confidence_level: Confidence level\n    horizon_days: Base time horizon\n    method: VaR calculation method for base VaR\n\nReturns:\n    LiquidityAdjustedVaRResult with decomposition",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "liquidity_profiles",
                  "type": "dict[str, LiquidityProfile]"
                },
                {
                  "name": "confidence_level",
                  "type": ""
                },
                {
                  "name": "horizon_days",
                  "type": ""
                },
                {
                  "name": "method",
                  "type": "VaRMethod"
                }
              ],
              "return_type": "LiquidityAdjustedVaRResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 781
            },
            {
              "name": "update_liquidity_profile",
              "module": "var_calculator",
              "signature": "def update_liquidity_profile(self, symbol: str, adv: float, bid_ask_spread_bps: float, position_size: float, volatility: ) -> LiquidityProfile",
              "docstring": "Create or update a liquidity profile for a symbol.\n\nArgs:\n    symbol: Instrument symbol\n    adv: Average daily volume\n    bid_ask_spread_bps: Typical bid-ask spread in basis points\n    position_size: Current position size in units\n    volatility: Daily volatility (uses returns data if None)\n\nReturns:\n    LiquidityProfile instance",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "adv",
                  "type": "float"
                },
                {
                  "name": "bid_ask_spread_bps",
                  "type": "float"
                },
                {
                  "name": "position_size",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": ""
                }
              ],
              "return_type": "LiquidityProfile",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 919
            },
            {
              "name": "get_status",
              "module": "var_calculator",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get calculator status for monitoring.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 955
            },
            {
              "name": "calculate_jump_adjusted_var",
              "module": "var_calculator",
              "signature": "def calculate_jump_adjusted_var(self, positions: dict[str, float], portfolio_value: float, confidence_level: , horizon_days: , jump_intensity: float, jump_mean: float, jump_std: float, n_simulations: ) -> VaRResult",
              "docstring": "Calculate VaR with jump-diffusion model for fat tails (#R9).\n\nUses Merton's jump-diffusion model to capture extreme events\nthat normal distributions miss. Returns are modeled as:\n\ndS/S = \u03bcdt + \u03c3dW + J*dN\n\nWhere:\n- dW is standard Brownian motion\n- dN is Poisson process with intensity \u03bb (jump_intensity)\n- J is jump size ~ Normal(jump_mean, jump_std)\n\nThis addresses the \"fat tails\" problem where market crashes\nare more frequent than normal distributions suggest.\n\nArgs:\n    positions: Dictionary of symbol to position value\n    portfolio_value: Total portfolio value\n    confidence_level: Confidence level (e.g., 0.99 for jump risk)\n    horizon_days: Time horizon\n    jump_intensity: Expected jumps per year (\u03bb, default 0.1 = 1 every 10 years)\n    jump_mean: Average jump size (default -5% for crash bias)\n    jump_std: Jump size volatility (default 10%)\n    n_simulations: Number of Monte Carlo paths\n\nReturns:\n    VaRResult with jump-adjusted VaR and tail statistics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                },
                {
                  "name": "confidence_level",
                  "type": ""
                },
                {
                  "name": "horizon_days",
                  "type": ""
                },
                {
                  "name": "jump_intensity",
                  "type": "float"
                },
                {
                  "name": "jump_mean",
                  "type": "float"
                },
                {
                  "name": "jump_std",
                  "type": "float"
                },
                {
                  "name": "n_simulations",
                  "type": ""
                }
              ],
              "return_type": "VaRResult",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 972
            },
            {
              "name": "calculate_fat_tail_metrics",
              "module": "var_calculator",
              "signature": "def calculate_fat_tail_metrics(self, positions: dict[str, float], portfolio_value: float) -> dict[str, Any]",
              "docstring": "Calculate comprehensive fat tail risk metrics (#R9).\n\nReturns metrics that capture tail risk beyond standard VaR:\n- Skewness and kurtosis\n- Tail ratio (losses vs gains)\n- Maximum drawdown in historical returns\n- Jump risk premium\n\nArgs:\n    positions: Position values\n    portfolio_value: Total portfolio value\n\nReturns:\n    Dictionary of fat tail metrics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "positions",
                  "type": "dict[str, float]"
                },
                {
                  "name": "portfolio_value",
                  "type": "float"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1136
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 190
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy",
        "scipy"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "scipy"
      ]
    },
    "core.__init__": {
      "name": "__init__",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\core\\__init__.py",
      "docstring": "AI Trading Firm - Core Module\n=============================\n\nCore infrastructure components for the multi-agent trading system.\nPer CLAUDE.md: Testable, observable, and auditable.",
      "classes": [],
      "functions": [],
      "constants": [],
      "imports": [
        "core.events",
        "core.event_bus",
        "core.agent_base",
        "core.broker",
        "core.logger",
        "core.monitoring"
      ],
      "dependencies": [
        "core.events",
        "core.event_bus",
        "core.agent_base",
        "core.broker",
        "core.logger",
        "core.monitoring"
      ]
    },
    "strategies.macro_strategy": {
      "name": "macro_strategy",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\strategies\\macro_strategy.py",
      "docstring": "Macro Strategy\n==============\n\nImplements macroeconomic signal generation logic.\n\nMATURITY: ALPHA\n---------------\nStatus: Basic framework - placeholder implementation\n- [x] Regime classification (expansion, slowdown, recession, recovery)\n- [x] Risk allocation by regime\n- [x] Sector rotation signals\n- [x] VIX term structure analysis\n- [ ] Hidden Markov Model for regime detection (TODO)\n- [ ] Leading economic indicators integration (TODO)\n- [ ] Cross-asset correlation analysis (TODO)\n- [ ] Credit cycle indicators (TODO)\n\nProduction Readiness:\n- Unit tests: Minimal\n- Backtesting: Not performed\n- Data sources: Not integrated (needs external macro data)\n\nWARNING: DO NOT USE IN PRODUCTION\n- Regime detection is overly simplified\n- Requires external macro data feeds (not implemented)\n- Sector signals are static, not data-driven\n- Consider this a conceptual framework only",
      "classes": [
        {
          "name": "MacroRegime",
          "module": "macro_strategy",
          "docstring": "Macroeconomic regime classification.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 44
        },
        {
          "name": "MacroIndicators",
          "module": "macro_strategy",
          "docstring": "Container for macro indicators.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "vix",
              "type": "float"
            },
            {
              "name": "yield_2y",
              "type": "float"
            },
            {
              "name": "yield_10y",
              "type": "float"
            },
            {
              "name": "dxy",
              "type": "float"
            },
            {
              "name": "credit_spread",
              "type": "float"
            },
            {
              "name": "pmi",
              "type": "float"
            },
            {
              "name": "unemployment",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 53
        },
        {
          "name": "MacroStrategy",
          "module": "macro_strategy",
          "docstring": "Macro Strategy Implementation.\n\nAnalyzes macroeconomic indicators to determine:\n1. Current economic regime\n2. Risk-on/risk-off positioning\n3. Sector rotation signals\n\nTODO: Implement actual models:\n- Yield curve analysis\n- Credit cycle indicators\n- Leading economic indicators\n- Cross-asset correlations",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "macro_strategy",
              "signature": "def __init__(self, config: dict[str, Any])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 80
            },
            {
              "name": "update_indicator",
              "module": "macro_strategy",
              "signature": "def update_indicator(self, name: str, value: float) -> None",
              "docstring": "Update a macro indicator value.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "name",
                  "type": "str"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 86
            },
            {
              "name": "analyze_regime",
              "module": "macro_strategy",
              "signature": "def analyze_regime(self) -> MacroRegime",
              "docstring": "Analyze current macro regime.\n\nTODO: Implement proper regime detection:\n- Hidden Markov Model\n- Rule-based classification\n- Machine learning classifier",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "MacroRegime",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 91
            },
            {
              "name": "get_risk_allocation",
              "module": "macro_strategy",
              "signature": "def get_risk_allocation(self) -> float",
              "docstring": "Get recommended risk allocation based on regime.\n\nReturns a factor 0.0 to 1.0 for risk scaling.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 124
            },
            {
              "name": "get_sector_signals",
              "module": "macro_strategy",
              "signature": "def get_sector_signals(self) -> dict[str, float]",
              "docstring": "Get sector rotation signals based on regime.\n\nReturns dict of sector -> signal strength (-1 to 1).\n\nTODO: Implement proper sector rotation model.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 138
            },
            {
              "name": "analyze_vix_term_structure",
              "module": "macro_strategy",
              "signature": "def analyze_vix_term_structure(self, vix_spot: float, vix_futures: list[float]) -> dict[str, Any]",
              "docstring": "Analyze VIX term structure for signals.\n\nTODO: Implement VIX term structure analysis:\n- Contango vs backwardation\n- Roll yield estimation\n- Vol regime detection",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "vix_spot",
                  "type": "float"
                },
                {
                  "name": "vix_futures",
                  "type": "list[float]"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 166
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 64
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "numpy"
      ],
      "dependencies": [
        "__future__",
        "numpy"
      ]
    },
    "strategies.market_making_strategy": {
      "name": "market_making_strategy",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\strategies\\market_making_strategy.py",
      "docstring": "Market Making Strategy\n======================\n\nImplements market making logic (IB-compatible latency).\n\nMATURITY: ALPHA\n---------------\nStatus: Basic framework - NOT ready for production\n- [x] Fair value estimation (size-weighted mid)\n- [x] Basic spread calculation (A-S inspired)\n- [x] Inventory management (skew adjustment)\n- [x] Quote generation\n- [ ] Avellaneda-Stoikov full model (TODO)\n- [ ] Order arrival rate estimation (TODO)\n- [ ] Kyle's lambda (adverse selection) (TODO)\n- [ ] VPIN (order flow toxicity) (TODO)\n\nProduction Readiness:\n- Unit tests: Minimal\n- Backtesting: Not performed\n- Live testing: Not performed\n\nWARNING: DO NOT USE IN PRODUCTION\n- This is a simplified placeholder implementation\n- Real market making requires:\n  * Sub-100ms latency (not achievable with IB)\n  * Sophisticated inventory models\n  * Adverse selection detection\n  * Fee structure optimization\n\nNOTE: Not HFT - operates at 100ms+ latencies due to IB constraints.",
      "classes": [
        {
          "name": "Quote",
          "module": "market_making_strategy",
          "docstring": "A bid/ask quote.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "bid_price",
              "type": "float"
            },
            {
              "name": "bid_size",
              "type": "int"
            },
            {
              "name": "ask_price",
              "type": "float"
            },
            {
              "name": "ask_size",
              "type": "int"
            },
            {
              "name": "mid_price",
              "type": "float"
            },
            {
              "name": "spread",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 48
        },
        {
          "name": "MarketMakingSignal",
          "module": "market_making_strategy",
          "docstring": "Market making signal output.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "action",
              "type": "str"
            },
            {
              "name": "quote",
              "type": ""
            },
            {
              "name": "inventory_action",
              "type": ""
            },
            {
              "name": "urgency",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 59
        },
        {
          "name": "MarketMakingStrategy",
          "module": "market_making_strategy",
          "docstring": "Market Making Strategy Implementation.\n\nImplements:\n1. Fair value estimation\n2. Optimal spread calculation\n3. Inventory management\n4. Adverse selection avoidance\n\nNOT HFT - All quotes refreshed at IB-compatible intervals (100ms+).\n\nTODO: Implement proper models:\n- Avellaneda-Stoikov optimal market making\n- Kyle's lambda for adverse selection\n- Order flow toxicity (VPIN)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "market_making_strategy",
              "signature": "def __init__(self, config: dict[str, Any])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 86
            },
            {
              "name": "estimate_fair_value",
              "module": "market_making_strategy",
              "signature": "def estimate_fair_value(self, bid: float, ask: float, bid_size: int, ask_size: int) -> float",
              "docstring": "Estimate fair value from order book.\n\nUses size-weighted mid price.\n\nTODO: Implement more sophisticated fair value:\n- Micro-price\n- Order flow imbalance\n- Volume-weighted price",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bid",
                  "type": "float"
                },
                {
                  "name": "ask",
                  "type": "float"
                },
                {
                  "name": "bid_size",
                  "type": "int"
                },
                {
                  "name": "ask_size",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 97
            },
            {
              "name": "calculate_optimal_spread",
              "module": "market_making_strategy",
              "signature": "def calculate_optimal_spread(self, volatility: float, inventory: int, time_horizon: float) -> float",
              "docstring": "Calculate optimal spread using Avellaneda-Stoikov framework.\n\ns* = gamma * sigma^2 * T + (2/gamma) * ln(1 + gamma/k)\n\nSimplified version - full implementation would need order arrival rate.\n\nTODO: Implement full A-S model with:\n- Order arrival rate estimation\n- Inventory penalty\n- Terminal inventory constraint",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "inventory",
                  "type": "int"
                },
                {
                  "name": "time_horizon",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 122
            },
            {
              "name": "calculate_quote_skew",
              "module": "market_making_strategy",
              "signature": "def calculate_quote_skew(self, inventory: int) -> float",
              "docstring": "Calculate quote skew based on inventory.\n\nPositive skew = higher ask (want to sell)\nNegative skew = lower bid (want to buy)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "inventory",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 158
            },
            {
              "name": "generate_quotes",
              "module": "market_making_strategy",
              "signature": "def generate_quotes(self, symbol: str, fair_value: float, volatility: float, inventory: int, bid_size: int, ask_size: int) -> MarketMakingSignal",
              "docstring": "Generate bid/ask quotes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "fair_value",
                  "type": "float"
                },
                {
                  "name": "volatility",
                  "type": "float"
                },
                {
                  "name": "inventory",
                  "type": "int"
                },
                {
                  "name": "bid_size",
                  "type": "int"
                },
                {
                  "name": "ask_size",
                  "type": "int"
                }
              ],
              "return_type": "MarketMakingSignal",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 172
            },
            {
              "name": "should_quote",
              "module": "market_making_strategy",
              "signature": "def should_quote(self, current_spread: float, our_spread: float, inventory: int) -> bool",
              "docstring": "Determine if we should be quoting.\n\nDon't quote if:\n- Spread is too tight (can't make money)\n- Inventory is at limit\n- Market is too fast (adverse selection)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_spread",
                  "type": "float"
                },
                {
                  "name": "our_spread",
                  "type": "float"
                },
                {
                  "name": "inventory",
                  "type": "int"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 231
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 68
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "numpy"
      ],
      "dependencies": [
        "__future__",
        "numpy"
      ]
    },
    "strategies.momentum_strategy": {
      "name": "momentum_strategy",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\strategies\\momentum_strategy.py",
      "docstring": "Momentum Strategy\n=================\n\nImplements momentum and trend-following logic.\n\nMATURITY: BETA\n--------------\nStatus: Core functionality implemented and tested\n- [x] MA crossovers implemented\n- [x] RSI calculation (Wilder's smoothing)\n- [x] MACD with proper signal line\n- [x] Stop-loss calculation (ATR-based)\n- [ ] ADX trend strength (TODO)\n- [ ] Volume-weighted indicators (TODO)\n- [ ] Ichimoku Cloud (TODO)\n\nProduction Readiness:\n- Unit tests: Partial coverage\n- Backtesting: Not yet performed\n- Live testing: Not yet performed\n\nUse in production: WITH CAUTION - verify signals manually before trading",
      "classes": [
        {
          "name": "MomentumSignal",
          "module": "momentum_strategy",
          "docstring": "Momentum signal output.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "direction",
              "type": "str"
            },
            {
              "name": "strength",
              "type": "float"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "indicators",
              "type": "dict[str, float]"
            },
            {
              "name": "stop_loss_price",
              "type": ""
            },
            {
              "name": "stop_loss_pct",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 39
        },
        {
          "name": "MomentumStrategy",
          "module": "momentum_strategy",
          "docstring": "Momentum Strategy Implementation.\n\nImplements:\n1. Moving average crossovers\n2. RSI (Relative Strength Index)\n3. MACD (Moving Average Convergence Divergence)\n4. Rate of Change (ROC)\n\nTODO: Implement more sophisticated models:\n- ADX for trend strength\n- Ichimoku Cloud\n- Bollinger Bands\n- Volume-weighted indicators",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "momentum_strategy",
              "signature": "def __init__(self, config: dict[str, Any])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 68
            },
            {
              "name": "calculate_sma",
              "module": "momentum_strategy",
              "signature": "def calculate_sma(self, prices: np.ndarray, period: int) -> float",
              "docstring": "Calculate Simple Moving Average.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "np.ndarray"
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "calculate_ema",
              "module": "momentum_strategy",
              "signature": "def calculate_ema(self, prices: np.ndarray, period: int) -> float",
              "docstring": "Calculate Exponential Moving Average (returns single value).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "np.ndarray"
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 93
            },
            {
              "name": "calculate_ema_series",
              "module": "momentum_strategy",
              "signature": "def calculate_ema_series(self, prices: np.ndarray, period: int) -> np.ndarray",
              "docstring": "Calculate full EMA series for MACD signal line calculation.\n\nReturns array of EMA values, same length as input prices.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "np.ndarray"
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "np.ndarray",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 108
            },
            {
              "name": "calculate_rsi",
              "module": "momentum_strategy",
              "signature": "def calculate_rsi(self, prices: np.ndarray, period: int) -> float",
              "docstring": "Calculate Relative Strength Index using Wilder's smoothing method.\n\nWilder's smoothing is an exponential moving average with\nsmoothing factor = 1/period (as opposed to 2/(period+1) for standard EMA).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "np.ndarray"
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 130
            },
            {
              "name": "calculate_macd",
              "module": "momentum_strategy",
              "signature": "def calculate_macd(self, prices: np.ndarray) -> tuple[float, float, float]",
              "docstring": "Calculate MACD, Signal line, and Histogram.\n\nMACD Line = Fast EMA (12) - Slow EMA (26)\nSignal Line = 9-period EMA of MACD Line\nHistogram = MACD Line - Signal Line\n\nReturns (macd, signal, histogram).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "tuple[float, float, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 169
            },
            {
              "name": "calculate_roc",
              "module": "momentum_strategy",
              "signature": "def calculate_roc(self, prices: np.ndarray, period: int) -> float",
              "docstring": "Calculate Rate of Change.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "np.ndarray"
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 213
            },
            {
              "name": "calculate_atr",
              "module": "momentum_strategy",
              "signature": "def calculate_atr(self, prices: np.ndarray, highs: , lows: , period: int) -> float",
              "docstring": "P1-13: Calculate Average True Range for stop-loss placement.\n\nIf highs/lows not provided, estimates from price changes.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "np.ndarray"
                },
                {
                  "name": "highs",
                  "type": ""
                },
                {
                  "name": "lows",
                  "type": ""
                },
                {
                  "name": "period",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 222
            },
            {
              "name": "calculate_stop_loss",
              "module": "momentum_strategy",
              "signature": "def calculate_stop_loss(self, current_price: float, direction: str, atr: float) -> tuple[float, float]",
              "docstring": "P1-13: Calculate stop-loss price and percentage.\n\nArgs:\n    current_price: Entry price\n    direction: \"long\" or \"short\"\n    atr: Average True Range\n\nReturns:\n    (stop_price, stop_pct)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_price",
                  "type": "float"
                },
                {
                  "name": "direction",
                  "type": "str"
                },
                {
                  "name": "atr",
                  "type": "float"
                }
              ],
              "return_type": "tuple[float, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 256
            },
            {
              "name": "analyze",
              "module": "momentum_strategy",
              "signature": "def analyze(self, symbol: str, prices: np.ndarray) -> MomentumSignal",
              "docstring": "Analyze price series and generate momentum signal.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "prices",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "MomentumSignal",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 288
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 51
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "numpy"
      ],
      "dependencies": [
        "__future__",
        "numpy"
      ]
    },
    "strategies.options_vol_strategy": {
      "name": "options_vol_strategy",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\strategies\\options_vol_strategy.py",
      "docstring": "Options Volatility Strategy\n===========================\n\nImplements options and volatility-based trading logic.\n\nMATURITY: BETA\n--------------\nStatus: Comprehensive Greeks and volatility surface implementation\n- [x] Black-Scholes pricing with dividends\n- [x] Full Greeks calculation (delta, gamma, theta, vega, rho)\n- [x] Implied volatility (Newton-Raphson)\n- [x] IV percentile ranking\n- [x] Vol surface construction (#O4)\n- [x] Skew analysis (risk reversal, butterfly) (#O5)\n- [x] Early exercise boundary (binomial) (#O3)\n- [x] Vanna/Volga adjustments (#O11)\n- [x] Option validation (#O2)\n- [x] Spread strategies (verticals, iron condors) (#O7)\n- [x] Pin risk detection (#O8)\n- [x] Assignment risk calculation (#O9)\n- [x] Gamma scalping support (#O10)\n- [ ] SABR model (TODO)\n- [ ] Local volatility surface (TODO)\n- [ ] Variance swap replication (TODO)\n\nProduction Readiness:\n- Unit tests: Good coverage for Greeks\n- Validation: Option contract validation implemented\n- Greeks bounds checking: Implemented\n\nUse in production: WITH CAUTION\n- IV solver may not converge for extreme values\n- Early exercise uses binomial tree approximation\n- Verify Greeks against broker values before trading",
      "classes": [
        {
          "name": "OptionValidationError",
          "module": "options_vol_strategy",
          "docstring": "Raised when option contract validation fails.",
          "bases": [
            "Exception"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 52
        },
        {
          "name": "OptionData",
          "module": "options_vol_strategy",
          "docstring": "Option contract data with validation (#O2).\n\nValidates strike prices and expiration dates to ensure contract integrity.",
          "bases": [],
          "methods": [
            {
              "name": "__post_init__",
              "module": "options_vol_strategy",
              "signature": "def __post_init__(self)",
              "docstring": "Validate option contract data (#O2).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 84
            },
            {
              "name": "validate",
              "module": "options_vol_strategy",
              "signature": "def validate(self) -> None",
              "docstring": "Validate option contract parameters (#O2).\n\nRaises:\n    OptionValidationError: If validation fails",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 88
            },
            {
              "name": "is_expired",
              "module": "options_vol_strategy",
              "signature": "def is_expired(self) -> bool",
              "docstring": "Check if option is expired.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 146
            },
            {
              "name": "is_atm",
              "module": "options_vol_strategy",
              "signature": "def is_atm(self) -> bool",
              "docstring": "Check if option is approximately at-the-money (within 2% of strike).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 151
            },
            {
              "name": "mid_price",
              "module": "options_vol_strategy",
              "signature": "def mid_price(self) -> float",
              "docstring": "Get mid-market price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 158
            },
            {
              "name": "spread_pct",
              "module": "options_vol_strategy",
              "signature": "def spread_pct(self) -> float",
              "docstring": "Get bid-ask spread as percentage of mid price.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 163
            },
            {
              "name": "create_validated",
              "module": "options_vol_strategy",
              "signature": "def create_validated(cls, symbol: str, underlying: str, strike: float, expiry_days: int, is_call: bool, bid: float, ask: float, implied_vol: float, delta: float, gamma: float, theta: float, vega: float) -> OptionData",
              "docstring": "Factory method to create validated option data.\n\nReturns:\n    Validated OptionData instance\n\nRaises:\n    OptionValidationError: If validation fails",
              "parameters": [
                {
                  "name": "cls"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "underlying",
                  "type": "str"
                },
                {
                  "name": "strike",
                  "type": "float"
                },
                {
                  "name": "expiry_days",
                  "type": "int"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "bid",
                  "type": "float"
                },
                {
                  "name": "ask",
                  "type": "float"
                },
                {
                  "name": "implied_vol",
                  "type": "float"
                },
                {
                  "name": "delta",
                  "type": "float"
                },
                {
                  "name": "gamma",
                  "type": "float"
                },
                {
                  "name": "theta",
                  "type": "float"
                },
                {
                  "name": "vega",
                  "type": "float"
                }
              ],
              "return_type": "OptionData",
              "raises": [],
              "examples": [],
              "decorators": [
                "classmethod"
              ],
              "is_async": false,
              "line_number": 171
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "underlying",
              "type": "str"
            },
            {
              "name": "strike",
              "type": "float"
            },
            {
              "name": "expiry_days",
              "type": "int"
            },
            {
              "name": "is_call",
              "type": "bool"
            },
            {
              "name": "bid",
              "type": "float"
            },
            {
              "name": "ask",
              "type": "float"
            },
            {
              "name": "implied_vol",
              "type": "float"
            },
            {
              "name": "delta",
              "type": "float"
            },
            {
              "name": "gamma",
              "type": "float"
            },
            {
              "name": "theta",
              "type": "float"
            },
            {
              "name": "vega",
              "type": "float"
            },
            {
              "name": "MIN_STRIKE",
              "type": "float"
            },
            {
              "name": "MAX_STRIKE",
              "type": "float"
            },
            {
              "name": "MIN_EXPIRY_DAYS",
              "type": "int"
            },
            {
              "name": "MAX_EXPIRY_DAYS",
              "type": "int"
            },
            {
              "name": "MAX_IMPLIED_VOL",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 58
        },
        {
          "name": "VolSignal",
          "module": "options_vol_strategy",
          "docstring": "Volatility strategy signal.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "underlying",
              "type": "str"
            },
            {
              "name": "strategy",
              "type": "str"
            },
            {
              "name": "direction",
              "type": "str"
            },
            {
              "name": "strength",
              "type": "float"
            },
            {
              "name": "iv_percentile",
              "type": "float"
            },
            {
              "name": "vol_premium",
              "type": "float"
            },
            {
              "name": "legs",
              "type": "list[dict]"
            },
            {
              "name": "max_loss_pct",
              "type": ""
            },
            {
              "name": "stop_loss_underlying_move",
              "type": ""
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 212
        },
        {
          "name": "OptionsVolStrategy",
          "module": "options_vol_strategy",
          "docstring": "Options Volatility Strategy Implementation.\n\nImplements:\n1. IV percentile ranking\n2. Volatility risk premium analysis\n3. Skew trading\n4. Term structure analysis\n\nTODO: Implement proper models:\n- SABR for smile dynamics\n- Local volatility surface\n- Variance swap replication\n- Dispersion trading",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "options_vol_strategy",
              "signature": "def __init__(self, config: dict[str, Any])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 243
            },
            {
              "name": "black_scholes_price",
              "module": "options_vol_strategy",
              "signature": "def black_scholes_price(self, S: float, K: float, T: float, r: float, sigma: float, is_call: bool, q: float) -> float",
              "docstring": "Calculate Black-Scholes option price with dividend yield.\n\nArgs:\n    S: Spot price\n    K: Strike price\n    T: Time to expiry in years\n    r: Risk-free interest rate (annualized)\n    sigma: Volatility (annualized)\n    is_call: True for call, False for put\n    q: Continuous dividend yield (annualized, e.g., 0.02 for 2%)\n\nReturns:\n    Option price\n\nNote: For stocks with discrete dividends, convert to continuous yield:\n    q = -ln(1 - PV(dividends)/S) / T",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "sigma",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "q",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 250
            },
            {
              "name": "calculate_greeks",
              "module": "options_vol_strategy",
              "signature": "def calculate_greeks(self, S: float, K: float, T: float, r: float, sigma: float, is_call: bool, q: float) -> dict[str, float]",
              "docstring": "Calculate option Greeks with dividend yield.\n\nArgs:\n    S: Spot price\n    K: Strike price\n    T: Time to expiry in years\n    r: Risk-free rate\n    sigma: Volatility\n    is_call: True for call, False for put\n    q: Continuous dividend yield\n\nReturns:\n    Dictionary with delta, gamma, theta, vega, rho",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "sigma",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "q",
                  "type": "float"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 299
            },
            {
              "name": "implied_volatility",
              "module": "options_vol_strategy",
              "signature": "def implied_volatility(self, price: float, S: float, K: float, T: float, r: float, is_call: bool, q: float, precision: float, max_iterations: int) -> float",
              "docstring": "Calculate implied volatility using Newton-Raphson.\n\nArgs:\n    price: Market price of the option\n    S: Spot price\n    K: Strike price\n    T: Time to expiry in years\n    r: Risk-free rate\n    is_call: True for call, False for put\n    q: Continuous dividend yield\n    precision: Price precision for convergence\n    max_iterations: Maximum iterations\n\nReturns:\n    Implied volatility\n\nTODO: Use more robust method (Brent's, bisection with bounds).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "price",
                  "type": "float"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "q",
                  "type": "float"
                },
                {
                  "name": "precision",
                  "type": "float"
                },
                {
                  "name": "max_iterations",
                  "type": "int"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 371
            },
            {
              "name": "calculate_iv_percentile",
              "module": "options_vol_strategy",
              "signature": "def calculate_iv_percentile(self, current_iv: float, iv_history: list[float]) -> float",
              "docstring": "Calculate IV percentile rank.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_iv",
                  "type": "float"
                },
                {
                  "name": "iv_history",
                  "type": "list[float]"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 421
            },
            {
              "name": "analyze_vol_surface",
              "module": "options_vol_strategy",
              "signature": "def analyze_vol_surface(self, options: list[OptionData], spot_price: float) -> dict[str, Any]",
              "docstring": "Analyze volatility surface characteristics.\n\nReturns analysis of:\n- ATM IV\n- Skew (25 delta put - 25 delta call IV)\n- Term structure",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 435
            },
            {
              "name": "generate_signal",
              "module": "options_vol_strategy",
              "signature": "def generate_signal(self, underlying: str, current_iv: float, iv_history: list[float], realized_vol: float, options: )",
              "docstring": "Generate volatility trading signal.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "underlying",
                  "type": "str"
                },
                {
                  "name": "current_iv",
                  "type": "float"
                },
                {
                  "name": "iv_history",
                  "type": "list[float]"
                },
                {
                  "name": "realized_vol",
                  "type": "float"
                },
                {
                  "name": "options",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 484
            },
            {
              "name": "calculate_early_exercise_boundary",
              "module": "options_vol_strategy",
              "signature": "def calculate_early_exercise_boundary(self, S: float, K: float, T: float, r: float, sigma: float, is_call: bool, q: float, n_steps: int) -> dict",
              "docstring": "Calculate early exercise boundary for American options (#O3).\n\nUses binomial tree approximation for early exercise premium.\n\nArgs:\n    S: Spot price\n    K: Strike price\n    T: Time to expiry (years)\n    r: Risk-free rate\n    sigma: Volatility\n    is_call: True for call, False for put\n    q: Dividend yield\n    n_steps: Number of time steps in binomial tree\n\nReturns:\n    Early exercise analysis including boundary and premium",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "sigma",
                  "type": "float"
                },
                {
                  "name": "is_call",
                  "type": "bool"
                },
                {
                  "name": "q",
                  "type": "float"
                },
                {
                  "name": "n_steps",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 535
            },
            {
              "name": "should_exercise_early",
              "module": "options_vol_strategy",
              "signature": "def should_exercise_early(self, option: OptionData, underlying_price: float, risk_free_rate: float, dividend_yield: float, days_to_ex_div: , expected_dividend: ) -> dict",
              "docstring": "Determine if early exercise is optimal (#O3).\n\nFor calls: Exercise before ex-dividend if dividend > time value\nFor puts: Exercise if time value < interest earned on proceeds\n\nArgs:\n    option: Option contract data\n    underlying_price: Current underlying price\n    risk_free_rate: Risk-free rate\n    dividend_yield: Continuous dividend yield\n    days_to_ex_div: Days until ex-dividend date\n    expected_dividend: Expected dividend amount\n\nReturns:\n    Early exercise recommendation",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "option",
                  "type": "OptionData"
                },
                {
                  "name": "underlying_price",
                  "type": "float"
                },
                {
                  "name": "risk_free_rate",
                  "type": "float"
                },
                {
                  "name": "dividend_yield",
                  "type": "float"
                },
                {
                  "name": "days_to_ex_div",
                  "type": ""
                },
                {
                  "name": "expected_dividend",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 655
            },
            {
              "name": "build_vol_surface",
              "module": "options_vol_strategy",
              "signature": "def build_vol_surface(self, options: list[OptionData], spot_price: float, risk_free_rate: float) -> dict",
              "docstring": "Build implied volatility surface (#O4).\n\nCreates a grid of IV by strike (moneyness) and expiry.\n\nArgs:\n    options: List of option data\n    spot_price: Current underlying price\n    risk_free_rate: Risk-free rate\n\nReturns:\n    Volatility surface data structure",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "risk_free_rate",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 734
            },
            {
              "name": "interpolate_vol",
              "module": "options_vol_strategy",
              "signature": "def interpolate_vol(self, surface: dict, target_expiry: int, target_moneyness: float)",
              "docstring": "Interpolate volatility from surface (#O4).\n\nUses bilinear interpolation for intermediate points.\n\nArgs:\n    surface: Vol surface from build_vol_surface\n    target_expiry: Target expiry in days\n    target_moneyness: Target log-moneyness\n\nReturns:\n    Interpolated implied volatility",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "surface",
                  "type": "dict"
                },
                {
                  "name": "target_expiry",
                  "type": "int"
                },
                {
                  "name": "target_moneyness",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 801
            },
            {
              "name": "analyze_skew",
              "module": "options_vol_strategy",
              "signature": "def analyze_skew(self, options: list[OptionData], spot_price: float, expiry_days: ) -> dict",
              "docstring": "Analyze volatility skew at given expiry (#O5).\n\nCalculates:\n- 25-delta risk reversal (put IV - call IV)\n- Butterfly (wing average - ATM)\n- Skew slope\n\nArgs:\n    options: List of option data\n    spot_price: Current underlying price\n    expiry_days: Specific expiry or None for all\n\nReturns:\n    Skew analysis metrics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "expiry_days",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 870
            },
            {
              "name": "detect_skew_anomaly",
              "module": "options_vol_strategy",
              "signature": "def detect_skew_anomaly(self, current_skew: dict, historical_skew: list[dict], z_threshold: float) -> dict",
              "docstring": "Detect anomalies in current skew vs history (#O5).\n\nArgs:\n    current_skew: Current skew analysis\n    historical_skew: List of historical skew analyses\n    z_threshold: Z-score threshold for anomaly\n\nReturns:\n    Anomaly detection results",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "current_skew",
                  "type": "dict"
                },
                {
                  "name": "historical_skew",
                  "type": "list[dict]"
                },
                {
                  "name": "z_threshold",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 951
            },
            {
              "name": "calculate_greeks_term_structure",
              "module": "options_vol_strategy",
              "signature": "def calculate_greeks_term_structure(self, options: list[OptionData], spot_price: float) -> dict",
              "docstring": "Calculate Greeks term structure across expiries (#O6).\n\nShows how Greeks evolve with time to expiration.\n\nArgs:\n    options: List of option data\n    spot_price: Current underlying price\n\nReturns:\n    Greeks term structure by expiry",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1008
            },
            {
              "name": "create_vertical_spread",
              "module": "options_vol_strategy",
              "signature": "def create_vertical_spread(self, options: list[OptionData], spread_type: str, target_delta: float, width_pct: float)",
              "docstring": "Create vertical spread strategy (#O7).\n\nArgs:\n    options: Available options\n    spread_type: Type of spread\n    target_delta: Delta for short leg\n    width_pct: Spread width as % of underlying\n\nReturns:\n    Spread definition or None if not possible",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "spread_type",
                  "type": "str"
                },
                {
                  "name": "target_delta",
                  "type": "float"
                },
                {
                  "name": "width_pct",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1076
            },
            {
              "name": "create_iron_condor",
              "module": "options_vol_strategy",
              "signature": "def create_iron_condor(self, options: list[OptionData], put_delta: float, call_delta: float, wing_width_pct: float)",
              "docstring": "Create iron condor strategy (#O7).\n\nSells put spread below market, sells call spread above market.\n\nArgs:\n    options: Available options\n    put_delta: Delta for short put\n    call_delta: Delta for short call\n    wing_width_pct: Wing width as % of strike\n\nReturns:\n    Iron condor definition",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "put_delta",
                  "type": "float"
                },
                {
                  "name": "call_delta",
                  "type": "float"
                },
                {
                  "name": "wing_width_pct",
                  "type": "float"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1162
            },
            {
              "name": "detect_pin_risk",
              "module": "options_vol_strategy",
              "signature": "def detect_pin_risk(self, options: list[OptionData], spot_price: float, position_size: int, pin_threshold_pct: float) -> dict",
              "docstring": "Detect pin risk near expiration (#O8).\n\nPin risk occurs when underlying settles near a strike at expiration,\nmaking assignment uncertain.\n\nArgs:\n    options: Option positions\n    spot_price: Current underlying price\n    position_size: Number of contracts (negative = short)\n    pin_threshold_pct: % from strike to flag as at-risk\n\nReturns:\n    Pin risk analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "position_size",
                  "type": "int"
                },
                {
                  "name": "pin_threshold_pct",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1233
            },
            {
              "name": "calculate_assignment_risk",
              "module": "options_vol_strategy",
              "signature": "def calculate_assignment_risk(self, option: OptionData, spot_price: float, position_size: int, days_to_ex_div: , dividend_amount: ) -> dict",
              "docstring": "Calculate assignment risk for short options (#O9).\n\nAssignment is most likely for:\n- Deep ITM options (high intrinsic value)\n- Near expiration\n- Before ex-dividend for calls\n\nArgs:\n    option: Option contract\n    spot_price: Current underlying price\n    position_size: Number of contracts (negative = short)\n    days_to_ex_div: Days to ex-dividend\n    dividend_amount: Expected dividend\n\nReturns:\n    Assignment risk analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "option",
                  "type": "OptionData"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "position_size",
                  "type": "int"
                },
                {
                  "name": "days_to_ex_div",
                  "type": ""
                },
                {
                  "name": "dividend_amount",
                  "type": ""
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1296
            },
            {
              "name": "calculate_gamma_scalp_parameters",
              "module": "options_vol_strategy",
              "signature": "def calculate_gamma_scalp_parameters(self, option: OptionData, position_size: int, spot_price: float, realized_vol: float, hedge_interval_seconds: int) -> dict",
              "docstring": "Calculate parameters for gamma scalping strategy (#O10).\n\nGamma scalping profits from realized volatility exceeding implied\nby delta-hedging an options position.\n\nArgs:\n    option: Option contract\n    position_size: Number of contracts (positive = long gamma)\n    spot_price: Current underlying price\n    realized_vol: Current realized volatility\n    hedge_interval_seconds: Seconds between hedges\n\nReturns:\n    Gamma scalping parameters",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "option",
                  "type": "OptionData"
                },
                {
                  "name": "position_size",
                  "type": "int"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "realized_vol",
                  "type": "float"
                },
                {
                  "name": "hedge_interval_seconds",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1391
            },
            {
              "name": "calculate_delta_hedge",
              "module": "options_vol_strategy",
              "signature": "def calculate_delta_hedge(self, options: list[tuple[OptionData, int]], spot_price: float, current_hedge_shares: int) -> dict",
              "docstring": "Calculate required delta hedge (#O10).\n\nArgs:\n    options: List of (option, position) tuples\n    spot_price: Current underlying price\n    current_hedge_shares: Current hedge position\n\nReturns:\n    Hedge adjustment needed",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "options",
                  "type": "list[tuple[OptionData, int]]"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "current_hedge_shares",
                  "type": "int"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1468
            },
            {
              "name": "calculate_vanna",
              "module": "options_vol_strategy",
              "signature": "def calculate_vanna(self, S: float, K: float, T: float, r: float, sigma: float, q: float) -> float",
              "docstring": "Calculate Vanna (dDelta/dVol or dVega/dSpot) (#O11).\n\nVanna measures sensitivity of delta to volatility changes.\n\nArgs:\n    S: Spot price\n    K: Strike\n    T: Time to expiry (years)\n    r: Risk-free rate\n    sigma: Volatility\n    q: Dividend yield\n\nReturns:\n    Vanna value",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "sigma",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1510
            },
            {
              "name": "calculate_volga",
              "module": "options_vol_strategy",
              "signature": "def calculate_volga(self, S: float, K: float, T: float, r: float, sigma: float, q: float) -> float",
              "docstring": "Calculate Volga (dVega/dVol, also called Vomma) (#O11).\n\nVolga measures convexity of vega with respect to volatility.\n\nArgs:\n    S: Spot price\n    K: Strike\n    T: Time to expiry (years)\n    r: Risk-free rate\n    sigma: Volatility\n    q: Dividend yield\n\nReturns:\n    Volga value",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "sigma",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1546
            },
            {
              "name": "apply_vanna_volga_adjustment",
              "module": "options_vol_strategy",
              "signature": "def apply_vanna_volga_adjustment(self, bs_price: float, S: float, K: float, T: float, r: float, atm_vol: float, put_25d_vol: float, call_25d_vol: float, q: float) -> dict",
              "docstring": "Apply Vanna-Volga adjustment to Black-Scholes price (#O11).\n\nAdjusts BS price to account for smile dynamics using\nmarket-implied risk reversals and butterflies.\n\nArgs:\n    bs_price: Black-Scholes price\n    S: Spot price\n    K: Strike\n    T: Time to expiry\n    r: Risk-free rate\n    atm_vol: ATM implied volatility\n    put_25d_vol: 25-delta put IV\n    call_25d_vol: 25-delta call IV\n    q: Dividend yield\n\nReturns:\n    Adjusted price and components",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "bs_price",
                  "type": "float"
                },
                {
                  "name": "S",
                  "type": "float"
                },
                {
                  "name": "K",
                  "type": "float"
                },
                {
                  "name": "T",
                  "type": "float"
                },
                {
                  "name": "r",
                  "type": "float"
                },
                {
                  "name": "atm_vol",
                  "type": "float"
                },
                {
                  "name": "put_25d_vol",
                  "type": "float"
                },
                {
                  "name": "call_25d_vol",
                  "type": "float"
                },
                {
                  "name": "q",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1585
            },
            {
              "name": "suggest_portfolio_hedges",
              "module": "options_vol_strategy",
              "signature": "def suggest_portfolio_hedges(self, portfolio_greeks: dict, available_options: list[OptionData], spot_price: float, hedge_targets: ) -> list[dict]",
              "docstring": "Suggest hedging trades for portfolio Greeks (#O12).\n\nArgs:\n    portfolio_greeks: Current portfolio Greeks {delta, gamma, theta, vega}\n    available_options: Options available for hedging\n    spot_price: Current underlying price\n    hedge_targets: Target Greeks (default: neutralize all)\n\nReturns:\n    List of suggested hedge trades",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "portfolio_greeks",
                  "type": "dict"
                },
                {
                  "name": "available_options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                },
                {
                  "name": "hedge_targets",
                  "type": ""
                }
              ],
              "return_type": "list[dict]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1650
            },
            {
              "name": "calculate_hedge_cost",
              "module": "options_vol_strategy",
              "signature": "def calculate_hedge_cost(self, hedge_suggestions: list[dict], options: list[OptionData], spot_price: float) -> dict",
              "docstring": "Calculate cost of implementing hedge suggestions (#O12).\n\nArgs:\n    hedge_suggestions: List of suggested hedges\n    options: Option universe\n    spot_price: Current underlying price\n\nReturns:\n    Cost breakdown",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "hedge_suggestions",
                  "type": "list[dict]"
                },
                {
                  "name": "options",
                  "type": "list[OptionData]"
                },
                {
                  "name": "spot_price",
                  "type": "float"
                }
              ],
              "return_type": "dict",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1734
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 226
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "typing",
        "numpy",
        "scipy.stats"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "scipy.stats"
      ]
    },
    "strategies.seasonality": {
      "name": "seasonality",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\strategies\\seasonality.py",
      "docstring": "Seasonality Strategy\n====================\n\nImplements seasonal patterns for commodity and equity trading.\nBased on historical calendar effects and production/consumption cycles.\n\nMATURITY: PRODUCTION-READY\n--------------------------\nStatus: Complete implementation with historical validation\n- [x] Comprehensive seasonal patterns database\n- [x] Active pattern detection\n- [x] Signal generation with confidence scoring\n- [x] Pattern confluence analysis\n- [x] Historical pattern validation\n- [x] Monthly bias calculation\n- [x] Upcoming patterns scanning\n- [x] Custom pattern support\n\nProduction Readiness:\n- Unit tests: Good coverage\n- Historical data: Patterns based on 10+ years of data\n- Win rates: Based on documented historical performance\n\nAPPROVED FOR PRODUCTION USE\n- Patterns are well-researched (driving season, planting, harvest, etc.)\n- Win rates are conservative estimates\n- Always combine with other signals for confirmation\n- Monitor actual vs expected performance\n\nCovered Markets:\n- Energy: Natural Gas (NG), Crude Oil (CL), Gasoline (RB)\n- Agriculture: Corn (ZC), Wheat (ZW), Soybeans (ZS)\n- Metals: Gold (GC)\n- Equities: ES/SPY (Santa Rally, Sell in May)",
      "classes": [
        {
          "name": "SeasonalPattern",
          "module": "seasonality",
          "docstring": "Types of seasonal patterns.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 52
        },
        {
          "name": "SeasonalStrength",
          "module": "seasonality",
          "docstring": "Strength of seasonal signal.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 60
        },
        {
          "name": "SeasonalWindow",
          "module": "seasonality",
          "docstring": "Defines a seasonal trading window.",
          "bases": [],
          "methods": [
            {
              "name": "strength",
              "module": "seasonality",
              "signature": "def strength(self) -> SeasonalStrength",
              "docstring": "Determine signal strength from win rate.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "SeasonalStrength",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 85
            },
            {
              "name": "is_active",
              "module": "seasonality",
              "signature": "def is_active(self, check_date: date) -> bool",
              "docstring": "Check if this seasonal window is active on given date.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "check_date",
                  "type": "date"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 96
            },
            {
              "name": "to_dict",
              "module": "seasonality",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 123
            }
          ],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "pattern_type",
              "type": "SeasonalPattern"
            },
            {
              "name": "start_month",
              "type": "int"
            },
            {
              "name": "start_day",
              "type": "int"
            },
            {
              "name": "end_month",
              "type": "int"
            },
            {
              "name": "end_day",
              "type": "int"
            },
            {
              "name": "direction",
              "type": "str"
            },
            {
              "name": "historical_win_rate",
              "type": "float"
            },
            {
              "name": "avg_return",
              "type": "float"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "tags",
              "type": "list[str]"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 69
        },
        {
          "name": "SeasonalSignal",
          "module": "seasonality",
          "docstring": "Signal generated from seasonal analysis.",
          "bases": [],
          "methods": [
            {
              "name": "to_dict",
              "module": "seasonality",
              "signature": "def to_dict(self) -> dict[str, Any]",
              "docstring": "Convert to dictionary.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 486
            }
          ],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "timestamp",
              "type": "datetime"
            },
            {
              "name": "direction",
              "type": "str"
            },
            {
              "name": "strength",
              "type": "SeasonalStrength"
            },
            {
              "name": "confidence",
              "type": "float"
            },
            {
              "name": "active_patterns",
              "type": "list[SeasonalWindow]"
            },
            {
              "name": "combined_win_rate",
              "type": "float"
            },
            {
              "name": "rationale",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 475
        },
        {
          "name": "SeasonalityStrategy",
          "module": "seasonality",
          "docstring": "Seasonality-based trading strategy.\n\nGenerates signals based on historical seasonal patterns\nin commodities and equity markets.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "seasonality",
              "signature": "def __init__(self, config: )",
              "docstring": "Initialize seasonality strategy.\n\nArgs:\n    config: Configuration with:\n        - min_win_rate: Minimum win rate to generate signal (default: 0.55)\n        - enabled_symbols: List of symbols to analyze (default: all)\n        - min_patterns: Minimum confirming patterns (default: 1)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 508
            },
            {
              "name": "_dict_to_window",
              "module": "seasonality",
              "signature": "def _dict_to_window(self, d: dict[str, Any]) -> SeasonalWindow",
              "docstring": "Convert dictionary to SeasonalWindow.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "d",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "SeasonalWindow",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 540
            },
            {
              "name": "get_active_patterns",
              "module": "seasonality",
              "signature": "def get_active_patterns(self, symbol: str, check_date: ) -> list[SeasonalWindow]",
              "docstring": "Get active seasonal patterns for a symbol.\n\nArgs:\n    symbol: Instrument symbol\n    check_date: Date to check (default: today)\n\nReturns:\n    List of active SeasonalWindows",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "check_date",
                  "type": ""
                }
              ],
              "return_type": "list[SeasonalWindow]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 557
            },
            {
              "name": "generate_signal",
              "module": "seasonality",
              "signature": "def generate_signal(self, symbol: str, check_date: )",
              "docstring": "Generate seasonal signal for a symbol.\n\nArgs:\n    symbol: Instrument symbol\n    check_date: Date to check\n\nReturns:\n    SeasonalSignal if patterns are active, None otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "check_date",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 586
            },
            {
              "name": "scan_all_symbols",
              "module": "seasonality",
              "signature": "def scan_all_symbols(self, check_date: ) -> list[SeasonalSignal]",
              "docstring": "Scan all symbols for active seasonal signals.\n\nArgs:\n    check_date: Date to check\n\nReturns:\n    List of SeasonalSignals",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "check_date",
                  "type": ""
                }
              ],
              "return_type": "list[SeasonalSignal]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 660
            },
            {
              "name": "get_upcoming_patterns",
              "module": "seasonality",
              "signature": "def get_upcoming_patterns(self, days_ahead: int) -> list[tuple[date, SeasonalWindow]]",
              "docstring": "Get patterns starting within the next N days.\n\nArgs:\n    days_ahead: Days to look ahead\n\nReturns:\n    List of (start_date, pattern) tuples",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "days_ahead",
                  "type": "int"
                }
              ],
              "return_type": "list[tuple[date, SeasonalWindow]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 685
            },
            {
              "name": "add_pattern",
              "module": "seasonality",
              "signature": "def add_pattern(self, window: SeasonalWindow) -> None",
              "docstring": "Add a custom seasonal pattern.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "window",
                  "type": "SeasonalWindow"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 724
            },
            {
              "name": "get_all_patterns",
              "module": "seasonality",
              "signature": "def get_all_patterns(self, symbol: ) -> list[SeasonalWindow]",
              "docstring": "Get all patterns, optionally filtered by symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": ""
                }
              ],
              "return_type": "list[SeasonalWindow]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 730
            },
            {
              "name": "get_status",
              "module": "seasonality",
              "signature": "def get_status(self) -> dict[str, Any]",
              "docstring": "Get strategy status.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 740
            },
            {
              "name": "validate_pattern",
              "module": "seasonality",
              "signature": "def validate_pattern(self, pattern: SeasonalWindow, price_data: np.ndarray, dates: np.ndarray, lookback_years: int) -> dict[str, Any]",
              "docstring": "Validate a seasonal pattern against historical price data.\n\nCalculates actual win rate and returns based on historical performance.\n\nArgs:\n    pattern: SeasonalWindow to validate\n    price_data: Historical prices (close prices)\n    dates: Corresponding dates as numpy datetime64 array\n    lookback_years: Years of history to analyze\n\nReturns:\n    Dictionary with validation metrics",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "pattern",
                  "type": "SeasonalWindow"
                },
                {
                  "name": "price_data",
                  "type": "np.ndarray"
                },
                {
                  "name": "dates",
                  "type": "np.ndarray"
                },
                {
                  "name": "lookback_years",
                  "type": "int"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 757
            },
            {
              "name": "update_pattern_from_history",
              "module": "seasonality",
              "signature": "def update_pattern_from_history(self, symbol: str, pattern_name: str, price_data: np.ndarray, dates: np.ndarray, lookback_years: int) -> bool",
              "docstring": "Update pattern's win rate and avg return based on historical data.\n\nArgs:\n    symbol: Symbol to update\n    pattern_name: Name of pattern to update\n    price_data: Historical prices\n    dates: Corresponding dates\n    lookback_years: Years to analyze\n\nReturns:\n    True if pattern was updated, False otherwise",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "pattern_name",
                  "type": "str"
                },
                {
                  "name": "price_data",
                  "type": "np.ndarray"
                },
                {
                  "name": "dates",
                  "type": "np.ndarray"
                },
                {
                  "name": "lookback_years",
                  "type": "int"
                }
              ],
              "return_type": "bool",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 864
            },
            {
              "name": "calculate_pattern_confluence",
              "module": "seasonality",
              "signature": "def calculate_pattern_confluence(self, symbol: str, check_date: ) -> dict[str, Any]",
              "docstring": "Calculate pattern confluence score for a symbol.\n\nMultiple overlapping patterns in same direction = stronger signal.\nConflicting patterns = weaker signal.\n\nArgs:\n    symbol: Symbol to analyze\n    check_date: Date to check\n\nReturns:\n    Dictionary with confluence analysis",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                },
                {
                  "name": "check_date",
                  "type": ""
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 919
            },
            {
              "name": "get_monthly_bias",
              "module": "seasonality",
              "signature": "def get_monthly_bias(self, symbol: str) -> dict[int, dict[str, float]]",
              "docstring": "Get monthly directional bias for a symbol based on all patterns.\n\nReturns:\n    Dictionary of month -> {\"long\": score, \"short\": score, \"net\": bias}",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "dict[int, dict[str, float]]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 986
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 500
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy"
      ],
      "dependencies": [
        "__future__",
        "numpy"
      ]
    },
    "strategies.stat_arb_strategy": {
      "name": "stat_arb_strategy",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\strategies\\stat_arb_strategy.py",
      "docstring": "Statistical Arbitrage Strategy\n==============================\n\nImplements pairs trading, mean reversion, and commodity spreads.\n\nMATURITY: BETA\n--------------\nStatus: Comprehensive implementation with commodity spreads\n- [x] Cointegration testing (simplified ADF)\n- [x] Hedge ratio estimation (OLS)\n- [x] Half-life calculation (OU process)\n- [x] Commodity spreads (crack, crush, inter-commodity)\n- [x] Optimal lag selection for ADF (#Q3)\n- [x] Dollar-neutral spread sizing\n- [ ] Johansen cointegration test (TODO)\n- [ ] Kalman filter for dynamic hedge ratio (TODO)\n- [ ] Transaction cost modeling (TODO)\n\nProduction Readiness:\n- Unit tests: Partial coverage\n- Backtesting: Spread definitions validated historically\n- Live testing: Not yet performed\n\nUse in production: WITH CAUTION\n- Commodity spread ratios are industry-standard\n- ADF test is simplified; production should use statsmodels\n- Monitor half-life for regime changes\n\nFeatures:\n- Pairs trading (cointegration-based)\n- Commodity spreads (crack, crush, calendar)\n- Contract specs integration for proper sizing",
      "classes": [
        {
          "name": "SpreadType",
          "module": "stat_arb_strategy",
          "docstring": "Types of spread trades.",
          "bases": [
            "Enum"
          ],
          "methods": [],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 51
        },
        {
          "name": "CommoditySpread",
          "module": "stat_arb_strategy",
          "docstring": "Definition of a commodity spread trade.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "spread_type",
              "type": "SpreadType"
            },
            {
              "name": "legs",
              "type": "dict[str, float]"
            },
            {
              "name": "description",
              "type": "str"
            },
            {
              "name": "typical_range",
              "type": "tuple[float, float]"
            },
            {
              "name": "seasonality",
              "type": "list[int]"
            },
            {
              "name": "margin_offset_pct",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 61
        },
        {
          "name": "SpreadAnalysis",
          "module": "stat_arb_strategy",
          "docstring": "Analysis results for a spread trade.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "spread_name",
              "type": "str"
            },
            {
              "name": "spread_type",
              "type": "SpreadType"
            },
            {
              "name": "current_value",
              "type": "float"
            },
            {
              "name": "zscore",
              "type": "float"
            },
            {
              "name": "percentile",
              "type": "float"
            },
            {
              "name": "mean",
              "type": "float"
            },
            {
              "name": "std",
              "type": "float"
            },
            {
              "name": "half_life",
              "type": "float"
            },
            {
              "name": "is_tradeable",
              "type": "bool"
            },
            {
              "name": "signal_direction",
              "type": "str"
            },
            {
              "name": "signal_strength",
              "type": "float"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 281
        },
        {
          "name": "PairAnalysis",
          "module": "stat_arb_strategy",
          "docstring": "Analysis results for a trading pair.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol_a",
              "type": "str"
            },
            {
              "name": "symbol_b",
              "type": "str"
            },
            {
              "name": "correlation",
              "type": "float"
            },
            {
              "name": "cointegration_pvalue",
              "type": "float"
            },
            {
              "name": "hedge_ratio",
              "type": "float"
            },
            {
              "name": "half_life",
              "type": "float"
            },
            {
              "name": "current_zscore",
              "type": "float"
            },
            {
              "name": "is_cointegrated",
              "type": "bool"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 297
        },
        {
          "name": "StatArbStrategy",
          "module": "stat_arb_strategy",
          "docstring": "Statistical Arbitrage Strategy Implementation.\n\nImplements:\n1. Cointegration testing (Engle-Granger)\n2. Hedge ratio estimation\n3. Mean reversion signal generation\n\nTODO: Implement proper models:\n- Johansen cointegration test\n- Kalman filter for dynamic hedge ratio\n- Ornstein-Uhlenbeck for half-life\n- Transaction cost modeling",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "stat_arb_strategy",
              "signature": "def __init__(self, config: dict[str, Any])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "config",
                  "type": "dict[str, Any]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 325
            },
            {
              "name": "test_cointegration",
              "module": "stat_arb_strategy",
              "signature": "def test_cointegration(self, prices_a: np.ndarray, prices_b: np.ndarray) -> PairAnalysis",
              "docstring": "Test for cointegration between two price series.\n\nTODO: Implement proper cointegration tests:\n- Augmented Dickey-Fuller on residuals\n- Johansen test for multiple series",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices_a",
                  "type": "np.ndarray"
                },
                {
                  "name": "prices_b",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "PairAnalysis",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 332
            },
            {
              "name": "_estimate_hedge_ratio",
              "module": "stat_arb_strategy",
              "signature": "def _estimate_hedge_ratio(self, prices_a: np.ndarray, prices_b: np.ndarray) -> float",
              "docstring": "Estimate hedge ratio using OLS.\n\nTODO: Implement more robust methods:\n- Total Least Squares (orthogonal regression)\n- Kalman filter for time-varying beta",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices_a",
                  "type": "np.ndarray"
                },
                {
                  "name": "prices_b",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 396
            },
            {
              "name": "_select_optimal_lag",
              "module": "stat_arb_strategy",
              "signature": "def _select_optimal_lag(self, series: np.ndarray, max_lags: , method: str) -> int",
              "docstring": "Select optimal lag for ADF test using information criteria (#Q3).\n\nMethods:\n- 'aic': Akaike Information Criterion (default)\n- 'bic': Bayesian Information Criterion\n- 'schwert': Schwert's rule: int(12 * (n/100)^(1/4))\n\nArgs:\n    series: Time series data\n    max_lags: Maximum lags to consider (default: Schwert's rule)\n    method: Selection method\n\nReturns:\n    Optimal number of lags",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "series",
                  "type": "np.ndarray"
                },
                {
                  "name": "max_lags",
                  "type": ""
                },
                {
                  "name": "method",
                  "type": "str"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 427
            },
            {
              "name": "_adf_test",
              "module": "stat_arb_strategy",
              "signature": "def _adf_test(self, series: np.ndarray, max_lags: , lag_method: str) -> tuple[float, float, int]",
              "docstring": "Augmented Dickey-Fuller test for stationarity with optimal lag selection (#Q3).\n\nTests H0: series has a unit root (non-stationary)\nvs H1: series is stationary (mean-reverting)\n\nArgs:\n    series: Time series data\n    max_lags: Maximum lags to consider (None = auto using Schwert's rule)\n    lag_method: Lag selection method ('aic', 'bic', 'schwert')\n\nReturns:\n    (test_statistic, p_value, selected_lags)",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "series",
                  "type": "np.ndarray"
                },
                {
                  "name": "max_lags",
                  "type": ""
                },
                {
                  "name": "lag_method",
                  "type": "str"
                }
              ],
              "return_type": "tuple[float, float, int]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 520
            },
            {
              "name": "_simplified_adf_test",
              "module": "stat_arb_strategy",
              "signature": "def _simplified_adf_test(self, series: np.ndarray) -> float",
              "docstring": "Wrapper for backward compatibility.\n\nReturns p-value from ADF test with optimal lag selection (#Q3).",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "series",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 629
            },
            {
              "name": "_estimate_half_life",
              "module": "stat_arb_strategy",
              "signature": "def _estimate_half_life(self, spread: np.ndarray) -> float",
              "docstring": "Estimate mean reversion half-life.\n\nUses Ornstein-Uhlenbeck process:\ndX = theta * (mu - X) * dt + sigma * dW\n\nHalf-life = ln(2) / theta\n\nTODO: Implement proper OU estimation via MLE.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread",
                  "type": "np.ndarray"
                }
              ],
              "return_type": "float",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 639
            },
            {
              "name": "generate_signal",
              "module": "stat_arb_strategy",
              "signature": "def generate_signal(self, analysis: PairAnalysis) -> dict[str, Any]",
              "docstring": "Generate trading signal from pair analysis.\n\nReturns signal dict with direction and strength.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "analysis",
                  "type": "PairAnalysis"
                }
              ],
              "return_type": "dict[str, Any]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 684
            },
            {
              "name": "analyze_spread",
              "module": "stat_arb_strategy",
              "signature": "def analyze_spread(self, spread_name: str, prices: dict[str, np.ndarray], lookback: )",
              "docstring": "Analyze a commodity spread.\n\nArgs:\n    spread_name: Name of predefined spread\n    prices: Dictionary of symbol to price arrays\n    lookback: Lookback period (default: self._lookback)\n\nReturns:\n    SpreadAnalysis or None if spread can't be computed",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread_name",
                  "type": "str"
                },
                {
                  "name": "prices",
                  "type": "dict[str, np.ndarray]"
                },
                {
                  "name": "lookback",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 731
            },
            {
              "name": "_calculate_spread_value",
              "module": "stat_arb_strategy",
              "signature": "def _calculate_spread_value(self, spread_def: CommoditySpread, prices: dict[str, np.ndarray], lookback: int, contract_specs: , use_multipliers: bool) -> np.ndarray",
              "docstring": "Calculate spread value time series.\n\nArgs:\n    spread_def: Spread definition\n    prices: Price series by symbol\n    lookback: Number of periods\n    contract_specs: Contract specifications (optional)\n    use_multipliers: If True, multiply by contract multipliers for\n                   dollar-based spread value (vs price-based)\n\nReturns:\n    Array of spread values",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread_def",
                  "type": "CommoditySpread"
                },
                {
                  "name": "prices",
                  "type": "dict[str, np.ndarray]"
                },
                {
                  "name": "lookback",
                  "type": "int"
                },
                {
                  "name": "contract_specs",
                  "type": ""
                },
                {
                  "name": "use_multipliers",
                  "type": "bool"
                }
              ],
              "return_type": "np.ndarray",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 817
            },
            {
              "name": "get_spread_legs",
              "module": "stat_arb_strategy",
              "signature": "def get_spread_legs(self, spread_name: str)",
              "docstring": "Get the legs (symbols and ratios) for a spread.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread_name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 862
            },
            {
              "name": "calculate_spread_position_sizes",
              "module": "stat_arb_strategy",
              "signature": "def calculate_spread_position_sizes(self, spread_name: str, notional_value: float, prices: dict[str, float], contract_specs: , round_to_integer: bool)",
              "docstring": "Calculate position sizes for spread legs with proper multiplier handling.\n\nArgs:\n    spread_name: Spread name\n    notional_value: Total notional value to allocate\n    prices: Current prices\n    contract_specs: Contract specifications (multipliers)\n    round_to_integer: Whether to round to integer contracts\n\nReturns:\n    Dictionary of symbol to number of contracts\n\nNote on ratio interpretation:\n- Ratios in spread definitions are CONTRACT ratios, not price ratios\n- For example, gold/silver ratio of 1:-1.6 means:\n  1 GC contract ($200k) vs 1.6 SI contracts (~$200k) = dollar-neutral",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread_name",
                  "type": "str"
                },
                {
                  "name": "notional_value",
                  "type": "float"
                },
                {
                  "name": "prices",
                  "type": "dict[str, float]"
                },
                {
                  "name": "contract_specs",
                  "type": ""
                },
                {
                  "name": "round_to_integer",
                  "type": "bool"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 868
            },
            {
              "name": "calculate_dollar_neutral_spread",
              "module": "stat_arb_strategy",
              "signature": "def calculate_dollar_neutral_spread(self, spread_name: str, target_notional: float, prices: dict[str, float], contract_specs: )",
              "docstring": "Calculate dollar-neutral position sizes for a spread.\n\nThis ensures each leg has approximately equal dollar exposure,\nwhich may differ from the defined contract ratios for some spreads.\n\nArgs:\n    spread_name: Spread name\n    target_notional: Target notional per leg\n    prices: Current prices\n    contract_specs: Contract specifications (multipliers)\n\nReturns:\n    Dictionary of symbol to number of contracts",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread_name",
                  "type": "str"
                },
                {
                  "name": "target_notional",
                  "type": "float"
                },
                {
                  "name": "prices",
                  "type": "dict[str, float]"
                },
                {
                  "name": "contract_specs",
                  "type": ""
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 966
            },
            {
              "name": "get_all_spreads",
              "module": "stat_arb_strategy",
              "signature": "def get_all_spreads(self) -> list[str]",
              "docstring": "Get list of all available spread names.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1030
            },
            {
              "name": "get_spreads_by_type",
              "module": "stat_arb_strategy",
              "signature": "def get_spreads_by_type(self, spread_type: SpreadType) -> list[str]",
              "docstring": "Get spreads of a specific type.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread_type",
                  "type": "SpreadType"
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1034
            },
            {
              "name": "get_spread_info",
              "module": "stat_arb_strategy",
              "signature": "def get_spread_info(self, spread_name: str)",
              "docstring": "Get detailed spread information.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "spread_name",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1041
            },
            {
              "name": "scan_all_spreads",
              "module": "stat_arb_strategy",
              "signature": "def scan_all_spreads(self, prices: dict[str, np.ndarray]) -> list[SpreadAnalysis]",
              "docstring": "Scan all spreads and return those with signals.\n\nArgs:\n    prices: Price data for all symbols\n\nReturns:\n    List of SpreadAnalysis for spreads with active signals",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "prices",
                  "type": "dict[str, np.ndarray]"
                }
              ],
              "return_type": "list[SpreadAnalysis]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1045
            },
            {
              "name": "get_seasonal_spreads",
              "module": "stat_arb_strategy",
              "signature": "def get_seasonal_spreads(self, month: ) -> list[str]",
              "docstring": "Get spreads that are seasonally favorable.\n\nArgs:\n    month: Month to check (1-12), default is current month\n\nReturns:\n    List of spread names",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "month",
                  "type": ""
                }
              ],
              "return_type": "list[str]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 1070
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 309
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "numpy",
        "scipy"
      ],
      "dependencies": [
        "__future__",
        "numpy",
        "scipy"
      ]
    },
    "strategies.__init__": {
      "name": "__init__",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\strategies\\__init__.py",
      "docstring": "AI Trading Firm - Strategies Module\n====================================\n\nStrategy implementations for signal generation.\nEach strategy is used by its corresponding agent.\n\nNOTE: Strategies contain the logic, agents orchestrate execution.",
      "classes": [],
      "functions": [],
      "constants": [],
      "imports": [
        "strategies.macro_strategy",
        "strategies.stat_arb_strategy",
        "strategies.momentum_strategy",
        "strategies.market_making_strategy",
        "strategies.options_vol_strategy"
      ],
      "dependencies": [
        "strategies.macro_strategy",
        "strategies.stat_arb_strategy",
        "strategies.momentum_strategy",
        "strategies.market_making_strategy",
        "strategies.options_vol_strategy"
      ]
    },
    "data.market_data": {
      "name": "market_data",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\data\\market_data.py",
      "docstring": "Market Data Manager\n===================\n\nCentralizes market data handling from Interactive Brokers.\nDistributes data to all agents via the event bus.",
      "classes": [
        {
          "name": "SymbolConfig",
          "module": "market_data",
          "docstring": "Configuration for a symbol subscription.",
          "bases": [],
          "methods": [],
          "class_attributes": [
            {
              "name": "symbol",
              "type": "str"
            },
            {
              "name": "exchange",
              "type": "str"
            },
            {
              "name": "currency",
              "type": "str"
            },
            {
              "name": "sec_type",
              "type": "str"
            }
          ],
          "instance_attributes": [],
          "decorators": [
            "dataclass"
          ],
          "line_number": 28
        },
        {
          "name": "MarketDataManager",
          "module": "market_data",
          "docstring": "Market Data Manager.\n\nResponsibilities:\n- Subscribe to market data from Interactive Brokers\n- Transform raw data into MarketDataEvents\n- Publish events to the event bus\n- Handle reconnection and data quality\n\nThis is the ONLY source of market data in the system.",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "module": "market_data",
              "signature": "def __init__(self, broker: IBBroker, event_bus: EventBus, symbols: list[SymbolConfig])",
              "docstring": "",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "broker",
                  "type": "IBBroker"
                },
                {
                  "name": "event_bus",
                  "type": "EventBus"
                },
                {
                  "name": "symbols",
                  "type": "list[SymbolConfig]"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 49
            },
            {
              "name": "start",
              "module": "market_data",
              "signature": "async def start(self) -> None",
              "docstring": "Start market data subscriptions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 62
            },
            {
              "name": "stop",
              "module": "market_data",
              "signature": "async def stop(self) -> None",
              "docstring": "Stop market data subscriptions.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 84
            },
            {
              "name": "_handle_market_data",
              "module": "market_data",
              "signature": "def _handle_market_data(self, event: MarketDataEvent) -> None",
              "docstring": "Handle incoming market data from broker.\n\nThis is called synchronously by the broker, so we need to\nschedule the async publish.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 96
            },
            {
              "name": "_publish_event",
              "module": "market_data",
              "signature": "async def _publish_event(self, event: MarketDataEvent) -> None",
              "docstring": "Publish market data event to the bus.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "event",
                  "type": "MarketDataEvent"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 112
            },
            {
              "name": "generate_simulated_data",
              "module": "market_data",
              "signature": "async def generate_simulated_data(self) -> None",
              "docstring": "Generate simulated market data for testing.\n\nUsed when IB connection is not available (development/testing).",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "None",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": true,
              "line_number": 119
            },
            {
              "name": "get_last_price",
              "module": "market_data",
              "signature": "def get_last_price(self, symbol: str)",
              "docstring": "Get last known price for a symbol.",
              "parameters": [
                {
                  "name": "self"
                },
                {
                  "name": "symbol",
                  "type": "str"
                }
              ],
              "return_type": "",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 172
            },
            {
              "name": "get_all_prices",
              "module": "market_data",
              "signature": "def get_all_prices(self) -> dict[str, float]",
              "docstring": "Get all last known prices.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "dict[str, float]",
              "raises": [],
              "examples": [],
              "decorators": [],
              "is_async": false,
              "line_number": 176
            },
            {
              "name": "update_count",
              "module": "market_data",
              "signature": "def update_count(self) -> int",
              "docstring": "Total market data updates processed.",
              "parameters": [
                {
                  "name": "self"
                }
              ],
              "return_type": "int",
              "raises": [],
              "examples": [],
              "decorators": [
                "property"
              ],
              "is_async": false,
              "line_number": 181
            }
          ],
          "class_attributes": [],
          "instance_attributes": [],
          "decorators": [],
          "line_number": 36
        }
      ],
      "functions": [],
      "constants": [],
      "imports": [
        "__future__",
        "asyncio",
        "logging",
        "dataclasses",
        "datetime",
        "typing",
        "core.events",
        "core.event_bus",
        "core.broker",
        "random"
      ],
      "dependencies": [
        "__future__",
        "core.events",
        "core.event_bus",
        "core.broker",
        "random"
      ]
    },
    "data.__init__": {
      "name": "__init__",
      "path": "C:\\Users\\Alexa\\ai-trading-firm\\data\\__init__.py",
      "docstring": "AI Trading Firm - Data Module\n==============================\n\nData handling and market data distribution.",
      "classes": [],
      "functions": [],
      "constants": [],
      "imports": [
        "data.market_data"
      ],
      "dependencies": [
        "data.market_data"
      ]
    }
  }
}