"""
Event Definitions
=================

All events in the system are immutable and traceable.
Each event carries metadata for audit compliance (EU/AMF).
"""

from __future__ import annotations

import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any


class EventType(Enum):
    """Enumeration of all event types in the system."""
    MARKET_DATA = "market_data"
    SIGNAL = "signal"
    DECISION = "decision"
    VALIDATED_DECISION = "validated_decision"
    ORDER = "order"
    FILL = "fill"
    RISK_ALERT = "risk_alert"
    SYSTEM = "system"
    # New event types for enhanced functionality
    ROLL_SIGNAL = "roll_signal"
    ROLL_COMPLETE = "roll_complete"
    SURVEILLANCE_ALERT = "surveillance_alert"
    TRANSACTION_REPORT = "transaction_report"
    STRESS_TEST_RESULT = "stress_test_result"
    CORRELATION_ALERT = "correlation_alert"
    GREEKS_UPDATE = "greeks_update"
    # MiFID II RTS 6 compliance - emergency stop functionality
    KILL_SWITCH = "kill_switch"
    # Order state tracking
    ORDER_STATE_CHANGE = "order_state_change"


class SignalDirection(Enum):
    """Trading signal direction."""
    LONG = "long"
    SHORT = "short"
    FLAT = "flat"


class OrderSide(Enum):
    """Order side."""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """Order type."""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class TimeInForce(Enum):
    """
    Time in force instruction for orders (#E7).

    Specifies how long an order remains active.
    """
    DAY = "DAY"        # Valid for the trading day
    GTC = "GTC"        # Good Till Cancelled
    IOC = "IOC"        # Immediate or Cancel - fill what you can immediately, cancel rest
    FOK = "FOK"        # Fill or Kill - fill entire quantity immediately or cancel
    GTD = "GTD"        # Good Till Date
    OPG = "OPG"        # At the Opening
    MOC = "MOC"        # Market on Close


class RiskAlertSeverity(Enum):
    """Risk alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


@dataclass(frozen=True)
class Event:
    """
    Base event class.

    All events are immutable (frozen) to ensure audit trail integrity.
    """
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    event_type: EventType = EventType.SYSTEM
    source_agent: str = "unknown"

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert event to dictionary for audit logging."""
        return {
            "event_id": self.event_id,
            "timestamp": self.timestamp.isoformat(),
            "event_type": self.event_type.value,
            "source_agent": self.source_agent,
        }


@dataclass(frozen=True)
class MarketDataEvent(Event):
    """
    Market data tick event from Interactive Brokers.
    """
    event_type: EventType = field(default=EventType.MARKET_DATA, init=False)
    symbol: str = ""
    exchange: str = ""
    bid: float = 0.0
    ask: float = 0.0
    last: float = 0.0
    volume: int = 0
    bid_size: int = 0
    ask_size: int = 0
    high: float = 0.0
    low: float = 0.0
    open_price: float = 0.0
    close: float = 0.0

    @property
    def mid(self) -> float:
        """Calculate mid price."""
        if self.bid > 0 and self.ask > 0:
            return (self.bid + self.ask) / 2
        return self.last

    @property
    def spread(self) -> float:
        """Calculate bid-ask spread."""
        if self.bid > 0 and self.ask > 0:
            return self.ask - self.bid
        return 0.0

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "symbol": self.symbol,
            "exchange": self.exchange,
            "bid": self.bid,
            "ask": self.ask,
            "last": self.last,
            "volume": self.volume,
            "high": self.high,
            "low": self.low,
            "open": self.open_price,
            "close": self.close,
        })
        return base


@dataclass(frozen=True)
class SignalEvent(Event):
    """
    Trading signal generated by a strategy agent.

    Signals are advisory only - they do NOT trigger orders directly.
    Only the CIO agent can make trading decisions.
    """
    event_type: EventType = field(default=EventType.SIGNAL, init=False)
    strategy_name: str = ""
    symbol: str = ""
    direction: SignalDirection = SignalDirection.FLAT
    strength: float = 0.0  # -1.0 to 1.0
    confidence: float = 0.0  # 0.0 to 1.0
    target_price: float | None = None
    stop_loss: float | None = None
    rationale: str = ""  # Required for compliance
    data_sources: tuple[str, ...] = ()  # Required for compliance

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary with full traceability."""
        base = super().to_audit_dict()
        base.update({
            "strategy_name": self.strategy_name,
            "symbol": self.symbol,
            "direction": self.direction.value,
            "strength": self.strength,
            "confidence": self.confidence,
            "target_price": self.target_price,
            "stop_loss": self.stop_loss,
            "rationale": self.rationale,
            "data_sources": list(self.data_sources),
        })
        return base


@dataclass(frozen=True)
class DecisionEvent(Event):
    """
    Trading decision made by the CIO agent.

    This is the ONLY event that can lead to order creation.
    Must include full rationale and data sources for compliance.
    """
    event_type: EventType = field(default=EventType.DECISION, init=False)
    symbol: str = ""
    action: OrderSide | None = None
    quantity: int = 0
    order_type: OrderType = OrderType.LIMIT
    limit_price: float | None = None
    stop_price: float | None = None
    rationale: str = ""  # Required - why this decision was made
    contributing_signals: tuple[str, ...] = ()  # Signal IDs that contributed
    data_sources: tuple[str, ...] = ()  # All data sources used
    conviction_score: float = 0.0  # 0.0 to 1.0

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary with full compliance data."""
        base = super().to_audit_dict()
        base.update({
            "symbol": self.symbol,
            "action": self.action.value if self.action else None,
            "quantity": self.quantity,
            "order_type": self.order_type.value,
            "limit_price": self.limit_price,
            "stop_price": self.stop_price,
            "rationale": self.rationale,
            "contributing_signals": list(self.contributing_signals),
            "data_sources": list(self.data_sources),
            "conviction_score": self.conviction_score,
        })
        return base


@dataclass(frozen=True)
class ValidatedDecisionEvent(Event):
    """
    Decision validated by Risk & Compliance agent.

    Only validated decisions can be executed.
    """
    event_type: EventType = field(default=EventType.VALIDATED_DECISION, init=False)
    original_decision_id: str = ""
    approved: bool = False
    adjusted_quantity: int | None = None  # Risk may reduce size
    rejection_reason: str | None = None
    risk_metrics: dict[str, float] = field(default_factory=dict)
    compliance_checks: tuple[str, ...] = ()  # List of passed checks

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "original_decision_id": self.original_decision_id,
            "approved": self.approved,
            "adjusted_quantity": self.adjusted_quantity,
            "rejection_reason": self.rejection_reason,
            "risk_metrics": dict(self.risk_metrics),
            "compliance_checks": list(self.compliance_checks),
        })
        return base


@dataclass(frozen=True)
class OrderEvent(Event):
    """
    Order event sent to broker.

    Only the Execution Agent can create these.
    """
    event_type: EventType = field(default=EventType.ORDER, init=False)
    decision_id: str = ""
    validation_id: str = ""
    symbol: str = ""
    side: OrderSide = OrderSide.BUY
    quantity: int = 0
    order_type: OrderType = OrderType.LIMIT
    limit_price: float | None = None
    stop_price: float | None = None
    broker_order_id: int | None = None
    algo: str = "TWAP"  # Execution algorithm
    time_in_force: TimeInForce = TimeInForce.DAY  # Time in force instruction (#E7)

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "decision_id": self.decision_id,
            "validation_id": self.validation_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "quantity": self.quantity,
            "order_type": self.order_type.value,
            "limit_price": self.limit_price,
            "stop_price": self.stop_price,
            "broker_order_id": self.broker_order_id,
            "time_in_force": self.time_in_force.value,
            "algo": self.algo,
        })
        return base


@dataclass(frozen=True)
class FillEvent(Event):
    """
    Order fill event from broker.
    """
    event_type: EventType = field(default=EventType.FILL, init=False)
    order_id: str = ""
    broker_order_id: int = 0
    symbol: str = ""
    side: OrderSide = OrderSide.BUY
    filled_quantity: int = 0
    fill_price: float = 0.0
    commission: float = 0.0
    exchange: str = ""

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "order_id": self.order_id,
            "broker_order_id": self.broker_order_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "filled_quantity": self.filled_quantity,
            "fill_price": self.fill_price,
            "commission": self.commission,
            "exchange": self.exchange,
        })
        return base


@dataclass(frozen=True)
class RiskAlertEvent(Event):
    """
    Risk alert event.

    CRITICAL and EMERGENCY alerts will halt trading.
    """
    event_type: EventType = field(default=EventType.RISK_ALERT, init=False)
    severity: RiskAlertSeverity = RiskAlertSeverity.INFO
    alert_type: str = ""
    message: str = ""
    current_value: float = 0.0
    threshold_value: float = 0.0
    affected_symbols: tuple[str, ...] = ()
    halt_trading: bool = False

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "severity": self.severity.value,
            "alert_type": self.alert_type,
            "message": self.message,
            "current_value": self.current_value,
            "threshold_value": self.threshold_value,
            "affected_symbols": list(self.affected_symbols),
            "halt_trading": self.halt_trading,
        })
        return base


# =============================================================================
# NEW EVENT TYPES FOR ENHANCED FUNCTIONALITY
# =============================================================================


@dataclass(frozen=True)
class RollSignalEvent(Event):
    """
    Futures roll signal event.

    Generated when a futures contract approaches expiry and needs to be rolled.
    """
    event_type: EventType = field(default=EventType.ROLL_SIGNAL, init=False)
    symbol: str = ""
    from_contract: str = ""
    to_contract: str = ""
    days_to_expiry: int = 0
    roll_date: str = ""  # ISO format date
    urgency: str = "normal"  # "normal", "urgent", "critical"

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "symbol": self.symbol,
            "from_contract": self.from_contract,
            "to_contract": self.to_contract,
            "days_to_expiry": self.days_to_expiry,
            "roll_date": self.roll_date,
            "urgency": self.urgency,
        })
        return base


@dataclass(frozen=True)
class RollCompleteEvent(Event):
    """
    Futures roll completion event.

    Generated when a roll has been successfully completed.
    """
    event_type: EventType = field(default=EventType.ROLL_COMPLETE, init=False)
    symbol: str = ""
    from_contract: str = ""
    to_contract: str = ""
    price_adjustment: float = 0.0
    rolled_quantity: int = 0

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "symbol": self.symbol,
            "from_contract": self.from_contract,
            "to_contract": self.to_contract,
            "price_adjustment": self.price_adjustment,
            "rolled_quantity": self.rolled_quantity,
        })
        return base


@dataclass(frozen=True)
class SurveillanceAlertEvent(Event):
    """
    Market surveillance alert event.

    Generated when potential market abuse is detected.
    """
    event_type: EventType = field(default=EventType.SURVEILLANCE_ALERT, init=False)
    alert_type: str = ""  # "wash_trading", "spoofing", "layering", etc.
    severity: str = "medium"
    symbol: str = ""
    description: str = ""
    evidence: tuple[str, ...] = ()
    requires_review: bool = True

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "alert_type": self.alert_type,
            "severity": self.severity,
            "symbol": self.symbol,
            "description": self.description,
            "evidence": list(self.evidence),
            "requires_review": self.requires_review,
        })
        return base


@dataclass(frozen=True)
class TransactionReportEvent(Event):
    """
    Transaction reporting event.

    Generated when a transaction report is submitted to regulators.
    """
    event_type: EventType = field(default=EventType.TRANSACTION_REPORT, init=False)
    report_id: str = ""
    transaction_reference: str = ""
    symbol: str = ""
    quantity: float = 0.0
    price: float = 0.0
    status: str = "submitted"  # "submitted", "accepted", "rejected"
    regulator: str = "AMF"

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "report_id": self.report_id,
            "transaction_reference": self.transaction_reference,
            "symbol": self.symbol,
            "quantity": self.quantity,
            "price": self.price,
            "status": self.status,
            "regulator": self.regulator,
        })
        return base


@dataclass(frozen=True)
class StressTestResultEvent(Event):
    """
    Stress test result event.

    Generated when a stress test scenario is run.
    """
    event_type: EventType = field(default=EventType.STRESS_TEST_RESULT, init=False)
    scenario_id: str = ""
    scenario_name: str = ""
    pnl_impact: float = 0.0
    pnl_impact_pct: float = 0.0
    passes_limit: bool = True
    limit_breaches: tuple[str, ...] = ()

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "scenario_id": self.scenario_id,
            "scenario_name": self.scenario_name,
            "pnl_impact": self.pnl_impact,
            "pnl_impact_pct": self.pnl_impact_pct,
            "passes_limit": self.passes_limit,
            "limit_breaches": list(self.limit_breaches),
        })
        return base


@dataclass(frozen=True)
class CorrelationAlertEvent(Event):
    """
    Correlation regime alert event.

    Generated when correlation patterns change significantly.
    """
    event_type: EventType = field(default=EventType.CORRELATION_ALERT, init=False)
    alert_type: str = ""  # "regime_change", "threshold_breach", "concentration"
    previous_regime: str = ""
    new_regime: str = ""
    average_correlation: float = 0.0
    max_pairwise_correlation: float = 0.0
    affected_pairs: tuple[str, ...] = ()

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "alert_type": self.alert_type,
            "previous_regime": self.previous_regime,
            "new_regime": self.new_regime,
            "average_correlation": self.average_correlation,
            "max_pairwise_correlation": self.max_pairwise_correlation,
            "affected_pairs": list(self.affected_pairs),
        })
        return base


@dataclass(frozen=True)
class GreeksUpdateEvent(Event):
    """
    Portfolio Greeks update event.

    Generated when portfolio Greeks are recalculated.
    """
    event_type: EventType = field(default=EventType.GREEKS_UPDATE, init=False)
    portfolio_delta: float = 0.0
    portfolio_gamma: float = 0.0
    portfolio_vega: float = 0.0
    portfolio_theta: float = 0.0
    delta_limit_pct: float = 0.0
    gamma_limit_pct: float = 0.0
    vega_limit_pct: float = 0.0
    any_breach: bool = False

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "portfolio_delta": self.portfolio_delta,
            "portfolio_gamma": self.portfolio_gamma,
            "portfolio_vega": self.portfolio_vega,
            "portfolio_theta": self.portfolio_theta,
            "delta_limit_pct": self.delta_limit_pct,
            "gamma_limit_pct": self.gamma_limit_pct,
            "vega_limit_pct": self.vega_limit_pct,
            "any_breach": self.any_breach,
        })
        return base


@dataclass(frozen=True)
class KillSwitchEvent(Event):
    """
    Kill switch event for MiFID II RTS 6 compliance.

    Triggers immediate halt of all trading activity when activated.
    All pending orders should be cancelled and no new orders accepted.
    """
    event_type: EventType = field(default=EventType.KILL_SWITCH, init=False)
    activated: bool = True  # True to activate, False to deactivate
    reason: str = ""  # Reason for kill switch activation
    trigger_type: str = "manual"  # "manual", "automatic", "regulatory"
    affected_symbols: tuple[str, ...] = ()  # Empty = all symbols
    cancel_pending_orders: bool = True  # Cancel all pending orders
    close_positions: bool = False  # Whether to close all positions (liquidation)

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "activated": self.activated,
            "reason": self.reason,
            "trigger_type": self.trigger_type,
            "affected_symbols": list(self.affected_symbols),
            "cancel_pending_orders": self.cancel_pending_orders,
            "close_positions": self.close_positions,
        })
        return base


class OrderState(Enum):
    """Order state machine states per MiFID II requirements."""
    CREATED = "created"  # Order created but not yet submitted
    PENDING = "pending"  # Awaiting submission to broker
    SUBMITTED = "submitted"  # Sent to broker, awaiting acknowledgment
    ACKNOWLEDGED = "acknowledged"  # Broker acknowledged receipt
    PARTIAL = "partial"  # Partially filled
    FILLED = "filled"  # Completely filled
    CANCELLED = "cancelled"  # Cancelled by user or system
    REJECTED = "rejected"  # Rejected by broker
    EXPIRED = "expired"  # Order expired (e.g., day order at close)
    FAILED = "failed"  # Technical failure


# Valid state transitions
VALID_ORDER_TRANSITIONS: dict[OrderState, tuple[OrderState, ...]] = {
    OrderState.CREATED: (OrderState.PENDING, OrderState.CANCELLED),
    OrderState.PENDING: (OrderState.SUBMITTED, OrderState.CANCELLED, OrderState.FAILED),
    OrderState.SUBMITTED: (OrderState.ACKNOWLEDGED, OrderState.REJECTED, OrderState.FAILED),
    OrderState.ACKNOWLEDGED: (OrderState.PARTIAL, OrderState.FILLED, OrderState.CANCELLED, OrderState.EXPIRED),
    OrderState.PARTIAL: (OrderState.PARTIAL, OrderState.FILLED, OrderState.CANCELLED),
    OrderState.FILLED: (),  # Terminal state
    OrderState.CANCELLED: (),  # Terminal state
    OrderState.REJECTED: (),  # Terminal state
    OrderState.EXPIRED: (),  # Terminal state
    OrderState.FAILED: (),  # Terminal state
}


@dataclass(frozen=True)
class OrderStateChangeEvent(Event):
    """
    Order state change event for tracking order lifecycle.

    Provides full audit trail of order state transitions.
    """
    event_type: EventType = field(default=EventType.ORDER_STATE_CHANGE, init=False)
    order_id: str = ""
    broker_order_id: int | None = None
    symbol: str = ""
    previous_state: OrderState = OrderState.CREATED
    new_state: OrderState = OrderState.PENDING
    reason: str = ""  # Reason for state change
    filled_quantity: int = 0  # Running total filled
    remaining_quantity: int = 0  # Remaining to fill
    avg_fill_price: float = 0.0  # Average fill price so far

    def to_audit_dict(self) -> dict[str, Any]:
        """Convert to audit dictionary."""
        base = super().to_audit_dict()
        base.update({
            "order_id": self.order_id,
            "broker_order_id": self.broker_order_id,
            "symbol": self.symbol,
            "previous_state": self.previous_state.value,
            "new_state": self.new_state.value,
            "reason": self.reason,
            "filled_quantity": self.filled_quantity,
            "remaining_quantity": self.remaining_quantity,
            "avg_fill_price": self.avg_fill_price,
        })
        return base


def is_valid_state_transition(from_state: OrderState, to_state: OrderState) -> bool:
    """Check if a state transition is valid."""
    valid_targets = VALID_ORDER_TRANSITIONS.get(from_state, ())
    return to_state in valid_targets
